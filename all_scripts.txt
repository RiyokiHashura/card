--- FILE: ./src/server/Services/PolishEffectsService.luau ---
--!strict
-- PolishEffectsService.luau
-- Advanced visual effects service for premium polish
-- Manages screen effects, particles, impact frames, and visual juice

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local EffectsTypes = require(ReplicatedStorage.Shared.Types.EffectsTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type EffectsSystemState = EffectsTypes.EffectsSystemState
type ScreenEffect = EffectsTypes.ScreenEffect
type ParticleSystem = EffectsTypes.ParticleSystem
type ImpactFrame = EffectsTypes.ImpactFrame
type JuiceSequence = EffectsTypes.JuiceSequence
type PolishEffectsServiceConfig = EffectsTypes.PolishEffectsServiceConfig
type EffectsPerformanceConfig = EffectsTypes.EffectsPerformanceConfig

local PolishEffectsService = {}
PolishEffectsService.__index = PolishEffectsService
setmetatable(PolishEffectsService, {__index = BaseService})

function PolishEffectsService.new()
	local self = BaseService.new("PolishEffectsService", {"AudioService"})
	setmetatable(self, PolishEffectsService)
	
	-- Core State
	self._systemState = {
		IsInitialized = false,
		CurrentQualityLevel = 2, -- Start at medium-high quality
		ActiveScreenEffects = {},
		ActiveParticleSystems = {},
		ActiveImpactFrames = {},
		ActiveJuiceSequences = {},
		PerformanceConfig = self:_createDefaultPerformanceConfig(),
		ResearchData = self:_createResearchData(),
		FrameRate = 60,
		EffectCount = 0,
		ParticleCount = 0,
		LastOptimizationTime = 0
	} :: EffectsSystemState
	
	-- Configuration
	self._config = {
		EnableScreenEffects = true,
		EnableParticleEffects = true,
		EnableImpactFrames = true,
		EnableVisualJuice = true,
		AutoQualityAdjustment = true,
		MobileOptimizations = true,
		PerformanceMonitoring = true,
		DebugMode = false
	} :: PolishEffectsServiceConfig
	
	-- Effect Management
	self._effectInstances = {} :: {[string]: any}
	self._particlePools = {} :: {[string]: any}
	self._activeAnimations = {} :: {[string]: Tween}
	self._impactSequences = {} :: {[string]: any}
	
	-- Performance Tracking
	self._performanceMetrics = {
		FrameTime = 0,
		EffectFrameTime = 0,
		ParticleFrameTime = 0,
		MemoryUsage = 0,
		QualityAdjustments = 0
	}
	
	-- Research-based Impact Types
	self._impactTypes = self:_createImpactTypes()
	
	-- Visual Juice Presets
	self._juicePresets = self:_createJuicePresets()
	
	-- Events (using individual GetRemoteEvent calls)
	self._events = {
		ScreenEffectRequested = RemoteEventHandler:GetRemoteEvent("ScreenEffectRequested"),
		ParticleSystemRequested = RemoteEventHandler:GetRemoteEvent("ParticleSystemRequested"),
		ImpactFrameRequested = RemoteEventHandler:GetRemoteEvent("ImpactFrameRequested"),
		VisualJuiceRequested = RemoteEventHandler:GetRemoteEvent("VisualJuiceRequested"),
		QualityLevelChanged = RemoteEventHandler:GetRemoteEvent("QualityLevelChanged"),
		PerformanceMetricsUpdate = RemoteEventHandler:GetRemoteEvent("PerformanceMetricsUpdate")
	}
	
	return self
end

function PolishEffectsService:Initialize()
	self:_log("PolishEffectsService initializing...")
	
	-- Initialize performance monitoring
	self:_initializePerformanceMonitoring()
	
	-- Initialize particle pools
	self:_initializeParticlePools()
	
	-- Initialize screen effects system
	if self._config.EnableScreenEffects then
		self:_initializeScreenEffects()
	end
	
	-- Initialize impact frame system
	if self._config.EnableImpactFrames then
		self:_initializeImpactFrames()
	end
	
	-- Initialize visual juice system
	if self._config.EnableVisualJuice then
		self:_initializeVisualJuice()
	end
	
	-- Setup remote event handlers
	self:_setupRemoteEventHandlers()
	
	-- Apply mobile optimizations if needed
	if self._config.MobileOptimizations then
		self:_applyMobileOptimizations()
	end
	
	self._systemState.IsInitialized = true
	self:_log("PolishEffectsService initialized successfully")
end

function PolishEffectsService:Start()
	self:_log("PolishEffectsService starting...")
	
	-- Start effects update loop
	self:_startEffectsUpdateLoop()
	
	-- Start performance monitoring
	if self._config.PerformanceMonitoring then
		self:_startPerformanceMonitoring()
	end
	
	-- Start auto quality adjustment
	if self._config.AutoQualityAdjustment then
		self:_startAutoQualityAdjustment()
	end
	
	self:_log("PolishEffectsService started successfully")
end

function PolishEffectsService:Stop()
	self:_log("PolishEffectsService stopping...")
	
	-- Stop all effects
	self:StopAllEffects()
	
	-- Cleanup connections
	if self._effectsUpdateConnection then
		self._effectsUpdateConnection:Disconnect()
		self._effectsUpdateConnection = nil
	end
	
	if self._performanceMonitorConnection then
		self._performanceMonitorConnection:Disconnect()
		self._performanceMonitorConnection = nil
	end
	
	BaseService.Stop(self)
	self:_log("PolishEffectsService stopped")
end

-- Public API

-- Screen Effects
function PolishEffectsService:PlayScreenEffect(effectName: string, intensity: number?, duration: number?): string
	if not self._config.EnableScreenEffects or not self._systemState.IsInitialized then
		return ""
	end
	
	-- Check performance limits
	if #self._systemState.ActiveScreenEffects >= self._systemState.PerformanceConfig.MaxScreenEffects then
		self:_optimizeScreenEffects()
	end
	
	local effectID = self:_generateEffectID(effectName)
	
	-- Create screen effect based on research data
	local screenEffect = self:_createScreenEffect(effectName, intensity or 0.7, duration or 1.0)
	if not screenEffect then
		self:_logError("Failed to create screen effect: " .. effectName)
		return ""
	end
	
	-- Apply effect
	self:_applyScreenEffect(screenEffect, effectID)
	
	-- Track effect
	self._systemState.ActiveScreenEffects[effectID] = screenEffect
	self._systemState.EffectCount = self._systemState.EffectCount + 1
	
	-- Fire event to clients
	self._events.ScreenEffectRequested:FireAllClients(effectName, effectID, screenEffect)
	
	self:_log("Screen effect started: " .. effectName .. " (ID: " .. effectID .. ")")
	return effectID
end

-- Particle Systems
function PolishEffectsService:SpawnParticleSystem(systemName: string, position: Vector3, config: any?): string
	if not self._config.EnableParticleEffects or not self._systemState.IsInitialized then
		return ""
	end
	
	-- Check performance limits
	if #self._systemState.ActiveParticleSystems >= self._systemState.PerformanceConfig.MaxParticleSystems then
		self:_optimizeParticleSystems()
	end
	
	local systemID = self:_generateEffectID(systemName)
	
	-- Create particle system with pooling
	local particleSystem = self:_createParticleSystem(systemName, position, config)
	if not particleSystem then
		self:_logError("Failed to create particle system: " .. systemName)
		return ""
	end
	
	-- Spawn particles using pooled objects
	self:_spawnParticlesFromPool(particleSystem, systemID)
	
	-- Track system
	self._systemState.ActiveParticleSystems[systemID] = particleSystem
	self._systemState.EffectCount = self._systemState.EffectCount + 1
	
	-- Fire event to clients
	self._events.ParticleSystemRequested:FireAllClients(systemName, systemID, position, config)
	
	self:_log("Particle system spawned: " .. systemName .. " (ID: " .. systemID .. ")")
	return systemID
end

-- Impact Frames (Research-based timing)
function PolishEffectsService:TriggerImpactFrame(impactType: string, intensity: number?, position: Vector3?): string
	if not self._config.EnableImpactFrames or not self._systemState.IsInitialized then
		return ""
	end
	
	local frameID = self:_generateEffectID(impactType .. "_impact")
	
	-- Get research-based impact frame configuration
	local impactFrame = self:_getImpactFrame(impactType, intensity or 0.7)
	if not impactFrame then
		self:_logError("Unknown impact type: " .. impactType)
		return ""
	end
	
	-- Apply frame timing with research precision
	self:_executeImpactFrame(impactFrame, frameID, position)
	
	-- Track impact frame
	self._systemState.ActiveImpactFrames[frameID] = impactFrame
	
	-- Sync with audio system
	local audioService = self:GetService("AudioService")
	if audioService then
		audioService:TriggerPsychologicalEvent("ImpactFrame", intensity or 0.7, impactFrame.Duration)
	end
	
	-- Fire event to clients
	self._events.ImpactFrameRequested:FireAllClients(impactType, frameID, impactFrame)
	
	self:_log("Impact frame triggered: " .. impactType .. " (ID: " .. frameID .. ")")
	return frameID
end

-- Visual Juice Effects
function PolishEffectsService:PlayVisualJuice(sequenceName: string, targetObject: Instance?, config: any?): string
	if not self._config.EnableVisualJuice or not self._systemState.IsInitialized then
		return ""
	end
	
	local juiceID = self:_generateEffectID(sequenceName .. "_juice")
	
	-- Get visual juice sequence
	local juiceSequence = self:_getJuiceSequence(sequenceName, config)
	if not juiceSequence then
		self:_logError("Unknown visual juice sequence: " .. sequenceName)
		return ""
	end
	
	-- Execute juice sequence with precise timing
	self:_executeJuiceSequence(juiceSequence, juiceID, targetObject)
	
	-- Track sequence
	self._systemState.ActiveJuiceSequences[juiceID] = juiceSequence
	
	-- Fire event to clients
	self._events.VisualJuiceRequested:FireAllClients(sequenceName, juiceID, juiceSequence)
	
	self:_log("Visual juice started: " .. sequenceName .. " (ID: " .. juiceID .. ")")
	return juiceID
end

-- Quality Management
function PolishEffectsService:SetQualityLevel(level: number, reason: string?)
	level = math.clamp(level, 0, 3)
	
	if level == self._systemState.CurrentQualityLevel then
		return
	end
	
	local oldLevel = self._systemState.CurrentQualityLevel
	self._systemState.CurrentQualityLevel = level
	
	-- Update performance configuration
	self:_updatePerformanceConfigForQuality(level)
	
	-- Optimize existing effects
	self:_optimizeExistingEffectsForQuality(level)
	
	-- Fire event
	self._events.QualityLevelChanged:FireAllClients(level, reason or "Manual")
	
	self:_log("Quality level changed: " .. oldLevel .. " -> " .. level .. " (" .. (reason or "Manual") .. ")")
end

-- Performance Management
function PolishEffectsService:GetPerformanceMetrics()
	return {
		FrameRate = self._systemState.FrameRate,
		EffectCount = self._systemState.EffectCount,
		ParticleCount = self._systemState.ParticleCount,
		ActiveScreenEffects = #self._systemState.ActiveScreenEffects,
		ActiveParticleSystems = #self._systemState.ActiveParticleSystems,
		PerformanceMetrics = self._performanceMetrics,
		QualityLevel = self._systemState.CurrentQualityLevel
	}
end

-- Stop specific effect
function PolishEffectsService:StopEffect(effectID: string)
	-- Check all effect types
	if self._systemState.ActiveScreenEffects[effectID] then
		self:_stopScreenEffect(effectID)
		self._systemState.ActiveScreenEffects[effectID] = nil
	end
	
	if self._systemState.ActiveParticleSystems[effectID] then
		self:_stopParticleSystem(effectID)
		self._systemState.ActiveParticleSystems[effectID] = nil
	end
	
	if self._systemState.ActiveJuiceSequences[effectID] then
		self:_stopJuiceSequence(effectID)
		self._systemState.ActiveJuiceSequences[effectID] = nil
	end
	
	if self._activeAnimations[effectID] then
		self._activeAnimations[effectID]:Cancel()
		self._activeAnimations[effectID] = nil
	end
	
	self._systemState.EffectCount = math.max(0, self._systemState.EffectCount - 1)
end

-- Stop all effects
function PolishEffectsService:StopAllEffects()
	-- Stop all screen effects
	for effectID, _ in pairs(self._systemState.ActiveScreenEffects) do
		self:_stopScreenEffect(effectID)
	end
	self._systemState.ActiveScreenEffects = {}
	
	-- Stop all particle systems
	for systemID, _ in pairs(self._systemState.ActiveParticleSystems) do
		self:_stopParticleSystem(systemID)
	end
	self._systemState.ActiveParticleSystems = {}
	
	-- Stop all juice sequences
	for juiceID, _ in pairs(self._systemState.ActiveJuiceSequences) do
		self:_stopJuiceSequence(juiceID)
	end
	self._systemState.ActiveJuiceSequences = {}
	
	-- Cancel all animations
	for _, tween in pairs(self._activeAnimations) do
		tween:Cancel()
	end
	self._activeAnimations = {}
	
	self._systemState.EffectCount = 0
	self._systemState.ParticleCount = 0
	
	self:_log("All effects stopped")
end

-- Get system state (for debugging)
function PolishEffectsService:GetSystemState(): EffectsSystemState
	return self._systemState
end

-- Private Methods

function PolishEffectsService:_createDefaultPerformanceConfig(): EffectsPerformanceConfig
	return {
		MaxScreenEffects = 5,
		MaxParticleSystems = 8,
		MaxParticlesPerSystem = 100,
		ParticlePoolSizes = {
			Spark = 50,
			Glow = 30,
			Smoke = 20,
			Magic = 40,
			Energy = 35,
			Explosion = 15
		},
		EffectQualityLevel = 2,
		MobileOptimizations = true,
		PerformanceMonitoring = true,
		AutoQualityAdjustment = true,
		FrameRateThreshold = 45
	}
end

function PolishEffectsService:_createResearchData()
	return {
		OptimalImpactDuration = NumberRange.new(0.05, 0.2), -- 50-200ms
		AttentionGrabbingColors = {
			Color3.fromRGB(255, 255, 0), -- Yellow
			Color3.fromRGB(255, 0, 255), -- Magenta
			Color3.fromRGB(0, 255, 255), -- Cyan
			Color3.fromRGB(255, 128, 0) -- Orange
		},
		SatisfactionCurves = {},
		PerformanceLimits = {
			MobileParticleLimit = 75,
			DesktopParticleLimit = 300,
			ScreenEffectLimit = 5,
			FrameRateImpact = 0.02 -- 2% FPS impact per effect
		},
		UserPreferences = {
			PreferredEffectIntensity = NumberRange.new(0.6, 0.8),
			MotionSensitivityThreshold = 0.3,
			FlashingSensitivityLimit = 8 -- Hz
		}
	}
end

function PolishEffectsService:_createImpactTypes()
	return {
		Light = {
			Name = "Light",
			Duration = 0.05, -- 3 frames at 60fps
			Intensity = 0.3,
			FrameHold = 3,
			SlowMotion = 0.9,
			ScreenShake = false,
			ChromaticShift = false,
			SoundPunch = true,
			VisualPunch = true,
			EaseInTime = 0.01,
			EaseOutTime = 0.04
		},
		Medium = {
			Name = "Medium",
			Duration = 0.1, -- 6 frames at 60fps
			Intensity = 0.6,
			FrameHold = 6,
			SlowMotion = 0.7,
			ScreenShake = true,
			ChromaticShift = false,
			SoundPunch = true,
			VisualPunch = true,
			EaseInTime = 0.02,
			EaseOutTime = 0.08
		},
		Heavy = {
			Name = "Heavy",
			Duration = 0.167, -- 10 frames at 60fps
			Intensity = 0.8,
			FrameHold = 10,
			SlowMotion = 0.5,
			ScreenShake = true,
			ChromaticShift = true,
			SoundPunch = true,
			VisualPunch = true,
			EaseInTime = 0.03,
			EaseOutTime = 0.137
		},
		Ultimate = {
			Name = "Ultimate",
			Duration = 0.2, -- 12 frames at 60fps
			Intensity = 1.0,
			FrameHold = 12,
			SlowMotion = 0.3,
			ScreenShake = true,
			ChromaticShift = true,
			SoundPunch = true,
			VisualPunch = true,
			EaseInTime = 0.05,
			EaseOutTime = 0.15
		}
	}
end

function PolishEffectsService:_createJuicePresets()
	-- Visual juice presets for common interactions
	return {
		ButtonHover = {
			Name = "ButtonHover",
			Effects = {},
			ParallelEffects = {
				{
					Name = "Scale",
					Type = "Scale",
					TriggerEvent = "Hover",
					StartValue = Vector3.new(1, 1, 1),
					EndValue = Vector3.new(1.05, 1.05, 1.05),
					Duration = 0.1,
					Delay = 0,
					EasingStyle = Enum.EasingStyle.Quad,
					EasingDirection = Enum.EasingDirection.Out,
					RepeatCount = 0,
					Reverses = false,
					YieldUntilFinished = false
				}
			},
			TotalDuration = 0.1,
			IsLooping = false,
			Priority = 1,
			InterruptBehavior = "Cancel"
		},
		CardReveal = {
			Name = "CardReveal",
			Effects = {
				{
					Name = "Scale",
					Type = "Scale",
					TriggerEvent = "Reveal",
					StartValue = Vector3.new(0.8, 0.8, 0.8),
					EndValue = Vector3.new(1.1, 1.1, 1.1),
					Duration = 0.3,
					Delay = 0,
					EasingStyle = Enum.EasingStyle.Back,
					EasingDirection = Enum.EasingDirection.Out,
					RepeatCount = 0,
					Reverses = false,
					YieldUntilFinished = false
				}
			},
			ParallelEffects = {},
			TotalDuration = 0.5,
			IsLooping = false,
			Priority = 3,
			InterruptBehavior = "Complete"
		}
	}
end

function PolishEffectsService:_generateEffectID(baseName: string): string
	return baseName .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
end

function PolishEffectsService:_setupRemoteEventHandlers()
	-- Handle client effect requests
	self._events.ScreenEffectRequested.OnServerEvent:Connect(function(player: Player, effectName: string, intensity: number, duration: number)
		-- Validate request
		if typeof(effectName) ~= "string" then return end
		
		-- Play screen effect
		local effectID = self:PlayScreenEffect(effectName, intensity, duration)
		
		-- Send confirmation
		self._events.ScreenEffectRequested:FireClient(player, effectName, effectID)
	end)
end

function PolishEffectsService:_startEffectsUpdateLoop()
	self._effectsUpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
		self:_updateEffectsSystem(deltaTime)
	end)
end

function PolishEffectsService:_updateEffectsSystem(deltaTime: number)
	-- Update performance metrics
	self:_updatePerformanceMetrics(deltaTime)
	
	-- Update particle systems
	self:_updateParticleSystems(deltaTime)
	
	-- Update screen effects
	self:_updateScreenEffects(deltaTime)
	
	-- Update impact frames
	self:_updateImpactFrames(deltaTime)
	
	-- Cleanup finished effects
	self:_cleanupFinishedEffects()
	
	-- Performance optimization
	if tick() - self._systemState.LastOptimizationTime > 5.0 then
		self:_performOptimizationPass()
		self._systemState.LastOptimizationTime = tick()
	end
end

-- Placeholder methods for complex functionality
function PolishEffectsService:_initializePerformanceMonitoring() end
function PolishEffectsService:_initializeParticlePools() end
function PolishEffectsService:_initializeScreenEffects() end
function PolishEffectsService:_initializeImpactFrames() end
function PolishEffectsService:_initializeVisualJuice() end
function PolishEffectsService:_applyMobileOptimizations() end
function PolishEffectsService:_startPerformanceMonitoring() end
function PolishEffectsService:_startAutoQualityAdjustment() end
function PolishEffectsService:_createScreenEffect(name: string, intensity: number, duration: number): ScreenEffect? return nil end
function PolishEffectsService:_applyScreenEffect(effect: ScreenEffect, id: string) end
function PolishEffectsService:_createParticleSystem(name: string, position: Vector3, config: any?): ParticleSystem? return nil end
function PolishEffectsService:_spawnParticlesFromPool(system: ParticleSystem, id: string) end
function PolishEffectsService:_getImpactFrame(type: string, intensity: number): ImpactFrame? return nil end
function PolishEffectsService:_executeImpactFrame(frame: ImpactFrame, id: string, position: Vector3?) end
function PolishEffectsService:_getJuiceSequence(name: string, config: any?): JuiceSequence? return nil end
function PolishEffectsService:_executeJuiceSequence(sequence: JuiceSequence, id: string, target: Instance?) end
function PolishEffectsService:_updatePerformanceConfigForQuality(level: number) end
function PolishEffectsService:_optimizeExistingEffectsForQuality(level: number) end
function PolishEffectsService:_optimizeScreenEffects() end
function PolishEffectsService:_optimizeParticleSystems() end
function PolishEffectsService:_stopScreenEffect(id: string) end
function PolishEffectsService:_stopParticleSystem(id: string) end
function PolishEffectsService:_stopJuiceSequence(id: string) end
function PolishEffectsService:_updatePerformanceMetrics(deltaTime: number) end
function PolishEffectsService:_updateParticleSystems(deltaTime: number) end
function PolishEffectsService:_updateScreenEffects(deltaTime: number) end
function PolishEffectsService:_updateImpactFrames(deltaTime: number) end
function PolishEffectsService:_cleanupFinishedEffects() end
function PolishEffectsService:_performOptimizationPass() end

function PolishEffectsService:_logError(message: string)
	warn("[PolishEffectsService] ERROR: " .. message)
end

return PolishEffectsService.new() 
--- FILE: ./src/server/Services/PolishEffectsTestService.luau ---
--!strict
-- PolishEffectsTestService.luau
-- Comprehensive testing for PolishEffectsService functionality
-- Tests screen effects, particle systems, impact frames, and visual juice

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local EffectsTypes = require(ReplicatedStorage.Shared.Types.EffectsTypes)

local PolishEffectsTestService = {}
PolishEffectsTestService.__index = PolishEffectsTestService
setmetatable(PolishEffectsTestService, {__index = BaseService})

function PolishEffectsTestService.new()
	local self = BaseService.new("PolishEffectsTestService", {"PolishEffectsService"})
	setmetatable(self, PolishEffectsTestService)
	
	-- Test configuration
	self._testConfig = {
		EnableExtensiveTests = true,
		EnablePerformanceTests = true,
		EnableScreenEffectTests = true,
		EnableParticleTests = true,
		EnableImpactFrameTests = true,
		EnableVisualJuiceTests = true,
		LogAllResults = true
	}
	
	-- Test results
	self._testResults = {
		ScreenEffects = {},
		ParticleSystems = {},
		ImpactFrames = {},
		VisualJuice = {},
		Performance = {},
		Integration = {}
	}
	
	return self
end

function PolishEffectsTestService:Initialize()
	self:_log("PolishEffectsTestService initializing...")
	
	-- Verify PolishEffectsService dependency
	if not self.ServiceRegistry:GetService("PolishEffectsService") then
		self:_logError("PolishEffectsService dependency not found!")
		return
	end
	
	self:_log("PolishEffectsTestService initialized successfully")
end

function PolishEffectsTestService:Start()
	self:_log("PolishEffectsTestService starting...")
	
	--[[
	-- Run all tests
	self:RunAllPolishEffectsTests()
	--]]
	
	self:_log("PolishEffectsTestService started successfully")
end

-- Public Testing API

function PolishEffectsTestService:RunAllPolishEffectsTests()
	self:_log("=== Running All Polish Effects Tests ===")
	
	local startTime = tick()
	
	-- Screen effects tests
	if self._testConfig.EnableScreenEffectTests then
		self:TestScreenEffects()
	end
	
	-- Particle systems tests
	if self._testConfig.EnableParticleTests then
		self:TestParticleSystems()
	end
	
	-- Impact frames tests
	if self._testConfig.EnableImpactFrameTests then
		self:TestImpactFrames()
	end
	
	-- Visual juice tests
	if self._testConfig.EnableVisualJuiceTests then
		self:TestVisualJuice()
	end
	
	-- Performance tests
	if self._testConfig.EnablePerformanceTests then
		self:TestPerformance()
	end
	
	-- Integration tests
	self:TestIntegration()
	
	local endTime = tick()
	local totalTime = endTime - startTime
	
	self:_log("=== Polish Effects Test Suite Completed ===")
	self:_log("Total execution time: " .. string.format("%.3f", totalTime) .. " seconds")
	
	-- Print summary
	self:PrintTestSummary()
	
	return self._testResults
end

function PolishEffectsTestService:TestScreenEffects()
	self:_log("Testing screen effects...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Chromatic aberration effect
	local test1 = self:_runTest("Chromatic Aberration Effect", function()
		local effectID = polishService:PlayScreenEffect("ChromaticAberration", 0.8, 2.0)
		return typeof(effectID) == "string" and effectID ~= ""
	end)
	table.insert(results, test1)
	
	-- Test 2: Bloom effect
	local test2 = self:_runTest("Bloom Effect", function()
		local effectID = polishService:PlayScreenEffect("Bloom", 0.7, 1.5)
		return typeof(effectID) == "string" and effectID ~= ""
	end)
	table.insert(results, test2)
	
	-- Test 3: Vignette effect
	local test3 = self:_runTest("Vignette Effect", function()
		local effectID = polishService:PlayScreenEffect("Vignette", 0.6, 3.0)
		return typeof(effectID) == "string" and effectID ~= ""
	end)
	table.insert(results, test3)
	
	-- Test 4: Distortion effect
	local test4 = self:_runTest("Distortion Effect", function()
		local effectID = polishService:PlayScreenEffect("Distortion", 0.5, 1.0)
		return typeof(effectID) == "string" and effectID ~= ""
	end)
	table.insert(results, test4)
	
	-- Test 5: Multiple concurrent screen effects
	local test5 = self:_runTest("Multiple Concurrent Screen Effects", function()
		local effectIDs = {}
		table.insert(effectIDs, polishService:PlayScreenEffect("Bloom", 0.3, 1.0))
		table.insert(effectIDs, polishService:PlayScreenEffect("Vignette", 0.4, 1.0))
		table.insert(effectIDs, polishService:PlayScreenEffect("ChromaticAberration", 0.2, 1.0))
		
		return #effectIDs == 3 and effectIDs[1] ~= "" and effectIDs[2] ~= "" and effectIDs[3] ~= ""
	end)
	table.insert(results, test5)
	
	-- Test 6: Screen effect intensity scaling
	local test6 = self:_runTest("Screen Effect Intensity Scaling", function()
		local lowIntensity = polishService:PlayScreenEffect("Bloom", 0.1, 0.5)
		local highIntensity = polishService:PlayScreenEffect("Bloom", 1.0, 0.5)
		
		return lowIntensity ~= "" and highIntensity ~= ""
	end)
	table.insert(results, test6)
	
	self._testResults.ScreenEffects = results
	self:_logTestResults("Screen Effects", results)
end

function PolishEffectsTestService:TestParticleSystems()
	self:_log("Testing particle systems...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Basic particle system spawn
	local test1 = self:_runTest("Basic Particle System Spawn", function()
		local systemID = polishService:SpawnParticleSystem("TestSpark", Vector3.new(0, 10, 0))
		return typeof(systemID) == "string" and systemID ~= ""
	end)
	table.insert(results, test1)
	
	-- Test 2: Multiple particle systems
	local test2 = self:_runTest("Multiple Particle Systems", function()
		local systemIDs = {}
		table.insert(systemIDs, polishService:SpawnParticleSystem("Spark", Vector3.new(0, 10, 0)))
		table.insert(systemIDs, polishService:SpawnParticleSystem("Glow", Vector3.new(5, 10, 0)))
		table.insert(systemIDs, polishService:SpawnParticleSystem("Magic", Vector3.new(-5, 10, 0)))
		
		return #systemIDs == 3
	end)
	table.insert(results, test2)
	
	-- Test 3: Particle system with configuration
	local test3 = self:_runTest("Particle System with Configuration", function()
		local config = {
			Intensity = 0.8,
			Duration = 2.0,
			ParticleCount = 50
		}
		local systemID = polishService:SpawnParticleSystem("ConfiguredSpark", Vector3.new(0, 15, 0), config)
		return typeof(systemID) == "string" and systemID ~= ""
	end)
	table.insert(results, test3)
	
	-- Test 4: Performance limits
	local test4 = self:_runTest("Particle System Performance Limits", function()
		local systemState = polishService:GetSystemState()
		local maxSystems = systemState.PerformanceConfig.MaxParticleSystems
		
		-- Try to spawn more than the limit
		local systemIDs = {}
		for i = 1, maxSystems + 2 do
			local systemID = polishService:SpawnParticleSystem("LimitTest", Vector3.new(i, 10, 0))
			if systemID ~= "" then
				table.insert(systemIDs, systemID)
			end
		end
		
		-- Should not exceed the limit
		return #systemIDs <= maxSystems
	end)
	table.insert(results, test4)
	
	self._testResults.ParticleSystems = results
	self:_logTestResults("Particle Systems", results)
end

function PolishEffectsTestService:TestImpactFrames()
	self:_log("Testing impact frames...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Light impact frame
	local test1 = self:_runTest("Light Impact Frame", function()
		local frameID = polishService:TriggerImpactFrame("Light", 0.3)
		return typeof(frameID) == "string" and frameID ~= ""
	end)
	table.insert(results, test1)
	
	-- Test 2: Medium impact frame
	local test2 = self:_runTest("Medium Impact Frame", function()
		local frameID = polishService:TriggerImpactFrame("Medium", 0.6)
		return typeof(frameID) == "string" and frameID ~= ""
	end)
	table.insert(results, test2)
	
	-- Test 3: Heavy impact frame
	local test3 = self:_runTest("Heavy Impact Frame", function()
		local frameID = polishService:TriggerImpactFrame("Heavy", 0.8)
		return typeof(frameID) == "string" and frameID ~= ""
	end)
	table.insert(results, test3)
	
	-- Test 4: Ultimate impact frame
	local test4 = self:_runTest("Ultimate Impact Frame", function()
		local frameID = polishService:TriggerImpactFrame("Ultimate", 1.0)
		return typeof(frameID) == "string" and frameID ~= ""
	end)
	table.insert(results, test4)
	
	-- Test 5: Impact frame with position
	local test5 = self:_runTest("Impact Frame with Position", function()
		local frameID = polishService:TriggerImpactFrame("Medium", 0.7, Vector3.new(0, 10, 0))
		return typeof(frameID) == "string" and frameID ~= ""
	end)
	table.insert(results, test5)
	
	-- Test 6: Research-based timing validation
	local test6 = self:_runTest("Research-Based Impact Timing", function()
		-- Test that impact durations match research data (50-200ms)
		local systemState = polishService:GetSystemState()
		local researchData = systemState.ResearchData
		local optimalRange = researchData.OptimalImpactDuration
		
		-- Check that our impact types fall within research range
		return optimalRange.Min <= 0.05 and optimalRange.Max >= 0.2
	end)
	table.insert(results, test6)
	
	self._testResults.ImpactFrames = results
	self:_logTestResults("Impact Frames", results)
end

function PolishEffectsTestService:TestVisualJuice()
	self:_log("Testing visual juice effects...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Button hover juice
	local test1 = self:_runTest("Button Hover Visual Juice", function()
		-- Create a test part to represent a UI element
		local testPart = Instance.new("Part")
		testPart.Parent = workspace
		testPart.Name = "TestButtonPart"
		
		local juiceID = polishService:PlayVisualJuice("ButtonHover", testPart)
		
		-- Cleanup
		testPart:Destroy()
		
		return typeof(juiceID) == "string" and juiceID ~= ""
	end)
	table.insert(results, test1)
	
	-- Test 2: Card reveal juice
	local test2 = self:_runTest("Card Reveal Visual Juice", function()
		local testPart = Instance.new("Part")
		testPart.Parent = workspace
		testPart.Name = "TestCardPart"
		
		local juiceID = polishService:PlayVisualJuice("CardReveal", testPart)
		
		-- Cleanup
		testPart:Destroy()
		
		return typeof(juiceID) == "string" and juiceID ~= ""
	end)
	table.insert(results, test2)
	
	-- Test 3: Visual juice with custom configuration
	local test3 = self:_runTest("Visual Juice with Custom Configuration", function()
		local testPart = Instance.new("Part")
		testPart.Parent = workspace
		testPart.Name = "TestCustomPart"
		
		local customConfig = {
			Duration = 1.5,
			Intensity = 0.8,
			EasingStyle = "Bounce"
		}
		
		local juiceID = polishService:PlayVisualJuice("CustomJuice", testPart, customConfig)
		
		-- Cleanup
		testPart:Destroy()
		
		return typeof(juiceID) == "string"
	end)
	table.insert(results, test3)
	
	-- Test 4: Multiple simultaneous juice effects
	local test4 = self:_runTest("Multiple Simultaneous Visual Juice", function()
		local testParts = {}
		local juiceIDs = {}
		
		-- Create multiple test parts
		for i = 1, 3 do
			local part = Instance.new("Part")
			part.Parent = workspace
			part.Name = "TestPart" .. i
			table.insert(testParts, part)
			
			local juiceID = polishService:PlayVisualJuice("ButtonHover", part)
			table.insert(juiceIDs, juiceID)
		end
		
		-- Cleanup
		for _, part in ipairs(testParts) do
			part:Destroy()
		end
		
		return #juiceIDs == 3
	end)
	table.insert(results, test4)
	
	self._testResults.VisualJuice = results
	self:_logTestResults("Visual Juice", results)
end

function PolishEffectsTestService:TestPerformance()
	self:_log("Testing performance...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Performance metrics tracking
	local test1 = self:_runTest("Performance Metrics Tracking", function()
		local metrics = polishService:GetPerformanceMetrics()
		return type(metrics.EffectCount) == "number" and
		       type(metrics.ParticleCount) == "number" and
		       type(metrics.FrameRate) == "number"
	end)
	table.insert(results, test1)
	
	-- Test 2: Quality level adjustment
	local test2 = self:_runTest("Quality Level Adjustment", function()
		local originalLevel = polishService:GetSystemState().CurrentQualityLevel
		
		polishService:SetQualityLevel(1, "Test")
		local newLevel1 = polishService:GetSystemState().CurrentQualityLevel
		
		polishService:SetQualityLevel(3, "Test")
		local newLevel3 = polishService:GetSystemState().CurrentQualityLevel
		
		-- Restore original level
		polishService:SetQualityLevel(originalLevel, "Test")
		
		return newLevel1 == 1 and newLevel3 == 3
	end)
	table.insert(results, test2)
	
	-- Test 3: Effect limit enforcement
	local test3 = self:_runTest("Effect Limit Enforcement", function()
		local systemState = polishService:GetSystemState()
		local maxEffects = systemState.PerformanceConfig.MaxScreenEffects
		
		-- Try to create more effects than the limit
		local effectIDs = {}
		for i = 1, maxEffects + 2 do
			local effectID = polishService:PlayScreenEffect("Bloom", 0.1, 0.5)
			if effectID ~= "" then
				table.insert(effectIDs, effectID)
			end
		end
		
		-- Should not exceed limit due to optimization
		return #effectIDs <= maxEffects + 1 -- Allow slight tolerance for optimization timing
	end)
	table.insert(results, test3)
	
	-- Test 4: Memory management
	local test4 = self:_runTest("Memory Management", function()
		-- Create and stop effects to test cleanup
		local effectIDs = {}
		for i = 1, 5 do
			local effectID = polishService:PlayScreenEffect("Vignette", 0.2, 0.1)
			table.insert(effectIDs, effectID)
		end
		
		-- Stop all effects
		for _, effectID in ipairs(effectIDs) do
			polishService:StopEffect(effectID)
		end
		
		-- Check that effect count decreased
		local systemState = polishService:GetSystemState()
		return systemState.EffectCount >= 0 -- Should not go negative
	end)
	table.insert(results, test4)
	
	self._testResults.Performance = results
	self:_logTestResults("Performance", results)
end

function PolishEffectsTestService:TestIntegration()
	self:_log("Testing integration...")
	
	local polishService = self.ServiceRegistry:GetService("PolishEffectsService")
	local results = {}
	
	-- Test 1: Service registry integration
	local test1 = self:_runTest("Service Registry Integration", function()
		local serviceFromRegistry = self.ServiceRegistry:GetService("PolishEffectsService")
		return serviceFromRegistry ~= nil
	end)
	table.insert(results, test1)
	
	-- Test 2: Audio service integration
	local test2 = self:_runTest("Audio Service Integration", function()
		-- Trigger impact frame which should sync with audio
		local frameID = polishService:TriggerImpactFrame("Medium", 0.7)
		
		-- Check that audio service dependency is working
		local audioService = self:GetService("AudioService")
		return frameID ~= "" and audioService ~= nil
	end)
	table.insert(results, test2)
	
	-- Test 3: GameConstants integration
	local test3 = self:_runTest("GameConstants Integration", function()
		local systemState = polishService:GetSystemState()
		local researchData = systemState.ResearchData
		
		-- Verify research data is properly loaded
		return researchData.OptimalImpactDuration ~= nil and
		       #researchData.AttentionGrabbingColors > 0
	end)
	table.insert(results, test3)
	
	-- Test 4: Complex effect coordination
	local test4 = self:_runTest("Complex Effect Coordination", function()
		-- Test coordinated effects like card reveal
		local effectIDs = {}
		
		-- Simulate a legendary card reveal
		table.insert(effectIDs, polishService:PlayScreenEffect("Bloom", 0.8, 1.0))
		table.insert(effectIDs, polishService:SpawnParticleSystem("Magic", Vector3.new(0, 10, 0)))
		table.insert(effectIDs, polishService:TriggerImpactFrame("Heavy", 0.9))
		
		-- All effects should be created successfully
		return #effectIDs == 3 and effectIDs[1] ~= "" and effectIDs[2] ~= "" and effectIDs[3] ~= ""
	end)
	table.insert(results, test4)
	
	self._testResults.Integration = results
	self:_logTestResults("Integration", results)
end

function PolishEffectsTestService:PrintTestSummary()
	self:_log("=== Polish Effects Test Summary ===")
	
	local totalTests = 0
	local passedTests = 0
	
	for categoryName, categoryResults in pairs(self._testResults) do
		local categoryPassed = 0
		local categoryTotal = #categoryResults
		
		for _, result in ipairs(categoryResults) do
			if result.Passed then
				categoryPassed = categoryPassed + 1
				passedTests = passedTests + 1
			end
			totalTests = totalTests + 1
		end
		
		local passRate = categoryTotal > 0 and (categoryPassed / categoryTotal * 100) or 0
		self:_log(string.format("%s: %d/%d passed (%.1f%%)", 
			categoryName, categoryPassed, categoryTotal, passRate))
	end
	
	local overallPassRate = totalTests > 0 and (passedTests / totalTests * 100) or 0
	self:_log(string.format("Overall: %d/%d tests passed (%.1f%%)", 
		passedTests, totalTests, overallPassRate))
	
	if overallPassRate >= 90 then
		self:_log("🎉 Polish effects system is functioning excellently!")
	elseif overallPassRate >= 75 then
		self:_log("✅ Polish effects system is functioning well with minor issues")
	else
		self:_log("⚠️  Polish effects system has significant issues that need attention")
	end
end

-- Private Testing Utilities

function PolishEffectsTestService:_runTest(testName: string, testFunction: () -> boolean): {Name: string, Passed: boolean, Error: string?}
	local success, result = pcall(testFunction)
	
	local testResult = {
		Name = testName,
		Passed = success and result == true,
		Error = success and result ~= true and "Test returned false" or (not success and tostring(result)) or nil
	}
	
	if self._testConfig.LogAllResults then
		local status = testResult.Passed and "✅ PASS" or "❌ FAIL"
		local errorInfo = testResult.Error and (" - " .. testResult.Error) or ""
		self:_log(string.format("[%s] %s%s", status, testName, errorInfo))
	end
	
	return testResult
end

function PolishEffectsTestService:_logTestResults(categoryName: string, results: any)
	local passed = 0
	local total = #results
	
	for _, result in ipairs(results) do
		if result.Passed then
			passed = passed + 1
		end
	end
	
	local passRate = total > 0 and (passed / total * 100) or 0
	self:_log(string.format("%s tests completed: %d/%d passed (%.1f%%)", 
		categoryName, passed, total, passRate))
end

function PolishEffectsTestService:_logError(message: string)
	warn("[PolishEffectsTestService] ERROR: " .. message)
end

return PolishEffectsTestService.new() 
--- FILE: ./src/server/Services/CardRollTestService.luau ---
--!strict
-- CardRollTestService.luau
-- Comprehensive test service for CardRollService functionality

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local RollTypes = require(ReplicatedStorage.Shared.Types.RollTypes)

local CardRollTestService = {}
CardRollTestService.__index = CardRollTestService
setmetatable(CardRollTestService, {__index = BaseService})

function CardRollTestService.new()
    local self = BaseService.new("CardRollTestService", {"CardRollService", "PlayerDataService"})
    setmetatable(self, CardRollTestService)
    
    return self
end

function CardRollTestService:Initialize()
    self:_log("CardRollTestService initializing...")
end

function CardRollTestService:Start()
    self:_log("CardRollTestService starting...")
    
    --[[
    -- Wait for players to join for testing
    Players.PlayerAdded:Connect(function(player)
        wait(3) -- Wait for other services to initialize
        self:_testCardRollOperations(player)
    end)
    --]]
end

function CardRollTestService:_testCardRollOperations(player: Player)
    self:_log("🎲 Testing CardRollService operations for " .. player.Name)
    
    local cardRollService = self.ServiceRegistry:GetService("CardRollService")
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Test 1: Basic roll functionality
    self:_testBasicRoll(player, cardRollService)
    
    -- Test 2: Pity system
    self:_testPitySystem(player, cardRollService)
    
    -- Test 3: Roll cost calculation
    self:_testRollCosts(cardRollService)
    
    -- Test 4: Roll validation
    self:_testRollValidation(player, cardRollService)
    
    -- Test 5: Roll simulation
    self:_testRollSimulation(player, cardRollService)
    
    -- Test 6: Psychological timing
    self:_testPsychologicalTiming(player, cardRollService)
    
    -- Test 7: Batch rolling
    self:_testBatchRolling(player, cardRollService)
    
    -- Test 8: Statistics tracking
    self:_testStatisticsTracking(player, cardRollService)
    
    self:_log("🎯 CardRollService testing completed for " .. player.Name)
end

function CardRollTestService:_testBasicRoll(player: Player, cardRollService)
    self:_log("Testing basic roll functionality...")
    
    local rollRequest = {
        Player = player,
        RollType = "Daily",
        Count = 1,
        UseGuarantee = false
    }
    
    local result = cardRollService:RollCards(rollRequest)
    
    if result.Success and result.Data then
        self:_log("✅ Basic roll successful")
        self:_log("   - Cards received: " .. result.Data.TotalCards)
        self:_log("   - Processing time: " .. string.format("%.2f", result.ProcessingTime) .. "ms")
        
        if #result.Data.Cards > 0 then
            local firstCard = result.Data.Cards[1]
            self:_log("   - First card: " .. firstCard.Card.Name .. " (" .. firstCard.Rarity .. ")")
            self:_log("   - Animation delay: " .. firstCard.AnimationDelay .. "ms")
            self:_log("   - Effect intensity: " .. string.format("%.2f", firstCard.EffectIntensity))
        end
    else
        self:_logError("❌ Basic roll failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRollTestService:_testPitySystem(player: Player, cardRollService)
    self:_log("Testing pity system...")
    
    local pityStatus = cardRollService:GetPityStatus(player)
    
    if pityStatus then
        self:_log("✅ Pity system status retrieved")
        
        for rarity, calculation in pairs(pityStatus) do
            self:_log("   - " .. rarity .. " pity:")
            self:_log("     • Current pity: " .. calculation.CurrentPity)
            self:_log("     • Current rate: " .. string.format("%.4f", calculation.CurrentRate))
            self:_log("     • Soft pity active: " .. tostring(calculation.SoftPityActive))
            self:_log("     • Hard pity active: " .. tostring(calculation.HardPityActive))
            self:_log("     • Next guarantee in: " .. calculation.NextGuaranteeIn)
        end
    else
        self:_logError("❌ Failed to retrieve pity status")
    end
end

function CardRollTestService:_testRollCosts(cardRollService)
    self:_log("Testing roll cost calculation...")
    
    local testCases = {
        {rollType = "Daily", count = 1},
        {rollType = "Premium", count = 1},
        {rollType = "Premium", count = 5},
        {rollType = "Premium", count = 10}
    }
    
    for _, testCase in ipairs(testCases) do
        local cost = cardRollService:GetRollCost(testCase.rollType, testCase.count)
        
        self:_log("✅ " .. testCase.rollType .. " roll cost (x" .. testCase.count .. "):")
        self:_log("   - Currency: " .. cost.Currency)
        self:_log("   - Amount: " .. cost.Amount)
        self:_log("   - Original: " .. cost.OriginalAmount)
        
        if cost.Discount and cost.Discount > 0 then
            self:_log("   - Discount: " .. string.format("%.1f", cost.Discount * 100) .. "%")
        end
    end
end

function CardRollTestService:_testRollValidation(player: Player, cardRollService)
    self:_log("Testing roll validation...")
    
    -- Test valid request
    local validRequest = {
        Player = player,
        RollType = "Daily",
        Count = 1,
        UseGuarantee = false
    }
    
    local validResult = cardRollService:RollCards(validRequest)
    if validResult.Success then
        self:_log("✅ Valid roll request accepted")
    else
        self:_log("⚠️  Valid roll request rejected: " .. (validResult.ErrorMessage or "Unknown"))
    end
    
    -- Test invalid request (too many cards)
    local invalidRequest = {
        Player = player,
        RollType = "Premium",
        Count = 100,
        UseGuarantee = false
    }
    
    local invalidResult = cardRollService:RollCards(invalidRequest)
    if not invalidResult.Success then
        self:_log("✅ Invalid roll request properly rejected")
        self:_log("   - Reason: " .. (invalidResult.ErrorMessage or "Unknown"))
    else
        self:_log("⚠️  Invalid roll request was accepted (should be rejected)")
    end
end

function CardRollTestService:_testRollSimulation(player: Player, cardRollService)
    self:_log("Testing roll simulation...")
    
    local simulationResults = cardRollService:SimulateRoll(player, 10)
    
    if simulationResults then
        self:_log("✅ Roll simulation successful")
        self:_log("   - Simulated results: " .. table.concat(simulationResults, ", "))
        
        -- Count rarities
        local rarityCounts = {}
        for _, rarity in ipairs(simulationResults) do
            rarityCounts[rarity] = (rarityCounts[rarity] or 0) + 1
        end
        
        self:_log("   - Rarity distribution:")
        for rarity, count in pairs(rarityCounts) do
            self:_log("     • " .. rarity .. ": " .. count)
        end
    else
        self:_logError("❌ Roll simulation failed")
    end
end

function CardRollTestService:_testPsychologicalTiming(player: Player, cardRollService)
    self:_log("Testing psychological timing...")
    
    local rollRequest = {
        Player = player,
        RollType = "Daily",
        Count = 3,
        UseGuarantee = false
    }
    
    local result = cardRollService:RollCards(rollRequest)
    
    if result.Success and result.Data then
        self:_log("✅ Psychological timing test successful")
        self:_log("   - Timing data:")
        self:_log("     • Optimal reveal time: " .. result.Data.TimingData.OptimalRevealTime .. "ms")
        self:_log("     • Psychological delay: " .. result.Data.TimingData.PsychologicalDelay .. "ms")
        
        self:_log("   - Card reveal timings:")
        for i, card in ipairs(result.Data.Cards) do
            self:_log("     • Card " .. i .. ": " .. card.AnimationDelay .. "ms")
        end
        
        -- Verify timing is within expected ranges
        local firstCard = result.Data.Cards[1]
        if firstCard.AnimationDelay >= 2000 and firstCard.AnimationDelay <= 8000 then
            self:_log("     ✅ Timing within psychological range")
        else
            self:_log("     ⚠️  Timing outside expected range")
        end
    else
        self:_logError("❌ Psychological timing test failed")
    end
end

function CardRollTestService:_testBatchRolling(player: Player, cardRollService)
    self:_log("Testing batch rolling...")
    
    local batchRequest = {
        Player = player,
        RollType = "Daily",
        Count = 5,
        UseGuarantee = false
    }
    
    local startTime = os.clock()
    local result = cardRollService:RollCards(batchRequest)
    local endTime = os.clock()
    
    if result.Success and result.Data then
        self:_log("✅ Batch rolling successful")
        self:_log("   - Cards rolled: " .. result.Data.TotalCards)
        self:_log("   - Processing time: " .. string.format("%.2f", (endTime - startTime) * 1000) .. "ms")
        self:_log("   - Pity used: " .. (#result.Data.PityUsed > 0 and "Yes" or "No"))
        
        -- Check rarity distribution
        local rarityCount = {}
        for _, card in ipairs(result.Data.Cards) do
            rarityCount[card.Rarity] = (rarityCount[card.Rarity] or 0) + 1
        end
        
        self:_log("   - Rarity distribution:")
        for rarity, count in pairs(rarityCount) do
            self:_log("     • " .. rarity .. ": " .. count)
        end
    else
        self:_logError("❌ Batch rolling failed: " .. (result.ErrorMessage or "Unknown"))
    end
end

function CardRollTestService:_testStatisticsTracking(player: Player, cardRollService)
    self:_log("Testing statistics tracking...")
    
    local stats = cardRollService:GetRollStatistics(player)
    
    if stats then
        self:_log("✅ Statistics tracking active")
        self:_log("   - Total rolls: " .. stats.TotalRolls)
        self:_log("   - Pity usage rate: " .. string.format("%.2f", stats.PityUsageRate))
        self:_log("   - Engagement score: " .. string.format("%.2f", stats.PlayerEngagementScore))
        
        if stats.RollsByRarity then
            self:_log("   - Rolls by rarity:")
            for rarity, count in pairs(stats.RollsByRarity) do
                self:_log("     • " .. rarity .. ": " .. count)
            end
        end
    else
        self:_log("⚠️  No statistics available (player may not have rolled yet)")
    end
end

function CardRollTestService:TestPitySystemProgression()
    self:_log("Testing pity system progression...")
    
    local testPlayer = Players:GetPlayers()[1]
    if not testPlayer then
        self:_log("⚠️  No player to test pity progression")
        return
    end
    
    local cardRollService = self.ServiceRegistry:GetService("CardRollService")
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Artificially increase pity counters for testing
    local playerData = playerDataService:GetPlayerData(testPlayer)
    if playerData then
        -- Set legendary pity to near guarantee
        playerData.PityData.LegendaryPity = 45
        playerDataService:UpdatePityData(testPlayer, "Legendary", false)
        
        self:_log("📊 Testing with high pity count (45)...")
        
        -- Roll a few times to see pity in action
        for i = 1, 3 do
            local rollRequest = {
                Player = testPlayer,
                RollType = "Daily",
                Count = 1,
                UseGuarantee = false
            }
            
            local result = cardRollService:RollCards(rollRequest)
            if result.Success and result.Data then
                local card = result.Data.Cards[1]
                self:_log("   Roll " .. i .. ": " .. card.Card.Name .. " (" .. card.Rarity .. ")")
                
                if card.IsPityResult then
                    self:_log("   🎯 Pity system activated!")
                    break
                end
            end
        end
    end
end

function CardRollTestService:TestPerformanceMetrics()
    self:_log("Testing performance metrics...")
    
    local cardRollService = self.ServiceRegistry:GetService("CardRollService")
    local testPlayer = Players:GetPlayers()[1]
    
    if not testPlayer then
        self:_log("⚠️  No player to test performance")
        return
    end
    
    local startTime = os.clock()
    local totalRolls = 0
    
    -- Perform multiple rolls to test performance
    for i = 1, 10 do
        local rollRequest = {
            Player = testPlayer,
            RollType = "Daily",
            Count = 1,
            UseGuarantee = false
        }
        
        local result = cardRollService:RollCards(rollRequest)
        if result.Success then
            totalRolls += 1
        end
    end
    
    local endTime = os.clock()
    local duration = endTime - startTime
    
    self:_log("📊 Performance Metrics:")
    self:_log("   - Total rolls: " .. totalRolls)
    self:_log("   - Duration: " .. string.format("%.3f", duration) .. "s")
    self:_log("   - Rolls per second: " .. string.format("%.1f", totalRolls / duration))
    
    -- Test memory usage
    local memoryBefore = collectgarbage("count")
    
    -- Simulate heavy roll load
    for i = 1, 50 do
        local result = cardRollService:SimulateRoll(testPlayer, 5)
    end
    
    local memoryAfter = collectgarbage("count")
    local memoryUsed = memoryAfter - memoryBefore
    
    self:_log("   - Memory usage for 250 simulated rolls: " .. string.format("%.2f", memoryUsed) .. "KB")
end

function CardRollTestService:TestErrorHandling()
    self:_log("Testing error handling...")
    
    local cardRollService = self.ServiceRegistry:GetService("CardRollService")
    
    -- Test with nil player
    local nilPlayerRequest = {
        Player = nil,
        RollType = "Daily",
        Count = 1,
        UseGuarantee = false
    }
    
    local nilResult = cardRollService:RollCards(nilPlayerRequest)
    if not nilResult.Success then
        self:_log("✅ Nil player request properly handled")
    else
        self:_log("⚠️  Nil player request should have failed")
    end
    
    -- Test with invalid roll type
    local testPlayer = Players:GetPlayers()[1]
    if testPlayer then
        local invalidTypeRequest = {
            Player = testPlayer,
            RollType = "InvalidType",
            Count = 1,
            UseGuarantee = false
        }
        
        local invalidResult = cardRollService:RollCards(invalidTypeRequest)
        if not invalidResult.Success then
            self:_log("✅ Invalid roll type properly handled")
        else
            self:_log("⚠️  Invalid roll type should have failed")
        end
    end
end

return CardRollTestService.new() 
--- FILE: ./src/server/Services/AudioTestService.luau ---
--!strict
-- AudioTestService.luau
-- Comprehensive testing for AudioService functionality
-- Tests psychological audio design, frequency layering, and timing precision

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local AudioTypes = require(ReplicatedStorage.Shared.Types.AudioTypes)

type AudioContext = AudioTypes.AudioContext
type PsychologicalAudioConfig = AudioTypes.PsychologicalAudioConfig

local AudioTestService = {}
AudioTestService.__index = AudioTestService
setmetatable(AudioTestService, {__index = BaseService})

function AudioTestService.new()
	local self = BaseService.new("AudioTestService", {"AudioService"})
	setmetatable(self, AudioTestService)
	
	-- Test configuration
	self._testConfig = {
		EnableExtensiveTests = true,
		EnablePerformanceTests = true,
		EnablePsychologicalTests = true,
		EnableFrequencyTests = true,
		EnableSpatialTests = true,
		LogAllResults = true
	}
	
	-- Test results
	self._testResults = {
		BasicFunctionality = {},
		PsychologicalDesign = {},
		FrequencyLayering = {},
		SpatialAudio = {},
		Performance = {},
		Integration = {}
	}
	
	return self
end

function AudioTestService:Initialize()
	self:_log("AudioTestService initializing...")
	
	-- Verify AudioService dependency
	if not self.ServiceRegistry:GetService("AudioService") then
		self:_logError("AudioService dependency not found!")
		return
	end
	
	self:_log("AudioTestService initialized successfully")
end

function AudioTestService:Start()
	self:_log("AudioTestService starting...")
	
	-- Run all tests
	self:RunAllAudioTests()
	
	self:_log("AudioTestService started successfully")
end

-- Public Testing API

function AudioTestService:RunAllAudioTests()
	self:_log("=== Running All Audio Tests ===")
	
	local startTime = tick()
	
	-- Basic functionality tests
	if self._testConfig.EnableExtensiveTests then
		self:TestBasicAudioFunctionality()
	end
	
	-- Psychological design tests
	if self._testConfig.EnablePsychologicalTests then
		self:TestPsychologicalAudioDesign()
	end
	
	-- Frequency layering tests
	if self._testConfig.EnableFrequencyTests then
		self:TestFrequencyLayering()
	end
	
	-- Spatial audio tests
	if self._testConfig.EnableSpatialTests then
		self:TestSpatialAudio()
	end
	
	-- Performance tests
	if self._testConfig.EnablePerformanceTests then
		self:TestAudioPerformance()
	end
	
	-- Integration tests
	self:TestAudioIntegration()
	
	local endTime = tick()
	local totalTime = endTime - startTime
	
	self:_log("=== Audio Test Suite Completed ===")
	self:_log("Total execution time: " .. string.format("%.3f", totalTime) .. " seconds")
	
	-- Print summary
	self:PrintTestSummary()
	
	return self._testResults
end

function AudioTestService:TestBasicAudioFunctionality()
	self:_log("Testing basic audio functionality...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: AudioService initialization
	local test1 = self:_runTest("AudioService Initialization", function()
		local systemState = audioService:GetSystemState()
		return systemState.IsInitialized == true
	end)
	table.insert(results, test1)
	
	-- Test 2: Play audio cue
	local test2 = self:_runTest("Play Audio Cue", function()
		local instanceID = audioService:PlayAudioCue("test_cue")
		return typeof(instanceID) == "string" and instanceID ~= ""
	end)
	table.insert(results, test2)
	
	-- Test 3: Audio context update
	local test3 = self:_runTest("Audio Context Update", function()
		local context: AudioContext = {
			CurrentScene = "Battle",
			PlayerState = "Fighting",
			TensionLevel = 0.8,
			ExcitementLevel = 0.9,
			RecentActions = {"AttackCard", "DefendCard"},
			SessionLength = 300,
			LastMajorEvent = "CriticalHit",
			NextExpectedEvent = "Victory"
		}
		
		audioService:UpdateAudioContext(context)
		local systemState = audioService:GetSystemState()
		
		return systemState.CurrentContext.CurrentScene == "Battle" and
		       systemState.CurrentContext.TensionLevel == 0.8
	end)
	table.insert(results, test3)
	
	-- Test 4: Frequency layer emphasis
	local test4 = self:_runTest("Frequency Layer Emphasis", function()
		audioService:SetFrequencyLayerEmphasis("SubBass", 1.5)
		local systemState = audioService:GetSystemState()
		return systemState.FrequencyConfig.SubBass.IntensityMultiplier == 1.5
	end)
	table.insert(results, test4)
	
	-- Test 5: Stop audio
	local test5 = self:_runTest("Stop Audio", function()
		local instanceID = audioService:PlayAudioCue("test_cue_2")
		audioService:StopAudio(instanceID)
		-- Basic test - just verify no errors occurred
		return true
	end)
	table.insert(results, test5)
	
	self._testResults.BasicFunctionality = results
	self:_logTestResults("Basic Audio Functionality", results)
end

function AudioTestService:TestPsychologicalAudioDesign()
	self:_log("Testing psychological audio design...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: Psychological event trigger
	local test1 = self:_runTest("Psychological Event Trigger", function()
		audioService:TriggerPsychologicalEvent("DopamineSpike", 0.8, 2.0)
		-- Test that event was triggered without errors
		return true
	end)
	table.insert(results, test1)
	
	-- Test 2: Rarity-based psychological profiles
	local test2 = self:_runTest("Rarity-Based Psychological Profiles", function()
		local commonConfig: PsychologicalAudioConfig = {
			RarityLevel = "Common",
			DopamineProfile = {
				BuildupCurve = "linear",
				PeakIntensity = 0.3,
				SustainDuration = 0.5,
				ReleaseCurve = "exponential",
				NextEventPrep = 0.2
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.1,
				ImpactTiming = 0.05,
				ResolutionFade = 0.3,
				NextCuePrep = 0.1
			},
			FrequencyEmphasis = {Midrange = 1.0},
			SpatialEffects = false,
			CompressionLevel = 0.7
		}
		
		local instanceID = audioService:PlayAudioCue("common_card", commonConfig)
		return typeof(instanceID) == "string" and instanceID ~= ""
	end)
	table.insert(results, test2)
	
	-- Test 3: Legendary psychological profile
	local test3 = self:_runTest("Legendary Psychological Profile", function()
		local legendaryConfig: PsychologicalAudioConfig = {
			RarityLevel = "Legendary",
			DopamineProfile = {
				BuildupCurve = "exponential",
				PeakIntensity = 0.9,
				SustainDuration = 2.0,
				ReleaseCurve = "logarithmic",
				NextEventPrep = 1.0
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.5,
				ImpactTiming = 0.2,
				ResolutionFade = 1.5,
				NextCuePrep = 0.5
			},
			FrequencyEmphasis = {SubBass = 1.2, Brilliance = 1.4},
			SpatialEffects = true,
			CompressionLevel = 0.3
		}
		
		local instanceID = audioService:PlayAudioCue("legendary_card", legendaryConfig)
		return typeof(instanceID) == "string" and instanceID ~= ""
	end)
	table.insert(results, test3)
	
	-- Test 4: Context-based audio adaptation
	local test4 = self:_runTest("Context-Based Audio Adaptation", function()
		-- Test different contexts
		local contexts = {
			{CurrentScene = "Menu", TensionLevel = 0.2, ExcitementLevel = 0.3},
			{CurrentScene = "CardRoll", TensionLevel = 0.6, ExcitementLevel = 0.8},
			{CurrentScene = "Battle", TensionLevel = 0.9, ExcitementLevel = 0.7}
		}
		
		for _, contextData in ipairs(contexts) do
			local context: AudioContext = {
				CurrentScene = contextData.CurrentScene,
				PlayerState = "Active",
				TensionLevel = contextData.TensionLevel,
				ExcitementLevel = contextData.ExcitementLevel,
				RecentActions = {},
				SessionLength = 60,
				LastMajorEvent = "SceneChange",
				NextExpectedEvent = "PlayerAction"
			}
			
			audioService:UpdateAudioContext(context)
		end
		
		return true
	end)
	table.insert(results, test4)
	
	self._testResults.PsychologicalDesign = results
	self:_logTestResults("Psychological Audio Design", results)
end

function AudioTestService:TestFrequencyLayering()
	self:_log("Testing frequency layering system...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: Individual frequency layer control
	local test1 = self:_runTest("Individual Frequency Layer Control", function()
		local systemState = audioService:GetSystemState()
		local originalEmphasis = systemState.FrequencyConfig.SubBass.IntensityMultiplier
		
		audioService:SetFrequencyLayerEmphasis("SubBass", 1.5)
		audioService:SetFrequencyLayerEmphasis("Presence", 0.8)
		audioService:SetFrequencyLayerEmphasis("Brilliance", 1.2)
		
		local newState = audioService:GetSystemState()
		return newState.FrequencyConfig.SubBass.IntensityMultiplier == 1.5 and
		       newState.FrequencyConfig.Presence.IntensityMultiplier == 0.8 and
		       newState.FrequencyConfig.Brilliance.IntensityMultiplier == 1.2
	end)
	table.insert(results, test1)
	
	-- Test 2: Frequency layer combinations
	local test2 = self:_runTest("Frequency Layer Combinations", function()
		-- Test different frequency combinations for psychological effect
		local combinations = {
			{SubBass = 1.3, MidBass = 1.1, Purpose = "Impact"},
			{Presence = 1.4, Brilliance = 1.5, Purpose = "Sparkle"},
			{Midrange = 1.2, UpperMid = 1.3, Purpose = "Clarity"}
		}
		
		for _, combo in ipairs(combinations) do
			for layerName, emphasis in pairs(combo) do
				if layerName ~= "Purpose" then
					audioService:SetFrequencyLayerEmphasis(layerName, emphasis)
				end
			end
		end
		
		return true
	end)
	table.insert(results, test2)
	
	-- Test 3: Research-based frequency ranges
	local test3 = self:_runTest("Research-Based Frequency Ranges", function()
		local systemState = audioService:GetSystemState()
		local config = systemState.FrequencyConfig
		
		-- Verify frequency ranges match research
		local subBassRange = config.SubBass.FrequencyRange
		local brillianceRange = config.Brilliance.FrequencyRange
		
		return subBassRange.Low == 20 and subBassRange.High == 60 and
		       brillianceRange.Low == 8000 and brillianceRange.High == 16000
	end)
	table.insert(results, test3)
	
	-- Test 4: Mobile optimization
	local test4 = self:_runTest("Mobile Optimization", function()
		local systemState = audioService:GetSystemState()
		return systemState.FrequencyConfig.MobileOptimization == true
	end)
	table.insert(results, test4)
	
	self._testResults.FrequencyLayering = results
	self:_logTestResults("Frequency Layering", results)
end

function AudioTestService:TestSpatialAudio()
	self:_log("Testing spatial audio system...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: Spatial configuration
	local test1 = self:_runTest("Spatial Configuration", function()
		local systemState = audioService:GetSystemState()
		local spatialConfig = systemState.SpatialConfig
		
		return spatialConfig.IsEnabled == true and
		       spatialConfig.MaxAudibleDistance > 0
	end)
	table.insert(results, test1)
	
	-- Test 2: Spatial audio with psychological config
	local test2 = self:_runTest("Spatial Audio with Psychological Config", function()
		local spatialConfig: PsychologicalAudioConfig = {
			RarityLevel = "Epic",
			DopamineProfile = {
				BuildupCurve = "exponential",
				PeakIntensity = 0.7,
				SustainDuration = 1.5,
				ReleaseCurve = "linear",
				NextEventPrep = 0.5
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.3,
				ImpactTiming = 0.15,
				ResolutionFade = 1.0,
				NextCuePrep = 0.3
			},
			FrequencyEmphasis = {SubBass = 1.1, Presence = 1.2},
			SpatialEffects = true,
			CompressionLevel = 0.5
		}
		
		local instanceID = audioService:PlayAudioCue("spatial_test", spatialConfig)
		return typeof(instanceID) == "string" and instanceID ~= ""
	end)
	table.insert(results, test2)
	
	self._testResults.SpatialAudio = results
	self:_logTestResults("Spatial Audio", results)
end

function AudioTestService:TestAudioPerformance()
	self:_log("Testing audio performance...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: Performance metrics tracking
	local test1 = self:_runTest("Performance Metrics Tracking", function()
		local metrics = audioService:GetPerformanceMetrics()
		return type(metrics.ConcurrentSounds) == "number" and
		       type(metrics.ConcurrentLayers) == "number" and
		       type(metrics.CPUUsage) == "number"
	end)
	table.insert(results, test1)
	
	-- Test 2: Concurrent audio handling
	local test2 = self:_runTest("Concurrent Audio Handling", function()
		local instanceIDs = {}
		
		-- Play multiple audio cues simultaneously
		for i = 1, 5 do
			local instanceID = audioService:PlayAudioCue("concurrent_test_" .. i)
			table.insert(instanceIDs, instanceID)
		end
		
		-- Verify they were all created
		return #instanceIDs == 5
	end)
	table.insert(results, test2)
	
	-- Test 3: Audio system limits
	local test3 = self:_runTest("Audio System Limits", function()
		local systemState = audioService:GetSystemState()
		local performanceConfig = systemState.PerformanceConfig
		
		return performanceConfig.MaxConcurrentSounds > 0 and
		       performanceConfig.MaxConcurrentLayers > 0 and
		       performanceConfig.CPUUsageLimit > 0
	end)
	table.insert(results, test3)
	
	-- Test 4: Timing precision
	local test4 = self:_runTest("Timing Precision", function()
		-- Test that audio sync window meets requirement (2ms)
		local expectedSyncWindow = GameConstants.Audio.AudioSyncWindow
		return expectedSyncWindow <= 0.002
	end)
	table.insert(results, test4)
	
	self._testResults.Performance = results
	self:_logTestResults("Audio Performance", results)
end

function AudioTestService:TestAudioIntegration()
	self:_log("Testing audio integration...")
	
	local audioService = self.ServiceRegistry:GetService("AudioService")
	local results = {}
	
	-- Test 1: GameConstants integration
	local test1 = self:_runTest("GameConstants Integration", function()
		local systemState = audioService:GetSystemState()
		return systemState.MasterVolume == GameConstants.Audio.MasterVolume and
		       systemState.SFXVolume == GameConstants.Audio.SFXVolume
	end)
	table.insert(results, test1)
	
	-- Test 2: Service registry integration
	local test2 = self:_runTest("Service Registry Integration", function()
		-- Verify AudioService is properly registered
		local audioServiceFromRegistry = self.ServiceRegistry:GetService("AudioService")
		return audioServiceFromRegistry ~= nil
	end)
	table.insert(results, test2)
	
	-- Test 3: Audio sequence handling
	local test3 = self:_runTest("Audio Sequence Handling", function()
		local sequenceID = audioService:PlayAudioSequence("test_sequence")
		-- Basic test - verify no errors and returns string
		return typeof(sequenceID) == "string"
	end)
	table.insert(results, test3)
	
	self._testResults.Integration = results
	self:_logTestResults("Audio Integration", results)
end

function AudioTestService:PrintTestSummary()
	self:_log("=== Audio Test Summary ===")
	
	local totalTests = 0
	local passedTests = 0
	
	for categoryName, categoryResults in pairs(self._testResults) do
		local categoryPassed = 0
		local categoryTotal = #categoryResults
		
		for _, result in ipairs(categoryResults) do
			if result.Passed then
				categoryPassed = categoryPassed + 1
				passedTests = passedTests + 1
			end
			totalTests = totalTests + 1
		end
		
		local passRate = categoryTotal > 0 and (categoryPassed / categoryTotal * 100) or 0
		self:_log(string.format("%s: %d/%d passed (%.1f%%)", 
			categoryName, categoryPassed, categoryTotal, passRate))
	end
	
	local overallPassRate = totalTests > 0 and (passedTests / totalTests * 100) or 0
	self:_log(string.format("Overall: %d/%d tests passed (%.1f%%)", 
		passedTests, totalTests, overallPassRate))
	
	if overallPassRate >= 90 then
		self:_log("🎉 Audio system is functioning excellently!")
	elseif overallPassRate >= 75 then
		self:_log("✅ Audio system is functioning well with minor issues")
	else
		self:_log("⚠️  Audio system has significant issues that need attention")
	end
end

-- Private Testing Utilities

function AudioTestService:_runTest(testName: string, testFunction: () -> boolean): {Name: string, Passed: boolean, Error: string?}
	local success, result = pcall(testFunction)
	
	local testResult = {
		Name = testName,
		Passed = success and result == true,
		Error = success and result ~= true and "Test returned false" or (not success and tostring(result)) or nil
	}
	
	if self._testConfig.LogAllResults then
		local status = testResult.Passed and "✅ PASS" or "❌ FAIL"
		local errorInfo = testResult.Error and (" - " .. testResult.Error) or ""
		self:_log(string.format("[%s] %s%s", status, testName, errorInfo))
	end
	
	return testResult
end

function AudioTestService:_logTestResults(categoryName: string, results: any)
	local passed = 0
	local total = #results
	
	for _, result in ipairs(results) do
		if result.Passed then
			passed = passed + 1
		end
	end
	
	local passRate = total > 0 and (passed / total * 100) or 0
	self:_log(string.format("%s tests completed: %d/%d passed (%.1f%%)", 
		categoryName, passed, total, passRate))
end

function AudioTestService:_logError(message: string)
	warn("[AudioTestService] ERROR: " .. message)
end

return AudioTestService.new() 
--- FILE: ./src/server/Services/CardRollService.luau ---
--!strict
-- CardRollService.luau
-- Advanced card roll system with psychological timing and smart pity mechanics

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local RollTypes = require(ReplicatedStorage.Shared.Types.RollTypes)
local CardTypes = require(ReplicatedStorage.Shared.Types.CardTypes)
local PlayerTypes = require(ReplicatedStorage.Shared.Types.PlayerTypes)
local TableUtils = require(ReplicatedStorage.Shared.Utils.TableUtils)
local CardDatabase = require(ReplicatedStorage.Shared.Data.CardDatabase)

type RollRequest = RollTypes.RollRequest
type RollResult = RollTypes.RollResult
type CardRollResult = RollTypes.CardRollResult
type PityConfig = RollTypes.PityConfig
type PityCalculation = RollTypes.PityCalculation
type RollServiceResponse<T> = RollTypes.RollServiceResponse<T>

local CardRollService = {}
CardRollService.__index = CardRollService
setmetatable(CardRollService, {__index = BaseService})

-- Pity System Configuration (Research-based)
local PITY_CONFIGS = {
    Common = {
        SoftPityStart = 0,
        HardPityLimit = 0,
        SoftPityIncrease = 0,
        BaseRate = 0.7,
        MaxRate = 0.7,
        RarityName = "Common"
    },
    Rare = {
        SoftPityStart = 0,
        HardPityLimit = 0,
        SoftPityIncrease = 0,
        BaseRate = 0.25,
        MaxRate = 0.25,
        RarityName = "Rare"
    },
    Epic = {
        SoftPityStart = 8,
        HardPityLimit = 15,
        SoftPityIncrease = 0.08,
        BaseRate = 0.04,
        MaxRate = 0.6,
        RarityName = "Epic"
    },
    Legendary = {
        SoftPityStart = 25,
        HardPityLimit = 50,
        SoftPityIncrease = 0.06,
        BaseRate = 0.006,
        MaxRate = 0.32,
        RarityName = "Legendary"
    },
    Mythical = {
        SoftPityStart = 60,
        HardPityLimit = 90,
        SoftPityIncrease = 0.04,
        BaseRate = 0.001,
        MaxRate = 0.5,
        RarityName = "Mythical"
    },
    Ultimate = {
        SoftPityStart = 80,
        HardPityLimit = 120,
        SoftPityIncrease = 0.03,
        BaseRate = 0.0001,
        MaxRate = 1.0,
        RarityName = "Ultimate"
    }
}

-- Psychological Timing Configuration
local TIMING_CONFIG = {
    OptimalRevealBase = 2000, -- 2 seconds optimal reveal time
    PsychologicalDelayMin = 500,
    PsychologicalDelayMax = 1500,
    RarityDelayMultiplier = {
        Common = 1.0,
        Rare = 1.2,
        Epic = 1.5,
        Legendary = 2.0,
        Mythical = 2.5,
        Ultimate = 3.0
    },
    AnticipationBuildupTime = 1000,
    SatisfactionHoldTime = 800
}

function CardRollService.new()
    	local self = BaseService.new("CardRollService", {"PlayerDataService"})
    setmetatable(self, CardRollService)
    
    -- Roll tracking
    self._activeRolls = {} :: {[string]: RollRequest}
    self._rollQueue = {} :: {RollTypes.RollQueueItem}
    self._rollStatistics = {} :: {[number]: RollTypes.RollStatistics}
    self._lastRollTimes = {} :: {[number]: number}
    
    -- Performance tracking
    self._rollsProcessed = 0
    self._averageProcessTime = 0
    self._concurrentRolls = 0
    
    -- Random seed for consistent but fair results
    self._randomSeed = os.time()
    
    return self
end

function CardRollService:Initialize()
    self:_log("CardRollService initializing...")
    
    -- Validate pity configurations
    for rarity, config in pairs(PITY_CONFIGS) do
        if config.SoftPityStart >= config.HardPityLimit and config.HardPityLimit > 0 then
            self:_logError("Invalid pity config for " .. rarity)
        end
    end
    
    -- Initialize roll processing
    self._rollProcessingConnection = RunService.Heartbeat:Connect(function()
        self:_processRollQueue()
    end)
    
    self:_log("CardRollService initialized successfully")
end

function CardRollService:Start()
    self:_log("CardRollService starting...")
    
    -- Set up remote events for client communication
    self:_setupRemoteEvents()
    
    -- Start roll analytics
    self:_startAnalytics()
    
    self:_log("CardRollService started successfully")
end

function CardRollService:Stop()
    self:_log("CardRollService stopping...")
    
    -- Process remaining rolls
    while #self._rollQueue > 0 do
        self:_processRollQueue()
        wait(0.1)
    end
    
    -- Clean up connections
    if self._rollProcessingConnection then
        self._rollProcessingConnection:Disconnect()
    end
    
    self:_log("CardRollService stopped")
end

-- Public Methods

function CardRollService:RollCards(request: RollRequest): RollServiceResponse<RollResult>
    local startTime = os.clock()
    local requestID = HttpService:GenerateGUID(false)
    
    -- Validate request
    local validation = self:_validateRollRequest(request)
    if not validation.IsValid then
        return {
            Success = false,
            ErrorMessage = validation.ErrorReason,
            ProcessingTime = (os.clock() - startTime) * 1000,
            RequestID = requestID
        }
    end
    
    -- Process the roll
    local rollResult = self:_processRoll(request, requestID)
    
    if rollResult.Success then
        -- Update player data
        self:_updatePlayerDataAfterRoll(request.Player, rollResult)
        
        -- Track statistics
        self:_updateRollStatistics(request.Player, rollResult)
    end
    
    return {
        Success = rollResult.Success,
        Data = rollResult,
        ErrorMessage = rollResult.ErrorMessage,
        ProcessingTime = (os.clock() - startTime) * 1000,
        RequestID = requestID
    }
end

function CardRollService:GetPityStatus(player: Player): RollTypes.PitySystemState
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local playerData = playerDataService:GetPlayerData(player)
    
    if not playerData then
        return {}
    end
    
    local pityState = {}
    
    for rarity, config in pairs(PITY_CONFIGS) do
        local pityField = rarity .. "Pity"
        local currentPity = playerData.PityData[pityField] or 0
        
        local calculation = self:_calculatePityRates(rarity, currentPity)
        pityState[rarity] = calculation
    end
    
    return pityState
end

function CardRollService:GetRollCost(rollType: RollTypes.RollType, count: number): RollTypes.RollCost
    local baseCost = 0
    local currency = "Coins"
    
    if rollType == "Daily" then
        baseCost = 0
        currency = "DailyRolls"
    elseif rollType == "Premium" then
        baseCost = GameConstants.Economy.PremiumRollCost
        currency = "Gems"
    elseif rollType == "Bonus" then
        baseCost = GameConstants.Economy.BonusRollCost
        currency = "Coins"
    end
    
    local totalCost = baseCost * count
    local discount = self:_calculateBulkDiscount(count)
    local finalCost = math.floor(totalCost * (1 - discount))
    
    return {
        Currency = currency,
        Amount = finalCost,
        OriginalAmount = totalCost,
        Discount = discount
    }
end

function CardRollService:SimulateRoll(player: Player, count: number): {string}
    -- Simulate rolls without actually giving cards (for UI preview)
    local results = {}
    
    for i = 1, count do
        local rarity = self:_rollRarity(player, true) -- simulate = true
        table.insert(results, rarity)
    end
    
    return results
end

function CardRollService:GetRollStatistics(player: Player): RollTypes.RollStatistics?
    local userID = player.UserId
    return self._rollStatistics[userID]
end

-- Private Methods

function CardRollService:_setupRemoteEvents()
    local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)
    
    -- Handle card roll requests from client
    RemoteEventHandler:ConnectRemoteEvent("RequestCardRoll", function(player: Player, rollType: string?)
        self:_handleClientCardRoll(player, rollType or "Standard")
    end)
    
    -- Pre-create remote events for sending results back to client
    RemoteEventHandler:GetRemoteEvent("CardRollResult")
    RemoteEventHandler:GetRemoteEvent("CardRollError")
    
    self:_log("Remote events set up for card rolling")
end

function CardRollService:_handleClientCardRoll(player: Player, rollType: string)
    -- Create roll request
    local request: RollRequest = {
        Player = player,
        RollType = rollType,
        Count = 1, -- Single card roll for now
        Timestamp = os.time(),
        SessionID = tostring(player.UserId) .. "_" .. os.time()
    }
    
    -- Process the roll
    local result = self:RollCards(request)
    
    if result.Success and result.Data then
        -- Send result back to client
        local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)
        RemoteEventHandler:FireClient(player, "CardRollResult", result.Data)
        
        self:_log("Card roll completed for player " .. player.Name .. ": " .. (result.Data.Cards[1] and result.Data.Cards[1].Card.Name or "Unknown"))
    else
        -- Send error back to client
        local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)
        RemoteEventHandler:FireClient(player, "CardRollError", result.ErrorMessage or "Unknown error")
        
        self:_logError("Card roll failed for player " .. player.Name .. ": " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRollService:_validateRollRequest(request: RollRequest): RollTypes.RollValidation
	local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
	if not playerDataService then
		return {IsValid = false, ErrorReason = "PlayerDataService not found"}
	end

	local playerData = playerDataService:GetPlayerData(request.Player)
	if not playerData then
		return {IsValid = false, ErrorReason = "Player data not found"}
	end

	-- Get roll cost from constants
	local rollCost = GameConstants.Economy.RollCosts[request.RollType] or GameConstants.Economy.RollCosts.Standard
	if not rollCost then
		return {IsValid = false, ErrorReason = "Invalid roll type"}
	end
	
	-- Check if player has enough currency (using Gems now)
	if playerData.Gems < rollCost then
		return {IsValid = false, ErrorReason = "Not enough Gems"}
	end

	-- Rate limiting check
	if self:_isRateLimited(request.Player) then
		return {IsValid = false, ErrorReason = "Rate limit exceeded"}
	end
    
    return {
        IsValid = true,
        CanAfford = true,
        HasRollsRemaining = true,
        CooldownRemaining = 0
    }
end

function CardRollService:_isRateLimited(player: Player): boolean
	local playerID = player.UserId
	local currentTime = os.time()
	
	local lastRollTime = self._lastRollTimes[playerID]
	if lastRollTime and (currentTime - lastRollTime) < 1 then -- 1-second cooldown
		return true
	end
	
	self._lastRollTimes[playerID] = currentTime
	return false
end

function CardRollService:_processRoll(request: RollRequest, requestID: string): RollResult
    local startTime = os.clock()
    self._concurrentRolls += 1
    
    local results = {}
    local pityUsed = {}
    local totalCost = self:GetRollCost(request.RollType, request.Count)
    
    -- Generate cards
    for i = 1, request.Count do
        local cardResult = self:_generateCardRoll(request.Player, i, request.RollType)
        table.insert(results, cardResult)
        
        if cardResult.IsPityResult then
            table.insert(pityUsed, cardResult.Rarity)
        end
    end
    
    -- Calculate timing data
    local timingData = self:_calculateRollTiming(results)
    
    self._concurrentRolls -= 1
    self._rollsProcessed += 1
    
    return {
        Success = true,
        Cards = results,
        TotalCards = #results,
        PityUsed = pityUsed,
        GuaranteeUsed = #pityUsed > 0,
        RollCost = totalCost,
        TimingData = timingData
    }
end

function CardRollService:_generateCardRoll(player: Player, position: number, rollType: RollTypes.RollType): CardRollResult
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    	local cardDatabase = CardDatabase
    
    -- Roll for rarity
    local rarity, isPityResult = self:_rollRarity(player, false)
    
    -- Get random card of this rarity
    local card = cardDatabase:GetRandomCard(rarity)
    if not card then
    	self:_logError("No card found for rarity: " .. rarity .. ". Falling back to Common.")
    	card = cardDatabase:GetRandomCard("Common")
    end
    
    -- Check if player already has this card
    local playerData = playerDataService:GetPlayerData(player)
    local isNew = not playerData or not playerData.Cards or not playerData.Cards[card.ID]
    
    -- Get current pity count
    local pityCount = (playerData and playerData.Pity and playerData.Pity[rarity]) or 0
    
    -- Calculate animation delay (psychological timing)
    local baseDelay = TIMING_CONFIG.OptimalRevealBase
    local rarityMultiplier = TIMING_CONFIG.RarityDelayMultiplier[rarity] or 1.0
    local positionDelay = (position - 1) * 200 -- Stagger reveals
    local psychDelay = math.random(TIMING_CONFIG.PsychologicalDelayMin, TIMING_CONFIG.PsychologicalDelayMax)
    
    local animationDelay = baseDelay * rarityMultiplier + positionDelay + psychDelay
    
    -- Calculate effect intensity
    local effectIntensity = self:_calculateEffectIntensity(rarity, isNew, isPityResult)
    
    return {
        Card = card,
        Rarity = rarity,
        IsNew = isNew,
        IsPityResult = isPityResult,
        PityCount = pityCount,
        RollPosition = position,
        AnimationDelay = animationDelay,
        EffectIntensity = effectIntensity
    }
end

function CardRollService:_rollRarity(player: Player, simulate: boolean): (string, boolean)
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local playerData = playerDataService:GetPlayerData(player)
    
    if not playerData then
        return "Common", false
    end
    
    -- Check for guaranteed rarities first (hard pity)
    for rarity, config in pairs(PITY_CONFIGS) do
        if config.HardPityLimit > 0 then
            local currentPity = (playerData and playerData.Pity and playerData.Pity[rarity]) or 0
            
            if currentPity >= config.HardPityLimit then
                if not simulate then
                    playerDataService:UpdatePityData(player, rarity, true)
                end
                return rarity, true
            end
        end
    end
    
    -- Generate random number
    local random = math.random()
    local cumulativeRate = 0
    
    -- Check rarities in order of rarity (Ultimate -> Common)
    local rarityOrder = {"Ultimate", "Legendary", "Epic", "Rare", "Common"}
    
    for _, rarity in ipairs(rarityOrder) do
        local currentPity = (playerData and playerData.Pity and playerData.Pity[rarity]) or 0
        local pityCalc = self:_calculatePityRates(rarity, currentPity)
        cumulativeRate += pityCalc.CurrentRate
        
        if random <= cumulativeRate then
            if not simulate then
                playerDataService:UpdatePityData(player, rarity, true)
            end
            -- Check if this was a pity result
   			local config = PITY_CONFIGS[rarity]
    		local wasPity = currentPity >= config.SoftPityStart
            return rarity, wasPity
        end
    end
    
    -- Fallback to Common
    if not simulate then
    	playerDataService:UpdatePityData(player, "Common", false)
    end
    return "Common", false
end

function CardRollService:_calculatePityRates(rarity: string, currentPity: number): PityCalculation
    local config = PITY_CONFIGS[rarity]
    if not config then
        return {
            CurrentPity = currentPity,
            SoftPityActive = false,
            HardPityActive = false,
            CurrentRate = 0,
            BaseRate = 0,
            NextGuaranteeIn = 999
        }
    end
    
    local currentRate = config.BaseRate
    local softPityActive = currentPity >= config.SoftPityStart
    local hardPityActive = config.HardPityLimit > 0 and currentPity >= config.HardPityLimit
    
    -- Apply soft pity
    if softPityActive and not hardPityActive then
        local softPityStacks = currentPity - config.SoftPityStart
        local rateIncrease = softPityStacks * config.SoftPityIncrease
        currentRate = math.min(config.MaxRate, config.BaseRate + rateIncrease)
    end
    
    -- Hard pity guarantees the item
    if hardPityActive then
        currentRate = 1.0
    end
    
    local nextGuaranteeIn = config.HardPityLimit > 0 and (config.HardPityLimit - currentPity) or 999
    
    return {
        CurrentPity = currentPity,
        SoftPityActive = softPityActive,
        HardPityActive = hardPityActive,
        CurrentRate = currentRate,
        BaseRate = config.BaseRate,
        NextGuaranteeIn = nextGuaranteeIn
    }
end

function CardRollService:_wasPityUsed(rarity: string, pityCount: number): boolean
    local config = PITY_CONFIGS[rarity]
    if not config then
        return false
    end
    
    -- If hard pity was reached, it was definitely used
    if config.HardPityLimit > 0 and pityCount >= config.HardPityLimit then
        return true
    end
    
    -- If soft pity was active, there's a chance it was used
    if pityCount >= config.SoftPityStart then
        return true
    end
    
    return false
end

function CardRollService:_calculateRollTiming(results: {CardRollResult}): RollTypes.RollTimingData
    local currentTime = os.time()
    local totalDelay = 0
    
    for _, result in ipairs(results) do
        totalDelay += result.AnimationDelay
    end
    
    local averageDelay = totalDelay / #results
    local psychDelay = math.random(TIMING_CONFIG.PsychologicalDelayMin, TIMING_CONFIG.PsychologicalDelayMax)
    
    return {
        RequestTime = currentTime,
        ProcessTime = 50, -- Simulated process time
        ResponseTime = currentTime + averageDelay / 1000,
        OptimalRevealTime = TIMING_CONFIG.OptimalRevealBase,
        PsychologicalDelay = psychDelay
    }
end

function CardRollService:_calculateEffectIntensity(rarity: string, isNew: boolean, isPityResult: boolean): number
    local baseIntensity = GameConstants.RarityData[rarity] and GameConstants.RarityData[rarity].EffectIntensity or 0.5
    
    -- Boost intensity for new cards
    if isNew then
        baseIntensity += 0.2
    end
    
    -- Boost intensity for pity results
    if isPityResult then
        baseIntensity += 0.3
    end
    
    return math.min(1.0, baseIntensity)
end

function CardRollService:_calculateBulkDiscount(count: number): number
    if not GameConstants or not GameConstants.Economy or not GameConstants.Economy.BulkDiscounts then
        return 0
    end
    
    local bulkDiscounts = GameConstants.Economy.BulkDiscounts
    
    for i = #bulkDiscounts, 1, -1 do
        local discount = bulkDiscounts[i]
        if count >= discount.Quantity then
            return discount.DiscountPercent
        end
    end
    
    return 0
end

function CardRollService:_updatePlayerDataAfterRoll(player: Player, rollResult: RollResult)
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Add cards to collection
    for _, cardResult in ipairs(rollResult.Cards) do
        playerDataService:AddCardToCollection(player, cardResult.Card.ID)
    end
    
    -- Update economy
    local cost = rollResult.RollCost
    playerDataService:UpdatePlayerEconomy(player, cost.Currency, -cost.Amount)
    
    -- Update stats
    local stats = {
        TotalRolls = {Increment = rollResult.TotalCards}
    }
    
    if cost.Currency == "DailyRolls" then
        stats.DailyRollsUsed = {Increment = rollResult.TotalCards}
    end
    
    playerDataService:UpdatePlayerStats(player, stats)
    
    -- Pity is updated within the roll itself
    
    self:_log("Updated player data after roll for " .. player.Name)
end

function CardRollService:_updateRollStatistics(player: Player, rollResult: RollResult)
    local userID = player.UserId
    
    if not self._rollStatistics[userID] then
        self._rollStatistics[userID] = {
            TotalRolls = 0,
            RollsByRarity = {},
            AverageRollsPerRarity = {},
            PityUsageRate = 0,
            OptimalTimingHitRate = 0,
            PlayerEngagementScore = 0
        }
    end
    
    local stats = self._rollStatistics[userID]
    stats.TotalRolls += rollResult.TotalCards
    
    -- Track rarity distribution
    for _, cardResult in ipairs(rollResult.Cards) do
        local rarity = cardResult.Rarity
        stats.RollsByRarity[rarity] = (stats.RollsByRarity[rarity] or 0) + 1
    end
    
    -- Update pity usage rate
    local pityUsageCount = #rollResult.PityUsed
    if pityUsageCount > 0 then
        stats.PityUsageRate = (stats.PityUsageRate + pityUsageCount / rollResult.TotalCards) / 2
    end
    
    -- Calculate engagement score based on timing and results
    local engagementBonus = 0
    for _, cardResult in ipairs(rollResult.Cards) do
        if cardResult.IsNew then
            engagementBonus += 0.1
        end
        if cardResult.IsPityResult then
            engagementBonus += 0.2
        end
    end
    
    stats.PlayerEngagementScore = math.min(1.0, stats.PlayerEngagementScore + engagementBonus)
end

function CardRollService:_processRollQueue()
    -- Process roll queue for high-load scenarios
    if #self._rollQueue == 0 then
        return
    end
    
    -- Sort by priority
    table.sort(self._rollQueue, function(a, b)
        return a.Priority > b.Priority
    end)
    
    -- Process highest priority roll
    local queueItem = table.remove(self._rollQueue, 1)
    if queueItem then
        -- Process the roll
        spawn(function()
            self:RollCards(queueItem.Request)
        end)
    end
end

function CardRollService:_startAnalytics()
    -- Start analytics tracking
    spawn(function()
        while true do
            wait(300) -- Every 5 minutes
            
            -- Log performance metrics
            self:_log("Roll Statistics:")
            self:_log("  - Total Rolls Processed: " .. self._rollsProcessed)
            self:_log("  - Concurrent Rolls: " .. self._concurrentRolls)
            self:_log("  - Queue Size: " .. #self._rollQueue)
            
            -- Player statistics
            local totalPlayers = 0
            for _ in pairs(self._rollStatistics) do
                totalPlayers += 1
            end
            
            self:_log("  - Active Players: " .. totalPlayers)
        end
    end)
end

return CardRollService.new() 
--- FILE: ./src/server/Services/BattleTestService.luau ---
--!strict
-- BattleTestService.luau
-- Comprehensive test service for the battle system

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local BattleTypes = require(ReplicatedStorage.Shared.Types.BattleTypes)
local CardDatabase = require(ReplicatedStorage.Shared.Data.CardDatabase)

local BattleTestService = {}
BattleTestService.__index = BattleTestService
setmetatable(BattleTestService, {__index = BaseService})

function BattleTestService.new()
    	local self = BaseService.new("BattleTestService", {"BattleService", "PlayerDataService"})
    setmetatable(self, BattleTestService)
    
    return self
end

function BattleTestService:Initialize()
    self:_log("BattleTestService initializing...")
end

function BattleTestService:Start()
    self:_log("BattleTestService starting...")
    
    --[[
    -- Wait for players to join for testing
    Players.PlayerAdded:Connect(function(player)
        wait(4) -- Wait for other services to initialize
        self:_testBattleSystem(player)
    end)
    --]]
end

function BattleTestService:_testBattleSystem(player: Player)
    self:_log("⚔️ Testing Battle System for " .. player.Name)
    
    local battleService = self.ServiceRegistry:GetService("BattleService")
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local cardDatabase = CardDatabase
    
    -- Test 1: Battle creation
    self:_testBattleCreation(player, battleService)
    
    -- Test 2: AI battle
    spawn(function()
        wait(8)
        self:_testAIBattle(player, battleService)
    end)
    
    -- Test 3: Turn management
    spawn(function()
        wait(16)
        self:_testTurnManagement(player, battleService)
    end)
    
    -- Test 4: Damage calculations
    spawn(function()
        wait(24)
        self:_testDamageCalculations(battleService)
    end)
    
    -- Test 5: Action validation
    spawn(function()
        wait(32)
        self:_testActionValidation(player, battleService)
    end)
    
    -- Test 6: Battle statistics
    spawn(function()
        wait(40)
        self:_testBattleStatistics(battleService)
    end)
    
    -- Test 7: Performance metrics
    spawn(function()
        wait(48)
        self:_testPerformanceMetrics(battleService)
    end)
end

function BattleTestService:_testBattleCreation(player: Player, battleService)
    self:_log("Testing battle creation...")
    
    local result = battleService:CreateBattle(player, nil, "Practice")
    
    if result.Success and result.Data then
        self:_log("✅ Battle creation successful")
        self:_log("   - Battle ID: " .. result.Data.BattleID)
        self:_log("   - Player 1: " .. result.Data.Player1.Username)
        self:_log("   - Player 2: " .. result.Data.Player2.Username)
        self:_log("   - Battle State: " .. result.Data.BattleState)
        self:_log("   - Starting Health: " .. result.Data.Player1.Health)
        self:_log("   - Starting Energy: " .. result.Data.Player1.Energy)
        self:_log("   - Hand Size: " .. #result.Data.Player1.Hand)
        self:_log("   - Processing Time: " .. string.format("%.2f", result.ProcessingTime) .. "ms")
        
        -- Verify battle data integrity
        local battle = result.Data
        if battle.Player1.Health > 0 and battle.Player2.Health > 0 then
            self:_log("   - ✅ Health values valid")
        else
            self:_logError("   - ❌ Invalid health values")
        end
        
        if #battle.Player1.Hand > 0 and #battle.Player2.Hand > 0 then
            self:_log("   - ✅ Initial hands drawn")
        else
            self:_logError("   - ❌ Initial hands not properly drawn")
        end
        
        -- Test battle state
        local stateResult = battleService:GetBattleState(player)
        if stateResult.Success then
            self:_log("   - ✅ Battle state retrieval working")
        else
            self:_logError("   - ❌ Battle state retrieval failed")
        end
        
    else
        self:_logError("❌ Battle creation failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function BattleTestService:_testAIBattle(player: Player, battleService)
    self:_log("Testing AI battle...")
    
    local result = battleService:CreateBattle(player, nil, "Practice")
    
    if result.Success and result.Data then
        local battle = result.Data
        self:_log("✅ AI battle created successfully")
        self:_log("   - AI Opponent: " .. battle.Player2.Username)
        self:_log("   - AI UserID: " .. battle.Player2.UserID)
        
        -- Verify AI setup
        if battle.Player2.UserID == -1 then
            self:_log("   - ✅ AI player properly identified")
        else
            self:_logError("   - ❌ AI player not properly set up")
        end
        
        if battle.Player2.IsReady then
            self:_log("   - ✅ AI player is ready")
        else
            self:_logError("   - ❌ AI player not ready")
        end
        
        -- Test AI turn processing (if it's AI's turn)
        if battle.ActivePlayer == 2 then
            self:_log("   - Testing AI turn processing...")
            wait(3) -- Wait for AI to process turn
            
            local updatedState = battleService:GetBattleState(player)
            if updatedState.Success and updatedState.Data then
                if updatedState.Data.CurrentTurn > battle.CurrentTurn then
                    self:_log("   - ✅ AI successfully processed turn")
                else
                    self:_log("   - ⚠️  AI turn still processing or no action taken")
                end
            end
        else
            self:_log("   - Player's turn first, AI will act on next turn")
        end
        
    else
        self:_logError("❌ AI battle creation failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function BattleTestService:_testTurnManagement(player: Player, battleService)
    self:_log("Testing turn management...")
    
    local stateResult = battleService:GetBattleState(player)
    if not stateResult.Success or not stateResult.Data then
        self:_log("⚠️  No active battle for turn management test")
        return
    end
    
    local battle = stateResult.Data
    self:_log("✅ Turn management test starting")
    self:_log("   - Current Turn: " .. battle.CurrentTurn)
    self:_log("   - Active Player: " .. battle.ActivePlayer)
    self:_log("   - Turn Timer: " .. battle.TurnTimer)
    
    -- Test end turn action
    local endTurnAction = {
        ActionID = "test_end_turn",
        PlayerID = player.UserId,
        ActionType = "EndTurn",
        ActionData = {},
        Timestamp = os.time(),
        IsValid = false
    }
    
    local actionResult = battleService:ProcessAction(player, endTurnAction)
    
    if actionResult.Success then
        self:_log("   - ✅ End turn action processed successfully")
        
        -- Verify turn advancement
        wait(0.5)
        local updatedState = battleService:GetBattleState(player)
        if updatedState.Success and updatedState.Data then
            if updatedState.Data.CurrentTurn > battle.CurrentTurn then
                self:_log("   - ✅ Turn advanced successfully")
                self:_log("   - New Turn: " .. updatedState.Data.CurrentTurn)
                self:_log("   - New Active Player: " .. updatedState.Data.ActivePlayer)
            else
                self:_logError("   - ❌ Turn did not advance")
            end
        end
    else
        self:_logError("   - ❌ End turn action failed: " .. (actionResult.ErrorMessage or "Unknown"))
    end
end

function BattleTestService:_testDamageCalculations(battleService)
    self:_log("Testing damage calculations...")
    
    -- Create test battle cards
    local attackingCard = {
        InstanceID = "test_attacker",
        CardData = {
            ID = "test_card_1",
            Name = "Test Attacker",
            Attack = 100,
            Defense = 50,
            Health = 150
        },
        CurrentHealth = 150,
        MaxHealth = 150,
        Attack = 100,
        Defense = 50,
        Energy = 3,
        StatusEffects = {},
        Position = "Active",
        CanAttack = true,
        TurnsOnField = 0,
        DamageDealt = 0,
        DamageTaken = 0
    }
    
    local defendingCard = {
        InstanceID = "test_defender",
        CardData = {
            ID = "test_card_2",
            Name = "Test Defender",
            Attack = 80,
            Defense = 80,
            Health = 120
        },
        CurrentHealth = 120,
        MaxHealth = 120,
        Attack = 80,
        Defense = 80,
        Energy = 2,
        StatusEffects = {},
        Position = "Active",
        CanAttack = false,
        TurnsOnField = 1,
        DamageDealt = 0,
        DamageTaken = 0
    }
    
    -- Create test players
    local attacker = {
        UserID = 1,
        Username = "TestAttacker",
        Health = 100,
        MaxHealth = 100,
        BattleStats = {
            DamageDealt = 0,
            DamageTaken = 0,
            CriticalHits = 0
        }
    }
    
    local defender = {
        UserID = 2,
        Username = "TestDefender",
        Health = 100,
        MaxHealth = 100,
        Shield = 0,
        BattleStats = {
            DamageDealt = 0,
            DamageTaken = 0,
            CriticalHits = 0
        }
    }
    
    -- Test damage calculation (using reflection to access private method)
    local damageCalc = {
        BaseAttack = attackingCard.Attack,
        BaseDamage = attackingCard.Attack,
        AttackModifiers = {},
        DefenseModifiers = {},
        FinalDamage = math.max(1, attackingCard.Attack - defendingCard.Defense),
        IsCritical = false,
        CriticalMultiplier = 1.0,
        DamageType = "Physical",
        Penetration = 0,
        MitigatedDamage = math.max(0, defendingCard.Defense)
    }
    
    self:_log("✅ Damage calculation test")
    self:_log("   - Base Attack: " .. damageCalc.BaseAttack)
    self:_log("   - Target Defense: " .. defendingCard.Defense)
    self:_log("   - Final Damage: " .. damageCalc.FinalDamage)
    self:_log("   - Mitigated Damage: " .. damageCalc.MitigatedDamage)
    self:_log("   - Critical Hit: " .. tostring(damageCalc.IsCritical))
    
    -- Verify damage calculation logic
    local expectedDamage = math.max(1, attackingCard.Attack - defendingCard.Defense)
    if damageCalc.FinalDamage == expectedDamage then
        self:_log("   - ✅ Damage calculation correct")
    else
        self:_logError("   - ❌ Damage calculation incorrect")
    end
    
    -- Test edge cases
    local zeroDamageAttack = math.max(1, 10 - 50) -- Should be 1 (minimum damage)
    if zeroDamageAttack == 1 then
        self:_log("   - ✅ Minimum damage rule working (1 damage)")
    else
        self:_logError("   - ❌ Minimum damage rule not working")
    end
end

function BattleTestService:_testActionValidation(player: Player, battleService)
    self:_log("Testing action validation...")
    
    local stateResult = battleService:GetBattleState(player)
    if not stateResult.Success or not stateResult.Data then
        self:_log("⚠️  No active battle for action validation test")
        return
    end
    
    local battle = stateResult.Data
    
    -- Test valid action
    local validAction = {
        ActionID = "test_valid",
        PlayerID = player.UserId,
        ActionType = "EndTurn",
        ActionData = {},
        Timestamp = os.time(),
        IsValid = false
    }
    
    local validResult = battleService:ProcessAction(player, validAction)
    if validResult.Success then
        self:_log("✅ Valid action accepted")
    else
        self:_log("⚠️  Valid action rejected: " .. (validResult.ErrorMessage or "Unknown"))
    end
    
    -- Test invalid action (wrong player)
    local invalidAction = {
        ActionID = "test_invalid",
        PlayerID = 99999, -- Invalid player ID
        ActionType = "EndTurn",
        ActionData = {},
        Timestamp = os.time(),
        IsValid = false
    }
    
    local invalidResult = battleService:ProcessAction(player, invalidAction)
    if not invalidResult.Success then
        self:_log("✅ Invalid action properly rejected")
        self:_log("   - Reason: " .. (invalidResult.ErrorMessage or "Unknown"))
    else
        self:_logError("❌ Invalid action was accepted (should be rejected)")
    end
    
    -- Test action with insufficient energy (if player has cards)
    if #battle.Player1.Hand > 0 then
        local handCard = battle.Player1.Hand[1]
        local energyAction = {
            ActionID = "test_energy",
            PlayerID = player.UserId,
            ActionType = "PlayCard",
            ActionData = {
                SourceCardID = handCard.InstanceID
            },
            Timestamp = os.time(),
            IsValid = false
        }
        
        -- Temporarily reduce player energy to test validation
        local originalEnergy = battle.Player1.Energy
        battle.Player1.Energy = 0
        
        local energyResult = battleService:ProcessAction(player, energyAction)
        if not energyResult.Success then
            self:_log("✅ Insufficient energy validation working")
        else
            self:_log("⚠️  Energy validation may not be working properly")
        end
        
        -- Restore energy
        battle.Player1.Energy = originalEnergy
    end
end

function BattleTestService:_testBattleStatistics(battleService)
    self:_log("Testing battle statistics...")
    
    local stats = battleService:GetBattleStatistics()
    
    self:_log("📊 Battle Statistics:")
    self:_log("   - Active Battles: " .. stats.ActiveBattles)
    self:_log("   - Battles Completed: " .. stats.BattlesCompleted)
    self:_log("   - Average Battle Duration: " .. string.format("%.2f", stats.AverageBattleDuration) .. "s")
    self:_log("   - Active Player Count: " .. stats.ActivePlayerCount)
    self:_log("   - Queue Size: " .. stats.QueueSize)
    
    -- Verify statistics validity
    if stats.ActiveBattles >= 0 and stats.BattlesCompleted >= 0 then
        self:_log("✅ Statistics values are valid")
    else
        self:_logError("❌ Invalid statistics values")
    end
    
    if stats.ActivePlayerCount >= 0 and stats.ActivePlayerCount <= stats.ActiveBattles * 2 then
        self:_log("✅ Player count within expected range")
    else
        self:_logError("❌ Player count outside expected range")
    end
end

function BattleTestService:_testPerformanceMetrics(battleService)
    self:_log("Testing performance metrics...")
    
    local startTime = os.clock()
    local operationCount = 0
    
    -- Test multiple battle operations
    for i = 1, 10 do
        local stats = battleService:GetBattleStatistics()
        operationCount += 1
        
        -- Simulate some processing time
        wait(0.01)
    end
    
    local endTime = os.clock()
    local duration = endTime - startTime
    local operationsPerSecond = operationCount / duration
    
    self:_log("📊 Performance Metrics:")
    self:_log("   - Operations tested: " .. operationCount)
    self:_log("   - Total duration: " .. string.format("%.3f", duration) .. "s")
    self:_log("   - Operations per second: " .. string.format("%.1f", operationsPerSecond))
    
    -- Test memory usage
    local memoryBefore = collectgarbage("count")
    
    -- Create and destroy multiple battle state objects
    for i = 1, 100 do
        local mockBattle = {
            BattleID = "test_" .. i,
            Player1 = { Username = "Test1", Health = 100 },
            Player2 = { Username = "Test2", Health = 100 },
            CurrentTurn = 1,
            ActivePlayer = 1
        }
        -- Let it be garbage collected
        mockBattle = nil
    end
    
    collectgarbage("collect")
    local memoryAfter = collectgarbage("count")
    local memoryUsed = memoryAfter - memoryBefore
    
    self:_log("   - Memory usage: " .. string.format("%.2f", memoryUsed) .. "KB")
    self:_log("   - Performance impact: " .. (memoryUsed < 50 and "Low" or "High"))
end

function BattleTestService:TestBattleEndConditions()
    self:_log("Testing battle end conditions...")
    
    local battleService = self.ServiceRegistry:GetService("BattleService")
    local testPlayer = Players:GetPlayers()[1]
    
    if not testPlayer then
        self:_log("⚠️  No player to test battle end conditions")
        return
    end
    
    local stateResult = battleService:GetBattleState(testPlayer)
    if not stateResult.Success or not stateResult.Data then
        self:_log("⚠️  No active battle for end condition test")
        return
    end
    
    local battle = stateResult.Data
    
    -- Test surrender
    local surrenderAction = {
        ActionID = "test_surrender",
        PlayerID = testPlayer.UserId,
        ActionType = "Surrender",
        ActionData = {},
        Timestamp = os.time(),
        IsValid = false
    }
    
    local surrenderResult = battleService:ProcessAction(testPlayer, surrenderAction)
    
    if surrenderResult.Success then
        self:_log("✅ Surrender action processed")
        
        -- Check if battle ended
        wait(0.5)
        local endState = battleService:GetBattleState(testPlayer)
        if not endState.Success then
            self:_log("✅ Battle properly ended after surrender")
        else
            self:_log("⚠️  Battle still active after surrender")
        end
    else
        self:_logError("❌ Surrender action failed")
    end
end

function BattleTestService:TestAIBehavior()
    self:_log("Testing AI behavior patterns...")
    
    local battleService = self.ServiceRegistry:GetService("BattleService")
    local testPlayer = Players:GetPlayers()[1]
    
    if not testPlayer then
        self:_log("⚠️  No player to test AI behavior")
        return
    end
    
    -- Create AI battle for testing
    local result = battleService:CreateBattle(testPlayer, nil, "Practice")
    
    if result.Success and result.Data then
        local battle = result.Data
        self:_log("✅ AI behavior test battle created")
        self:_log("   - AI Personality: " .. (battle.Player2.Username or "Unknown"))
        
        -- Monitor AI actions over several turns
        local aiActionCount = 0
        local turnCount = 0
        
        for i = 1, 5 do -- Test 5 turns
            if battle.ActivePlayer == 2 then -- AI turn
                local turnStartTime = os.clock()
                wait(4) -- Wait for AI to act
                
                local updatedState = battleService:GetBattleState(testPlayer)
                if updatedState.Success and updatedState.Data then
                    if updatedState.Data.CurrentTurn > battle.CurrentTurn then
                        aiActionCount += 1
                        local thinkingTime = os.clock() - turnStartTime
                        self:_log("   - AI Turn " .. i .. ": " .. string.format("%.2f", thinkingTime) .. "s thinking time")
                    end
                    battle = updatedState.Data
                end
            else
                -- End player turn quickly
                local endTurnAction = {
                    ActionID = "test_end_" .. i,
                    PlayerID = testPlayer.UserId,
                    ActionType = "EndTurn",
                    ActionData = {},
                    Timestamp = os.time(),
                    IsValid = false
                }
                battleService:ProcessAction(testPlayer, endTurnAction)
                wait(0.5)
            end
            
            turnCount += 1
            wait(1)
        end
        
        self:_log("📊 AI Behavior Results:")
        self:_log("   - AI actions taken: " .. aiActionCount .. "/" .. turnCount)
        self:_log("   - AI responsiveness: " .. string.format("%.1f", (aiActionCount / turnCount) * 100) .. "%")
        
        -- Clean up test battle
        battleService:EndBattle(battle.BattleID, "Test completed")
    else
        self:_logError("❌ Failed to create AI test battle")
    end
end

function BattleTestService:TestBattleIntegration()
    self:_log("Testing battle system integration...")
    
    local battleService = self.ServiceRegistry:GetService("BattleService")
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local cardDatabase = CardDatabase
    local testPlayer = Players:GetPlayers()[1]
    
    if not testPlayer then
        self:_log("⚠️  No player for integration test")
        return
    end
    
    -- Test PlayerDataService integration
    local playerData = playerDataService:GetPlayerData(testPlayer)
    if playerData then
        self:_log("✅ PlayerDataService integration working")
        self:_log("   - Player level: " .. playerData.Stats.Level)
        self:_log("   - Cards owned: " .. playerData.Collection.TotalCardsOwned)
    else
        self:_logError("❌ PlayerDataService integration failed")
    end
    
    -- Test CardDatabase integration
    local testCard = cardDatabase:GetCard("naruto_001")
    if testCard then
        self:_log("✅ CardDatabase integration working")
        self:_log("   - Test card: " .. testCard.Name)
    else
        self:_logError("❌ CardDatabase integration failed")
    end
    
    -- Test battle creation with real player data
    local integrationResult = battleService:CreateBattle(testPlayer, nil, "Practice")
    if integrationResult.Success then
        self:_log("✅ Battle system integration successful")
        self:_log("   - All services working together properly")
    else
        self:_logError("❌ Battle system integration failed")
    end
end

return BattleTestService.new() 
--- FILE: ./src/server/Services/PlayerDataService.luau ---
--!strict
-- PlayerDataService.luau
-- Comprehensive player data management with persistence, validation, and progression tracking

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local PlayerTypes = require(ReplicatedStorage.Shared.Types.PlayerTypes)
local CardTypes = require(ReplicatedStorage.Shared.Types.CardTypes)
local TableUtils = require(ReplicatedStorage.Shared.Utils.TableUtils)

type PlayerData = PlayerTypes.PlayerData
type PlayerSession = PlayerTypes.PlayerSession
type DataServiceResponse<T> = PlayerTypes.DataServiceResponse<T>
type SaveResult = PlayerTypes.SaveResult

local PlayerDataService = {}
PlayerDataService.__index = PlayerDataService
setmetatable(PlayerDataService, {__index = BaseService})

-- Constants
local DATA_STORE_NAME = "PlayerData_v1"
local BACKUP_STORE_NAME = "PlayerBackup_v1"
local SESSION_STORE_NAME = "PlayerSessions_v1"
local AUTO_SAVE_INTERVAL = 300 -- 5 minutes
local MAX_SAVE_RETRIES = 3
local CACHE_EXPIRE_TIME = 1800 -- 30 minutes

function PlayerDataService.new()
    local self = BaseService.new("PlayerDataService", {})
    setmetatable(self, PlayerDataService)
    
    -- Data stores
    self._dataStore = nil
    self._backupStore = nil
    self._sessionStore = nil
    
    -- Player data cache
    self._playerDataCache = {} :: {[number]: PlayerData}
    self._playerSessions = {} :: {[number]: PlayerSession}
    self._saveQueue = {} :: {[number]: boolean}
    self._savingPlayers = {} :: {[number]: boolean}
    
    -- Performance tracking
    self._lastSaveTime = os.time()
    self._saveOperations = 0
    self._loadOperations = 0
    
    return self
end

function PlayerDataService:Initialize()
    self:_log("PlayerDataService initializing...")
    
    -- Initialize data stores
    self:_initializeDataStores()
    
    if not self._dataStore then
        self:_logError("Failed to initialize data stores - running in offline mode")
        return
    end
    
    -- Connect player events
    Players.PlayerAdded:Connect(function(player)
        self:_onPlayerAdded(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:_onPlayerRemoving(player)
    end)
    
    -- Auto-save timer
    self._autoSaveConnection = RunService.Heartbeat:Connect(function()
        self:_processAutoSave()
    end)
    
    self:_log("PlayerDataService initialized successfully")
end

function PlayerDataService:Start()
    self:_log("PlayerDataService starting...")
    
    -- Connect to player events
    Players.PlayerAdded:Connect(function(player)
        self:_onPlayerAdded(player)
    end)
    
    Players.PlayerRemoving:Connect(function(player)
        self:_onPlayerRemoving(player)
    end)

    -- Start the auto-save loop
    self:_startAutoSaveLoop()
    
    self:_log("PlayerDataService started successfully")
end

function PlayerDataService:Stop()
    self:_log("PlayerDataService stopping...")
    
    -- Save all player data
    for userID, _ in pairs(self._playerDataCache) do
        local player = Players:GetPlayerByUserId(userID)
        if player then
            self:SavePlayerData(player):await()
        end
    end
    
    -- Clean up connections
    if self._autoSaveConnection then
        self._autoSaveConnection:Disconnect()
    end
    
    self:_log("PlayerDataService stopped")
end

-- Public Methods

function PlayerDataService:GetPlayerData(player: Player): PlayerData?
    local userID = player.UserId
    return self._playerDataCache[userID]
end

function PlayerDataService:GetPlayerSession(player: Player): PlayerSession?
    local userID = player.UserId
    return self._playerSessions[userID]
end

function PlayerDataService:LoadPlayerData(player: Player): DataServiceResponse<PlayerData>
    local userID = player.UserId
    
    -- Check cache first
    if self._playerDataCache[userID] then
        return {
            Success = true,
            Data = self._playerDataCache[userID]
        }
    end
    
    self._loadOperations += 1
    self:_log("Loading player data for " .. player.Name)
    
    local success, result = pcall(function()
        if not self._dataStore then
            error("Data store not available")
        end
        
        local data = self._dataStore:GetAsync(tostring(userID))
        return data
    end)
    
    if not success then
        self:_logError("Failed to load player data: " .. tostring(result))
        return {
            Success = false,
            ErrorMessage = "Failed to load player data"
        }
    end
    
    local playerData: PlayerData
    if result then
        -- Validate and migrate existing data
        playerData = self:_validatePlayerData(result, player)
    else
        -- Create new player data
        playerData = self:_createDefaultPlayerData(player)
    end
    
    -- Cache the data
    self._playerDataCache[userID] = playerData
    
    return {
        Success = true,
        Data = playerData
    }
end

function PlayerDataService:SavePlayerData(player: Player): SaveResult
    local userID = player.UserId
    local playerData = self._playerDataCache[userID]
    
    if not playerData then
        return {
            Success = false,
            ErrorMessage = "No player data to save"
        }
    end
    
    -- Skip if already saving
    if self._savingPlayers[userID] then
        return {
            Success = false,
            ErrorMessage = "Save already in progress"
        }
    end
    
    self._savingPlayers[userID] = true
    self._saveOperations += 1
    
    -- Update save metadata
    playerData.LastSaveTime = os.time()
    playerData.IsDirty = false
    
    local success, errorMessage = pcall(function()
        if not self._dataStore then
            error("Data store not available")
        end
        
        -- Create backup first
        local backupKey = tostring(userID) .. "_backup"
        pcall(function()
            self._backupStore:SetAsync(backupKey, playerData)
        end)
        
        -- Save main data
        self._dataStore:SetAsync(tostring(userID), playerData)
    end)
    
    self._savingPlayers[userID] = nil
    
    if not success then
        self:_logError("Failed to save player data: " .. tostring(errorMessage))
        return {
            Success = false,
            SaveTime = os.time(),
            ErrorMessage = "Failed to save player data"
        }
    end
    
    self:_log("Saved player data for " .. player.Name)
    return {
        Success = true,
        SaveTime = os.time()
    }
end

function PlayerDataService:UpdatePlayerStats(player: Player, statUpdates: {[string]: any}): boolean
    local playerData = self:GetPlayerData(player)
    if not playerData then
        return false
    end
    
    for statName, value in pairs(statUpdates) do
        if playerData.Stats[statName] ~= nil then
            playerData.Stats[statName] = value
        end
    end
    
    -- Calculate derived stats
    self:_calculateDerivedStats(playerData)
    
    playerData.IsDirty = true
    return true
end

function PlayerDataService:AddCardToCollection(player: Player, cardID: string): boolean
    local playerData = self:GetPlayerData(player)
    if not playerData then
        return false
    end
    
    local collection = playerData.Collection
    local currentTime = os.time()
    
    -- Create card instance
    local cardInstance = {
        ID = self:_generateCardInstanceID(),
        CardID = cardID,
        ObtainedTime = currentTime,
        TimesUsed = 0,
        WinsWithCard = 0,
        LossesWithCard = 0,
        DamageDealt = 0,
        IsNew = true,
        IsFavorite = false
    }
    
    -- Add to collection
    collection.OwnedCards[cardInstance.ID] = cardInstance
    collection.CardCounts[cardID] = (collection.CardCounts[cardID] or 0) + 1
    collection.TotalCardsOwned += 1
    
    -- Check if new unique card
    if collection.CardCounts[cardID] == 1 then
        collection.UniqueCardsOwned += 1
    end
    
    -- Add to recently obtained
    table.insert(collection.RecentlyObtained, cardInstance.ID)
    if #collection.RecentlyObtained > 10 then
        table.remove(collection.RecentlyObtained, 1)
    end
    
    -- Update collection value
    self:_updateCollectionValue(playerData)
    
    playerData.IsDirty = true
    return true
end

function PlayerDataService:UpdatePityData(player: Player, rarity: string, wasPityRoll: boolean)
	local playerData = self:GetPlayerData(player)
	if not playerData then return end
	
	if wasPityRoll then
		-- Reset pity for this rarity and all lower rarities
		playerData.Pity[rarity] = 0
		
		-- Example: if Legendary pity is used, reset Epic and Rare too
		local rarityOrder = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Ultimate"}
		local rarityIndex = table.find(rarityOrder, rarity)
		if rarityIndex then
			for i = 1, rarityIndex - 1 do
				playerData.Pity[rarityOrder[i]] = 0
			end
		end
		
	else
		-- Increment pity for all rarities that weren't won
		for r, _ in pairs(playerData.Pity) do
			if r ~= rarity then
				playerData.Pity[r] = (playerData.Pity[r] or 0) + 1
			end
		end
	end
	
	self:_log(string.format("Pity data updated for %s: %s", player.Name, HttpService:JSONEncode(playerData.Pity)))
end

function PlayerDataService:UpdatePlayerEconomy(player: Player, currency: string, amount: number): boolean
    local playerData = self:GetPlayerData(player)
    if not playerData then
        return false
    end
    
    local economy = playerData.Economy
    
    if economy[currency] then
        economy[currency] = math.max(0, economy[currency] + amount)
        
        -- Track earnings/spending
        if amount > 0 then
            economy.EarnedTotal += amount
        else
            economy.SpentTotal += math.abs(amount)
        end
        
        playerData.IsDirty = true
        return true
    end
    
    return false
end

function PlayerDataService:GetPlayerLevel(player: Player): number
    local playerData = self:GetPlayerData(player)
    if not playerData then
        return 1
    end
    
    return playerData.Stats.Level
end

function PlayerDataService:AddExperience(player: Player, amount: number): boolean
    local playerData = self:GetPlayerData(player)
    if not playerData then
        return false
    end
    
    local stats = playerData.Stats
    stats.Experience += amount
    
    -- Check for level up
    while stats.Experience >= stats.ExperienceToNext do
        stats.Experience -= stats.ExperienceToNext
        stats.Level += 1
        stats.ExperienceToNext = self:_calculateExperienceToNext(stats.Level)
        
        -- Level up rewards
        self:_processLevelUpRewards(player, stats.Level)
    end
    
    playerData.IsDirty = true
    return true
end

-- Private Methods

function PlayerDataService:_initializeDataStores()
	if not RunService:IsStudio() then
		-- In a live server, try to get DataStoreService
		local success, result = pcall(function()
			return game:GetService("DataStoreService")
		end)
		
		if success and result then
			self._dataStore = result:GetDataStore("PlayerData_v1")
			self:_log("Successfully connected to DataStore.")
		else
			self:_logError("Failed to get DataStoreService. Running in offline mode.")
			self._dataStore = nil
		end
	else
		-- In Studio, we are always in offline mode for testing
		self:_log("Running in Roblox Studio. DataStore is disabled. Using offline mode.")
		self._dataStore = nil
	end
end

function PlayerDataService:_onPlayerAdded(player: Player)
	local playerID = player.UserId
	self:_log("Player joined: " .. player.Name .. " (ID: " .. playerID .. ")")
	
	if self._dataStore then
		-- Load data from DataStore
		-- (Implementation for live server)
	else
		-- Offline mode: create default data for testing
		self:_log("Creating default data for " .. player.Name .. " in offline mode.")
		local defaultData: PlayerTypes.PlayerData = {
			PlayerId = playerID,
			Name = player.Name,
			Level = 1,
			Experience = 0,
			Gems = 1000,
			Cards = {},
			Pity = {
				Rare = 0,
				Epic = 0,
				Legendary = 0,
			},
			LastLogin = os.time(),
			Settings = {
				Volume = 1,
				AutoSkip = false,
			},
		}
		self._playerDataCache[playerID] = defaultData
		self:_log("Default data created for " .. player.Name)
	end
end

function PlayerDataService:_onPlayerRemoving(player: Player)
	local playerID = player.UserId
	self:_log("Player left: " .. player.Name .. " (ID: " .. playerID .. ")")

	-- Save their data one last time
	if self._playerDataCache[playerID] then
		self:_savePlayerData(playerID, self._playerDataCache[playerID])
	end

	-- Clear from cache
	self._playerDataCache[playerID] = nil
	self:_log("Cleared data cache for " .. player.Name)
end

function PlayerDataService:_startAutoSaveLoop()
	-- This will periodically save data for all online players
	spawn(function()
		while true do
			wait(GameConstants.Settings.AutoSaveInterval or 300) -- Default to 5 minutes
			
			if not self._dataStore then return end -- Don't run in offline mode
			
			self:_log("Performing periodic auto-save...")
			for playerID, data in pairs(self._playerDataCache) do
				self:_savePlayerData(playerID, data)
			end
		end
	end)
end

function PlayerDataService:_savePlayerData(playerID: number, data: PlayerTypes.PlayerData)
	if not self._dataStore then return end -- No saving in offline mode

	local success, err = pcall(function()
		self._dataStore:SetAsync(tostring(playerID), data)
	end)

	if not success then
		self:_logError("Failed to save data for player " .. tostring(playerID) .. ": " .. err)
	else
		self:_log("Successfully saved data for player " .. tostring(playerID))
	end
end

function PlayerDataService:_createDefaultPlayerData(player: Player): PlayerData
    local currentTime = os.time()
    
    return {
        UserID = player.UserId,
        Username = player.Name,
        Stats = {
            Level = 1,
            Experience = 0,
            ExperienceToNext = 100,
            TotalRolls = 0,
            RollsToNextPity = 0,
            BattlesWon = 0,
            BattlesLost = 0,
            WinRate = 0,
            HighestWinStreak = 0,
            CurrentWinStreak = 0,
            TotalDamageDealt = 0,
            TotalDamageReceived = 0,
            FavoriteCard = nil,
            PlayTime = 0,
            FirstLoginTime = currentTime,
            LastLoginTime = currentTime,
            LoginStreak = 1,
            DailyRollsUsed = 0,
            DailyRollsResetTime = currentTime + 86400
        },
        Collection = {
            OwnedCards = {},
            CardCounts = {},
            TotalCardsOwned = 0,
            UniqueCardsOwned = 0,
            FavoriteCards = {},
            RecentlyObtained = {},
            CollectionValue = 0
        },
        Progression = {
            CurrentDeck = {},
            UnlockedFeatures = {"basic_battle", "card_collection"},
            Achievements = {},
            QuestProgress = {},
            CompletedQuests = {},
            TutorialProgress = {},
            LastSeenNews = nil,
            Settings = self:_getDefaultSettings()
        },
        PityData = {
            CommonPity = 0,
            RarePity = 0,
            EpicPity = 0,
            LegendaryPity = 0,
            MythicalPity = 0,
            UltimatePity = 0,
            LastLegendaryRoll = 0,
            LastMythicalRoll = 0,
            LastUltimateRoll = 0,
            GuaranteedNext = nil,
            RollHistory = {}
        },
        Economy = {
            Coins = GameConstants.Balance.StartingCoins,
            Gems = GameConstants.Balance.StartingGems,
            DailyRolls = GameConstants.Balance.DailyRolls,
            PremiumRolls = 0,
            BattleTokens = 0,
            LastDailyReward = 0,
            LastWeeklyReward = 0,
            PurchaseHistory = {},
            SpentTotal = 0,
            EarnedTotal = 0
        },
        Social = {
            Friends = {},
            BlockedUsers = {},
            GuildID = nil,
            GuildRank = nil,
            RecentOpponents = {},
            Reputation = 100,
            ReportsMade = 0,
            ReportsReceived = 0,
            LastReportTime = 0
        },
        DataVersion = 1,
        LastSaveTime = currentTime,
        IsDirty = false
    }
end

function PlayerDataService:_getDefaultSettings(): PlayerTypes.PlayerSettings
    return {
        SoundEnabled = true,
        MusicEnabled = true,
        SoundVolume = 0.8,
        MusicVolume = 0.6,
        ScreenShakeEnabled = true,
        ScreenShakeIntensity = 0.8,
        AutoPlay = false,
        SkipAnimations = false,
        ShowDamageNumbers = true,
        ShowCardTooltips = true,
        ChatEnabled = true,
        FriendRequestsEnabled = true,
        DataCollectionConsent = false
    }
end

function PlayerDataService:_validatePlayerData(data: any, player: Player): PlayerData
    -- Basic validation and migration logic
    if type(data) ~= "table" then
        return self:_createDefaultPlayerData(player)
    end
    
    -- Ensure all required fields exist
    local validData = TableUtils.DeepCopy(data)
    local defaultData = self:_createDefaultPlayerData(player)
    
    -- Merge missing fields
    validData = TableUtils.DeepMerge(defaultData, validData)
    
    -- Update username if changed
    validData.Username = player.Name
    
    -- Update login time
    validData.Stats.LastLoginTime = os.time()
    
    return validData
end

function PlayerDataService:_calculateDerivedStats(playerData: PlayerData)
    local stats = playerData.Stats
    
    -- Calculate win rate
    local totalBattles = stats.BattlesWon + stats.BattlesLost
    if totalBattles > 0 then
        stats.WinRate = stats.BattlesWon / totalBattles
    else
        stats.WinRate = 0
    end
end

function PlayerDataService:_calculateExperienceToNext(level: number): number
    return math.floor(100 * (level ^ 1.5))
end

function PlayerDataService:_processLevelUpRewards(player: Player, newLevel: number)
    -- Give level up rewards
    local coinsReward = newLevel * 50
    local gemsReward = math.floor(newLevel / 5)
    
    self:UpdatePlayerEconomy(player, "Coins", coinsReward)
    if gemsReward > 0 then
        self:UpdatePlayerEconomy(player, "Gems", gemsReward)
    end
    
    self:_log("Player " .. player.Name .. " reached level " .. newLevel)
end

function PlayerDataService:_updateCollectionValue(playerData: PlayerData)
    local totalValue = 0
    for cardID, count in pairs(playerData.Collection.CardCounts) do
        -- Calculate value based on rarity and count
        -- This would integrate with CardDatabase to get rarity
        totalValue += count * 10 -- Placeholder calculation
    end
    
    playerData.Collection.CollectionValue = totalValue
end

function PlayerDataService:_generateCardInstanceID(): string
    return "card_" .. tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
end

function PlayerDataService:_processAutoSave()
    local currentTime = os.time()
    
    -- Auto-save every 5 minutes
    if currentTime - self._lastSaveTime >= AUTO_SAVE_INTERVAL then
        for userID, isDirty in pairs(self._saveQueue) do
            if isDirty then
                local player = Players:GetPlayerByUserId(userID)
                if player then
                    spawn(function()
                        self:SavePlayerData(player)
                    end)
                end
            end
        end
        
        self._lastSaveTime = currentTime
    end
    
    -- Update save queue for dirty data
    for userID, playerData in pairs(self._playerDataCache) do
        if playerData.IsDirty then
            self._saveQueue[userID] = true
        end
    end
end

function PlayerDataService:_logError(message: string)
	warn("[PlayerDataService] ERROR: " .. message)
end

return PlayerDataService.new() 
--- FILE: ./src/server/Services/PlayerDataTestService.luau ---
--!strict
-- PlayerDataTestService.luau
-- Test service for PlayerDataService functionality

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)

local PlayerDataTestService = {}
PlayerDataTestService.__index = PlayerDataTestService
setmetatable(PlayerDataTestService, {__index = BaseService})

function PlayerDataTestService.new()
    local self = BaseService.new("PlayerDataTestService", {"PlayerDataService"})
    setmetatable(self, PlayerDataTestService)
    
    return self
end

function PlayerDataTestService:Initialize()
    self:_log("PlayerDataTestService initializing...")
end

function PlayerDataTestService:Start()
    self:_log("PlayerDataTestService starting...")
    
    --[[
    -- Wait for players to join for testing
    Players.PlayerAdded:Connect(function(player)
        wait(2) -- Wait for PlayerDataService to load the player
        self:_testPlayerDataOperations(player)
    end)
    --]]
end

function PlayerDataTestService:_testPlayerDataOperations(player: Player)
    self:_log("Testing PlayerDataService operations for " .. player.Name)
    
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Test 1: Get player data
    local playerData = playerDataService:GetPlayerData(player)
    if playerData then
        self:_log("✅ Successfully retrieved player data for " .. player.Name)
        self:_log("   - Level: " .. playerData.Stats.Level)
        self:_log("   - Coins: " .. playerData.Economy.Coins)
        self:_log("   - Gems: " .. playerData.Economy.Gems)
    else
        self:_logError("❌ Failed to retrieve player data for " .. player.Name)
        return
    end
    
    -- Test 2: Update player stats
    local success = playerDataService:UpdatePlayerStats(player, {
        BattlesWon = 5,
        BattlesLost = 2,
        TotalDamageDealt = 1500
    })
    if success then
        self:_log("✅ Successfully updated player stats")
        local updatedData = playerDataService:GetPlayerData(player)
        self:_log("   - Win Rate: " .. string.format("%.2f", updatedData.Stats.WinRate))
    else
        self:_logError("❌ Failed to update player stats")
    end
    
    -- Test 3: Add experience
    local initialLevel = playerData.Stats.Level
    local expSuccess = playerDataService:AddExperience(player, 250)
    if expSuccess then
        self:_log("✅ Successfully added experience")
        local updatedData = playerDataService:GetPlayerData(player)
        self:_log("   - New Level: " .. updatedData.Stats.Level)
        self:_log("   - Experience: " .. updatedData.Stats.Experience .. "/" .. updatedData.Stats.ExperienceToNext)
        
        if updatedData.Stats.Level > initialLevel then
            self:_log("   - 🎉 Level up detected! New level: " .. updatedData.Stats.Level)
        end
    else
        self:_logError("❌ Failed to add experience")
    end
    
    -- Test 4: Update economy
    local economySuccess = playerDataService:UpdatePlayerEconomy(player, "Coins", 500)
    if economySuccess then
        self:_log("✅ Successfully updated economy")
        local updatedData = playerDataService:GetPlayerData(player)
        self:_log("   - New Coins: " .. updatedData.Economy.Coins)
    else
        self:_logError("❌ Failed to update economy")
    end
    
    -- Test 5: Add card to collection
    local cardSuccess = playerDataService:AddCardToCollection(player, "naruto_001")
    if cardSuccess then
        self:_log("✅ Successfully added card to collection")
        local updatedData = playerDataService:GetPlayerData(player)
        self:_log("   - Total Cards: " .. updatedData.Collection.TotalCardsOwned)
        self:_log("   - Unique Cards: " .. updatedData.Collection.UniqueCardsOwned)
    else
        self:_logError("❌ Failed to add card to collection")
    end
    
    -- Test 6: Update pity data
    local pitySuccess = playerDataService:UpdatePityData(player, "Legendary", false)
    if pitySuccess then
        self:_log("✅ Successfully updated pity data")
        local updatedData = playerDataService:GetPlayerData(player)
        self:_log("   - Legendary Pity: " .. updatedData.PityData.LegendaryPity)
    else
        self:_logError("❌ Failed to update pity data")
    end
    
    -- Test 7: Get player session
    local session = playerDataService:GetPlayerSession(player)
    if session then
        self:_log("✅ Successfully retrieved player session")
        self:_log("   - Session Start: " .. os.date("%H:%M:%S", session.SessionStartTime))
        self:_log("   - Current Location: " .. session.CurrentLocation)
    else
        self:_logError("❌ Failed to retrieve player session")
    end
    
    -- Test 8: Save player data
    local saveResult = playerDataService:SavePlayerData(player)
    if saveResult.Success then
        self:_log("✅ Successfully saved player data")
        self:_log("   - Save Time: " .. os.date("%H:%M:%S", saveResult.SaveTime))
    else
        self:_logError("❌ Failed to save player data: " .. (saveResult.ErrorMessage or "Unknown error"))
    end
    
    -- Test performance data
    self:_log("📊 Performance Metrics:")
    self:_log("   - Load Operations: " .. (playerDataService._loadOperations or 0))
    self:_log("   - Save Operations: " .. (playerDataService._saveOperations or 0))
    
    self:_log("🎯 PlayerDataService testing completed for " .. player.Name)
end

function PlayerDataTestService:TestBatchOperations()
    self:_log("Testing batch operations on PlayerDataService...")
    
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Test with multiple players
    local players = Players:GetPlayers()
    if #players == 0 then
        self:_log("⚠️  No players to test batch operations")
        return
    end
    
    local startTime = os.clock()
    
    for _, player in pairs(players) do
        -- Simulate typical player operations
        playerDataService:UpdatePlayerStats(player, {
            TotalRolls = math.random(1, 100),
            BattlesWon = math.random(1, 50),
            BattlesLost = math.random(1, 30)
        })
        
        playerDataService:AddExperience(player, math.random(50, 200))
        playerDataService:UpdatePlayerEconomy(player, "Coins", math.random(100, 500))
        
        -- Add some random cards
        for i = 1, math.random(1, 5) do
            local cardID = "test_card_" .. tostring(math.random(1, 100))
            playerDataService:AddCardToCollection(player, cardID)
        end
    end
    
    local endTime = os.clock()
    local duration = endTime - startTime
    
    self:_log("✅ Batch operations completed")
    self:_log("   - Players processed: " .. #players)
    self:_log("   - Duration: " .. string.format("%.3f", duration) .. "s")
    self:_log("   - Operations per second: " .. string.format("%.1f", (#players * 4) / duration))
end

function PlayerDataTestService:TestDataValidation()
    self:_log("Testing data validation...")
    
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local testPlayer = Players:GetPlayers()[1]
    
    if not testPlayer then
        self:_log("⚠️  No player to test data validation")
        return
    end
    
    -- Test invalid operations
    local invalidStats = playerDataService:UpdatePlayerStats(testPlayer, {
        InvalidField = "test",
        Level = "not_a_number"
    })
    
    local invalidEconomy = playerDataService:UpdatePlayerEconomy(testPlayer, "InvalidCurrency", 100)
    
    self:_log("✅ Data validation test completed")
    self:_log("   - Invalid stats update handled: " .. tostring(not invalidStats))
    self:_log("   - Invalid economy update handled: " .. tostring(not invalidEconomy))
end

function PlayerDataTestService:TestMemoryUsage()
    self:_log("Testing memory usage...")
    
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Get cache size
    local cacheSize = 0
    for _ in pairs(playerDataService._playerDataCache) do
        cacheSize += 1
    end
    
    local sessionSize = 0
    for _ in pairs(playerDataService._playerSessions) do
        sessionSize += 1
    end
    
    self:_log("📊 Memory Usage:")
    self:_log("   - Cached player data: " .. cacheSize)
    self:_log("   - Active sessions: " .. sessionSize)
    self:_log("   - Save queue size: " .. self:_getTableSize(playerDataService._saveQueue))
end

function PlayerDataTestService:_getTableSize(t: table): number
    local count = 0
    for _ in pairs(t) do
        count += 1
    end
    return count
end

return PlayerDataTestService.new() 
--- FILE: ./src/server/Services/BattleService.luau ---
--!strict
-- BattleService.luau
-- Server-side battle system with elevated 2D combat mechanics

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local HttpService = game:GetService("HttpService")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local BattleTypes = require(ReplicatedStorage.Shared.Types.BattleTypes)
local CardTypes = require(ReplicatedStorage.Shared.Types.CardTypes)
local PlayerTypes = require(ReplicatedStorage.Shared.Types.PlayerTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)
local CardDatabase = require(ReplicatedStorage.Shared.Data.CardDatabase)
local TableUtils = require(ReplicatedStorage.Shared.Utils.TableUtils)

type BattleSession = BattleTypes.BattleSession
type BattlePlayer = BattleTypes.BattlePlayer
type BattleCard = BattleTypes.BattleCard
type BattleAction = BattleTypes.BattleAction
type BattleServiceResponse<T> = BattleTypes.BattleServiceResponse<T>
type DamageCalculation = BattleTypes.DamageCalculation
type AIOpponent = BattleTypes.AIOpponent

local BattleService = {}
BattleService.__index = BattleService
setmetatable(BattleService, {__index = BaseService})

-- Battle Configuration
local BATTLE_CONFIG = {
    DefaultTurnTime = 30, -- seconds
    MaxBattleDuration = 1800, -- 30 minutes
    StartingHealth = 100,
    StartingEnergy = 3,
    MaxEnergy = 10,
    HandSize = 5,
    DeckSize = 20,
    ImpactFrameDuration = 6, -- frames
    CriticalChance = 0.1,
    CriticalMultiplier = 1.5
}

-- AI Personalities
local AI_PERSONALITIES = {
    Easy = {
        Aggression = 0.3,
        Defense = 0.7,
        RiskTaking = 0.2,
        Patience = 0.8,
        Adaptability = 0.3
    },
    Medium = {
        Aggression = 0.5,
        Defense = 0.5,
        RiskTaking = 0.4,
        Patience = 0.6,
        Adaptability = 0.5
    },
    Hard = {
        Aggression = 0.7,
        Defense = 0.4,
        RiskTaking = 0.6,
        Patience = 0.4,
        Adaptability = 0.7
    },
    Expert = {
        Aggression = 0.8,
        Defense = 0.6,
        RiskTaking = 0.7,
        Patience = 0.3,
        Adaptability = 0.9
    },
    Master = {
        Aggression = 0.9,
        Defense = 0.8,
        RiskTaking = 0.8,
        Patience = 0.2,
        Adaptability = 1.0
    }
}

function BattleService.new()
    	local self = BaseService.new("BattleService", {"PlayerDataService"})
    setmetatable(self, BattleService)
    
    -- Battle tracking
    self._activeBattles = {} :: {[string]: BattleSession}
    self._playerBattles = {} :: {[number]: string} -- UserID -> BattleID
    self._battleQueue = {} :: {BattleTypes.MatchmakingRequest}
    
    -- AI opponents
    self._aiOpponents = {} :: {[string]: AIOpponent}
    
    -- Performance tracking
    self._battlesCompleted = 0
    self._averageBattleDuration = 0
    self._activePlayerCount = 0
    
    -- Turn processing
    self._turnTimers = {} :: {[string]: number}
    
    return self
end

function BattleService:Initialize()
    self:_log("BattleService initializing...")
    
    -- Initialize AI opponents
    self:_initializeAIOpponents()
    
    -- Setup remote event handlers
    self:_setupRemoteHandlers()
    
    -- Start battle processing
    self._battleProcessingConnection = RunService.Heartbeat:Connect(function()
        self:_processBattleUpdates()
    end)
    
    self:_log("BattleService initialized successfully")
end

function BattleService:Start()
    self:_log("BattleService starting...")
    
    -- Start matchmaking processing
    self:_startMatchmakingProcessor()
    
    self:_log("BattleService started successfully")
end

function BattleService:Stop()
    self:_log("BattleService stopping...")
    
    -- End all active battles
    for battleID, battle in pairs(self._activeBattles) do
        self:EndBattle(battleID, "ServerShutdown")
    end
    
    -- Clean up connections
    if self._battleProcessingConnection then
        self._battleProcessingConnection:Disconnect()
    end
    
    self:_log("BattleService stopped")
end

-- Public Methods

function BattleService:StartBattle(player: Player, request: BattleTypes.StartBattleRequest): BattleServiceResponse<BattleSession>
    local startTime = os.clock()
    local battleID = self:_generateBattleID()
    
    self:_log("Creating battle: " .. battleID .. " for " .. player.Name)
    
    -- Get player data
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    local playerData = playerDataService:GetPlayerData(player)
    
    if not playerData then
        return {
            Success = false,
            ErrorMessage = "Player data not available",
            ProcessingTime = (os.clock() - startTime) * 1000,
            BattleID = battleID,
        }
    end
    
    -- Create battle players
    local battlePlayer1 = self:_createBattlePlayer(player, playerData)
    local battlePlayer2: BattlePlayer
    
    if request.BattleType == "PVE" then
        -- AI battle
        local opponentID = request.OpponentId or "AI_EASY_01"
        battlePlayer2 = self:_createAIBattlePlayer(opponentID)
    else
        -- PvP battle (not implemented)
        return {
            Success = false,
            ErrorMessage = "PvP battles are not yet implemented.",
            ProcessingTime = (os.clock() - startTime) * 1000,
            BattleID = battleID,
        }
    end
    
    -- Create battle session
    local battleSession: BattleSession = {
        BattleID = battleID,
        Player1 = battlePlayer1,
        Player2 = battlePlayer2,
        CurrentTurn = 1,
        ActivePlayer = 1,
        BattleState = "Starting",
        TurnTimer = BATTLE_CONFIG.DefaultTurnTime,
        BattleStartTime = os.time(),
        BattleEndTime = nil,
        Winner = nil,
        BattleType = request.BattleType,
        Spectators = {},
        BattleSettings = self:_getDefaultBattleSettings()
    }
    
    -- Store battle
    self._activeBattles[battleID] = battleSession
    self._playerBattles[player.UserId] = battleID
    
    -- Start battle
    self:_startBattle(battleSession)
    
    return {
        Success = true,
        Data = battleSession,
        ProcessingTime = (os.clock() - startTime) * 1000,
        BattleID = battleID,
    }
end

function BattleService:ProcessAction(player: Player, action: BattleAction): BattleServiceResponse<boolean>
    local startTime = os.clock()
    local battleID = self._playerBattles[player.UserId]
    
    if not battleID then
        return {
            Success = false,
            ErrorMessage = "Player not in battle",
            ProcessingTime = (os.clock() - startTime) * 1000
        }
    end
    
    local battle = self._activeBattles[battleID]
    if not battle then
        return {
            Success = false,
            ErrorMessage = "Battle not found",
            ProcessingTime = (os.clock() - startTime) * 1000,
            BattleID = battleID
        }
    end
    
    -- Validate action
    local validation = self:_validateAction(battle, player, action)
    if not validation.IsValid then
        return {
            Success = false,
            ErrorMessage = validation.ErrorReason or "Invalid action",
            ProcessingTime = (os.clock() - startTime) * 1000,
            BattleID = battleID
        }
    end
    
    -- Process action
    local success = self:_executeAction(battle, action)
    
    if success then
        -- Broadcast action to clients
        self:_broadcastBattleUpdate(battle, {
            Type = "ActionExecuted",
            Action = action,
            BattleState = battle
        })
        
        -- Check for battle end conditions
        self:_checkBattleEndConditions(battle)
    end
    
    return {
        Success = success,
        Data = success,
        ProcessingTime = (os.clock() - startTime) * 1000,
        BattleID = battleID
    }
end

function BattleService:GetBattleState(player: Player): BattleServiceResponse<BattleSession>
    local battleID = self._playerBattles[player.UserId]
    
    if not battleID then
        return {
            Success = false,
            ErrorMessage = "Player not in battle",
            ProcessingTime = 0
        }
    end
    
    local battle = self._activeBattles[battleID]
    if not battle then
        return {
            Success = false,
            ErrorMessage = "Battle not found",
            ProcessingTime = 0,
            BattleID = battleID
        }
    end
    
    return {
        Success = true,
        Data = battle,
        ProcessingTime = 0,
        BattleID = battleID
    }
end

function BattleService:EndBattle(battleID: string, reason: string): boolean
    local battle = self._activeBattles[battleID]
    if not battle then
        return false
    end
    
    self:_log("Ending battle: " .. battleID .. " - " .. reason)
    
    -- Calculate battle results
    local battleResult = self:_calculateBattleResult(battle)
    
    -- Update player statistics
    self:_updatePlayerBattleStats(battle, battleResult)
    
    -- Clean up battle
    battle.BattleState = "Finished"
    battle.BattleEndTime = os.time()
    
    -- Remove from tracking
    self._activeBattles[battleID] = nil
    self._playerBattles[battle.Player1.UserID] = nil
    if battle.Player2.UserID > 0 then -- Not AI
        self._playerBattles[battle.Player2.UserID] = nil
    end
    
    -- Broadcast battle end
    self:_broadcastBattleUpdate(battle, {
        Type = "BattleEnded",
        Result = battleResult,
        Reason = reason
    })
    
    self._battlesCompleted += 1
    return true
end

function BattleService:GetActiveBattleCount(): number
    local count = 0
    for _ in pairs(self._activeBattles) do
        count += 1
    end
    return count
end

function BattleService:GetBattleStatistics(): {[string]: any}
    return {
        ActiveBattles = self:GetActiveBattleCount(),
        BattlesCompleted = self._battlesCompleted,
        AverageBattleDuration = self._averageBattleDuration,
        ActivePlayerCount = self._activePlayerCount,
        QueueSize = #self._battleQueue
    }
end

-- Private Methods

function BattleService:_createBattlePlayer(player: Player, playerData: PlayerTypes.PlayerData): BattlePlayer
    -- Get player's deck from collection
    local deck = self:_buildDeckFromCollection(playerData)
    
    return {
        UserID = player.UserId,
        Username = player.Name,
        Deck = deck,
        Hand = {},
        ActiveCard = nil,
        Health = BATTLE_CONFIG.StartingHealth,
        MaxHealth = BATTLE_CONFIG.StartingHealth,
        Energy = BATTLE_CONFIG.StartingEnergy,
        MaxEnergy = BATTLE_CONFIG.MaxEnergy,
        Shield = 0,
        StatusEffects = {},
        IsReady = false,
        LastActionTime = os.time(),
        BattleStats = self:_createEmptyBattleStats()
    }
end

function BattleService:_createAIBattlePlayer(battleType: BattleTypes.BattleType): BattlePlayer
    local difficulty = battleType == "Practice" and "Easy" or "Medium"
    local aiOpponent = self._aiOpponents[difficulty] or self._aiOpponents["Easy"]
    
    local aiDeck = self:_buildAIDeck(aiOpponent)
    
    return {
        UserID = -1, -- AI identifier
        Username = aiOpponent.Name,
        Deck = aiDeck,
        Hand = {},
        ActiveCard = nil,
        Health = BATTLE_CONFIG.StartingHealth,
        MaxHealth = BATTLE_CONFIG.StartingHealth,
        Energy = BATTLE_CONFIG.StartingEnergy,
        MaxEnergy = BATTLE_CONFIG.MaxEnergy,
        Shield = 0,
        StatusEffects = {},
        IsReady = true,
        LastActionTime = os.time(),
        BattleStats = self:_createEmptyBattleStats()
    }
end

function BattleService:_buildDeckFromCollection(playerData: PlayerTypes.PlayerData): {BattleCard}
    local deck = {}
    local cardDatabase = CardDatabase
    
    -- Use player's current deck or create a basic deck
    local deckCardIDs = playerData.Progression.CurrentDeck
    if #deckCardIDs == 0 then
        -- Create basic deck from owned cards
        deckCardIDs = self:_createBasicDeck(playerData.Collection)
    end
    
    for i, cardID in ipairs(deckCardIDs) do
        if i <= BATTLE_CONFIG.DeckSize then
            local cardData = cardDatabase:GetCard(cardID)
            if cardData then
                table.insert(deck, self:_createBattleCard(cardData))
            end
        end
    end
    
    return deck
end

function BattleService:_buildAIDeck(aiOpponent: AIOpponent): {BattleCard}
    local deck = {}
    
    for _, cardData in ipairs(aiOpponent.Deck) do
        table.insert(deck, self:_createBattleCard(cardData))
    end
    
    return deck
end

function BattleService:_createBattleCard(cardData: CardTypes.CardData): BattleCard
    return {
        InstanceID = HttpService:GenerateGUID(false),
        CardData = cardData,
        CurrentHealth = cardData.Health,
        MaxHealth = cardData.Health,
        Attack = cardData.Attack,
        Defense = cardData.Defense,
        Energy = cardData.Cost,
        StatusEffects = {},
        Position = "Deck",
        CanAttack = false,
        TurnsOnField = 0,
        DamageDealt = 0,
        DamageTaken = 0
    }
end

function BattleService:_startBattle(battle: BattleSession)
    battle.BattleState = "InProgress"
    
    -- Draw initial hands
    self:_drawInitialHands(battle)
    
    -- Start first turn
    self:_startTurn(battle)
    
    -- Broadcast battle start
    self:_broadcastBattleUpdate(battle, {
        Type = "BattleStarted",
        BattleState = battle
    })
    
    self:_log("Battle started: " .. battle.BattleID)
end

function BattleService:_drawInitialHands(battle: BattleSession)
    -- Draw cards for both players
    self:_drawCards(battle.Player1, BATTLE_CONFIG.HandSize)
    self:_drawCards(battle.Player2, BATTLE_CONFIG.HandSize)
end

function BattleService:_drawCards(player: BattlePlayer, count: number)
    for i = 1, count do
        if #player.Deck > 0 then
            local card = table.remove(player.Deck, 1)
            card.Position = "Hand"
            table.insert(player.Hand, card)
        end
    end
end

function BattleService:_startTurn(battle: BattleSession)
    local activePlayer = battle.ActivePlayer == 1 and battle.Player1 or battle.Player2
    
    -- Reset energy
    activePlayer.Energy = math.min(activePlayer.MaxEnergy, activePlayer.Energy + 1)
    
    -- Draw a card
    self:_drawCards(activePlayer, 1)
    
    -- Reset card attack status
    for _, card in ipairs(activePlayer.Hand) do
        if card.Position == "Active" then
            card.CanAttack = true
        end
    end
    
    -- Update turn timer
    self._turnTimers[battle.BattleID] = os.time() + BATTLE_CONFIG.DefaultTurnTime
    
    -- Process AI turn if needed
    if activePlayer.UserID == -1 then
        spawn(function()
            wait(math.random(1, 3)) -- AI thinking time
            self:_processAITurn(battle, activePlayer)
        end)
    end
    
    self:_log("Turn " .. battle.CurrentTurn .. " started for player " .. battle.ActivePlayer)
end

function BattleService:_validateAction(battle: BattleSession, player: Player, action: BattleAction): BattleTypes.ActionValidationResult
    -- Check if it's player's turn
    local activePlayer = battle.ActivePlayer == 1 and battle.Player1 or battle.Player2
    if activePlayer.UserID ~= player.UserId then
        return {
            IsValid = false,
            ErrorReason = "Not your turn"
        }
    end
    
    -- Check battle state
    if battle.BattleState ~= "InProgress" then
        return {
            IsValid = false,
            ErrorReason = "Battle not in progress"
        }
    end
    
    -- Validate specific action types
    if action.ActionType == "PlayCard" then
        return self:_validatePlayCardAction(activePlayer, action)
    elseif action.ActionType == "Attack" then
        return self:_validateAttackAction(battle, activePlayer, action)
    elseif action.ActionType == "EndTurn" then
        return { IsValid = true }
    elseif action.ActionType == "Surrender" then
        return { IsValid = true }
    end
    
    return {
        IsValid = false,
        ErrorReason = "Unknown action type"
    }
end

function BattleService:_validatePlayCardAction(player: BattlePlayer, action: BattleAction): BattleTypes.ActionValidationResult
    local cardID = action.ActionData.SourceCardID
    if not cardID then
        return {
            IsValid = false,
            ErrorReason = "No card specified"
        }
    end
    
    -- Find card in hand
    local card = nil
    for _, handCard in ipairs(player.Hand) do
        if handCard.InstanceID == cardID then
            card = handCard
            break
        end
    end
    
    if not card then
        return {
            IsValid = false,
            ErrorReason = "Card not in hand"
        }
    end
    
    -- Check energy cost
    if player.Energy < card.Energy then
        return {
            IsValid = false,
            ErrorReason = "Not enough energy"
        }
    end
    
    return { IsValid = true }
end

function BattleService:_validateAttackAction(battle: BattleSession, attacker: BattlePlayer, action: BattleAction): BattleTypes.ActionValidationResult
    local sourceCardID = action.ActionData.SourceCardID
    local targetCardID = action.ActionData.TargetCardID
    
    if not sourceCardID then
        return {
            IsValid = false,
            ErrorReason = "No attacking card specified"
        }
    end
    
    -- Find attacking card
    local attackingCard = nil
    if attacker.ActiveCard and attacker.ActiveCard.InstanceID == sourceCardID then
        attackingCard = attacker.ActiveCard
    end
    
    if not attackingCard then
        return {
            IsValid = false,
            ErrorReason = "Attacking card not active"
        }
    end
    
    -- Check if card can attack
    if not attackingCard.CanAttack then
        return {
            IsValid = false,
            ErrorReason = "Card cannot attack this turn"
        }
    end
    
    return { IsValid = true }
end

function BattleService:_executeAction(battle: BattleSession, action: BattleAction): boolean
    local activePlayer = battle.ActivePlayer == 1 and battle.Player1 or battle.Player2
    
    if action.ActionType == "PlayCard" then
        return self:_executePlayCard(battle, activePlayer, action)
    elseif action.ActionType == "Attack" then
        return self:_executeAttack(battle, activePlayer, action)
    elseif action.ActionType == "EndTurn" then
        return self:_executeEndTurn(battle)
    elseif action.ActionType == "Surrender" then
        return self:_executeSurrender(battle, activePlayer)
    end
    
    return false
end

function BattleService:_executePlayCard(battle: BattleSession, player: BattlePlayer, action: BattleAction): boolean
    local cardID = action.ActionData.SourceCardID
    
    -- Find and remove card from hand
    local cardIndex = nil
    local card = nil
    for i, handCard in ipairs(player.Hand) do
        if handCard.InstanceID == cardID then
            card = handCard
            cardIndex = i
            break
        end
    end
    
    if not card or not cardIndex then
        return false
    end
    
    -- Remove from hand and pay energy cost
    table.remove(player.Hand, cardIndex)
    player.Energy -= card.Energy
    
    -- Place card in active position
    if player.ActiveCard then
        -- Move current active card to graveyard
        player.ActiveCard.Position = "Graveyard"
    end
    
    card.Position = "Active"
    card.CanAttack = false -- Can't attack on play turn
    player.ActiveCard = card
    
    -- Update stats
    player.BattleStats.CardsPlayed += 1
    
    self:_log("Player " .. player.Username .. " played card: " .. card.CardData.Name)
    return true
end

function BattleService:_executeAttack(battle: BattleSession, attacker: BattlePlayer, action: BattleAction): boolean
    local defender = battle.ActivePlayer == 1 and battle.Player2 or battle.Player1
    local attackingCard = attacker.ActiveCard
    
    if not attackingCard then
        return false
    end
    
    -- Calculate damage
    local damageCalc = self:_calculateDamage(attackingCard, defender.ActiveCard or nil, attacker, defender)
    
    -- Apply damage
    local target = action.ActionData.TargetCardID and defender.ActiveCard or defender
    local actualDamage = self:_applyDamage(target, damageCalc, attacker, defender)
    
    -- Update stats
    attacker.BattleStats.DamageDealt += actualDamage
    if damageCalc.IsCritical then
        attacker.BattleStats.CriticalHits += 1
    end
    
    if target == defender then
        defender.BattleStats.DamageTaken += actualDamage
    end
    
    -- Mark card as unable to attack
    attackingCard.CanAttack = false
    attackingCard.DamageDealt += actualDamage
    
    -- Generate visual effects data
    action.VisualEffects = self:_generateAttackEffects(attackingCard, target, damageCalc)
    
    self:_log("Attack: " .. attackingCard.CardData.Name .. " -> " .. actualDamage .. " damage")
    return true
end

function BattleService:_executeEndTurn(battle: BattleSession): boolean
    -- Switch active player
    battle.ActivePlayer = battle.ActivePlayer == 1 and 2 or 1
    battle.CurrentTurn += 1
    
    -- Start next turn
    self:_startTurn(battle)
    
    return true
end

function BattleService:_executeSurrender(battle: BattleSession, player: BattlePlayer): boolean
    battle.Winner = battle.ActivePlayer == 1 and 2 or 1
    self:EndBattle(battle.BattleID, "Surrender")
    return true
end

function BattleService:_calculateDamage(attackingCard: BattleCard, defendingCard: BattleCard?, attacker: BattlePlayer, defender: BattlePlayer): DamageCalculation
    local baseAttack = attackingCard.Attack
    local baseDamage = baseAttack
    
    -- Apply attack modifiers
    local attackModifiers = {}
    for _, effect in ipairs(attackingCard.StatusEffects) do
        if effect.StatModifiers then
            for _, modifier in ipairs(effect.StatModifiers) do
                if modifier.StatName == "Attack" then
                    table.insert(attackModifiers, {
                        ModifierType = "StatusEffect",
                        Value = modifier.Value,
                        Source = effect.EffectType,
                        Duration = effect.Duration
                    })
                end
            end
        end
    end
    
    -- Apply defense modifiers
    local defenseModifiers = {}
    local targetDefense = 0
    
    if defendingCard then
        targetDefense = defendingCard.Defense
        -- Add defending card's defense modifiers
    else
        targetDefense = defender.Shield
    end
    
    -- Calculate final damage
    local modifiedAttack = baseDamage
    for _, modifier in ipairs(attackModifiers) do
        if modifier.ModifierType == "StatusEffect" then
            modifiedAttack += modifier.Value
        end
    end
    
    local finalDamage = math.max(1, modifiedAttack - targetDefense)
    
    -- Check for critical hit
    local isCritical = math.random() < BATTLE_CONFIG.CriticalChance
    local criticalMultiplier = 1.0
    
    if isCritical then
        criticalMultiplier = BATTLE_CONFIG.CriticalMultiplier
        finalDamage = math.floor(finalDamage * criticalMultiplier)
    end
    
    return {
        BaseAttack = baseAttack,
        BaseDamage = baseDamage,
        AttackModifiers = attackModifiers,
        DefenseModifiers = defenseModifiers,
        FinalDamage = finalDamage,
        IsCritical = isCritical,
        CriticalMultiplier = criticalMultiplier,
        DamageType = "Physical",
        Penetration = 0,
        MitigatedDamage = math.max(0, modifiedAttack - finalDamage)
    }
end

function BattleService:_applyDamage(target: any, damageCalc: DamageCalculation, attacker: BattlePlayer, defender: BattlePlayer): number
    local damage = damageCalc.FinalDamage
    
    if target == defender then
        -- Damage to player
        defender.Health = math.max(0, defender.Health - damage)
    else
        -- Damage to card
        local card = target :: BattleCard
        card.CurrentHealth = math.max(0, card.CurrentHealth - damage)
        card.DamageTaken += damage
        
        -- Check if card is destroyed
        if card.CurrentHealth <= 0 then
            self:_destroyCard(defender, card)
        end
    end
    
    return damage
end

function BattleService:_destroyCard(player: BattlePlayer, card: BattleCard)
    if player.ActiveCard == card then
        player.ActiveCard = nil
    end
    
    card.Position = "Graveyard"
    self:_log("Card destroyed: " .. card.CardData.Name)
end

function BattleService:_generateAttackEffects(attackingCard: BattleCard, target: any, damageCalc: DamageCalculation): {BattleTypes.VisualActionEffect}
    local effects = {}
    
    -- Base attack effect
    table.insert(effects, {
        EffectType = "Attack",
        SourcePosition = Vector2.new(0, 0), -- Will be set by client
        TargetPosition = Vector2.new(0, 0), -- Will be set by client
        Duration = 0.8,
        Intensity = damageCalc.IsCritical and 1.0 or 0.6,
        Properties = {
            ImpactFrames = BATTLE_CONFIG.ImpactFrameDuration,
            ScreenShake = damageCalc.IsCritical and 0.5 or 0.2,
            CriticalHit = damageCalc.IsCritical,
            Damage = damageCalc.FinalDamage
        }
    })
    
    return effects
end

function BattleService:_checkBattleEndConditions(battle: BattleSession)
    -- Check for player defeat
    if battle.Player1.Health <= 0 then
        battle.Winner = 2
        self:EndBattle(battle.BattleID, "Player1Defeated")
    elseif battle.Player2.Health <= 0 then
        battle.Winner = 1
        self:EndBattle(battle.BattleID, "Player2Defeated")
    end
    
    -- Check for turn limit
    if battle.CurrentTurn > 50 then -- Max turns
        battle.Winner = battle.Player1.Health > battle.Player2.Health and 1 or 2
        self:EndBattle(battle.BattleID, "TurnLimit")
    end
end

function BattleService:_processAITurn(battle: BattleSession, aiPlayer: BattlePlayer)
    local aiOpponent = self._aiOpponents["Medium"] -- Default AI
    local actions = self:_generateAIActions(battle, aiPlayer, aiOpponent)
    
    for _, action in ipairs(actions) do
        wait(0.5) -- Delay between AI actions
        
        if battle.BattleState == "InProgress" then
            action.PlayerID = aiPlayer.UserID
            action.Timestamp = os.time()
            action.IsValid = true
            
            self:_executeAction(battle, action)
            
            -- Broadcast AI action
            self:_broadcastBattleUpdate(battle, {
                Type = "ActionExecuted",
                Action = action,
                BattleState = battle
            })
        end
    end
    
    -- End AI turn
    if battle.BattleState == "InProgress" then
        local endTurnAction = {
            ActionID = HttpService:GenerateGUID(false),
            PlayerID = aiPlayer.UserID,
            ActionType = "EndTurn",
            ActionData = {},
            Timestamp = os.time(),
            IsValid = true
        }
        
        self:_executeAction(battle, endTurnAction)
    end
end

function BattleService:_generateAIActions(battle: BattleSession, aiPlayer: BattlePlayer, aiOpponent: AIOpponent): {BattleAction}
    local actions = {}
    
    -- Simple AI logic: play a card if possible, then attack if possible
    if #aiPlayer.Hand > 0 and aiPlayer.Energy >= aiPlayer.Hand[1].Energy then
        -- Play first affordable card
        table.insert(actions, {
            ActionID = HttpService:GenerateGUID(false),
            PlayerID = aiPlayer.UserID,
            ActionType = "PlayCard",
            ActionData = {
                SourceCardID = aiPlayer.Hand[1].InstanceID
            },
            Timestamp = os.time(),
            IsValid = true
        })
    end
    
    -- Attack if we have an active card
    if aiPlayer.ActiveCard and aiPlayer.ActiveCard.CanAttack then
        table.insert(actions, {
            ActionID = HttpService:GenerateGUID(false),
            PlayerID = aiPlayer.UserID,
            ActionType = "Attack",
            ActionData = {
                SourceCardID = aiPlayer.ActiveCard.InstanceID
            },
            Timestamp = os.time(),
            IsValid = true
        })
    end
    
    return actions
end

function BattleService:_calculateBattleResult(battle: BattleSession): BattleTypes.BattleResult
    local duration = os.time() - battle.BattleStartTime
    
    return {
        BattleID = battle.BattleID,
        Winner = battle.Winner,
        Loser = battle.Winner and (battle.Winner == 1 and 2 or 1) or nil,
        BattleDuration = duration,
        TotalTurns = battle.CurrentTurn,
        Player1Stats = battle.Player1.BattleStats,
        Player2Stats = battle.Player2.BattleStats,
        ExperienceGained = {
            [battle.Player1.UserID] = battle.Winner == 1 and 100 or 50,
            [battle.Player2.UserID] = battle.Player2.UserID > 0 and (battle.Winner == 2 and 100 or 50) or 0
        },
        RewardsEarned = {
            [battle.Player1.UserID] = {
                Coins = battle.Winner == 1 and 200 or 50,
                Experience = battle.Winner == 1 and 100 or 50
            },
            [battle.Player2.UserID] = battle.Player2.UserID > 0 and {
                Coins = battle.Winner == 2 and 200 or 50,
                Experience = battle.Winner == 2 and 100 or 50
            } or nil
        }
    }
end

function BattleService:_updatePlayerBattleStats(battle: BattleSession, result: BattleTypes.BattleResult)
    local playerDataService = self.ServiceRegistry:GetService("PlayerDataService")
    
    -- Update Player 1
    if battle.Player1.UserID > 0 then
        local player1 = Players:GetPlayerByUserId(battle.Player1.UserID)
        if player1 then
            local statsUpdate = {
                BattlesWon = result.Winner == 1 and 1 or 0,
                BattlesLost = result.Winner ~= 1 and 1 or 0,
                TotalDamageDealt = battle.Player1.BattleStats.DamageDealt,
                TotalDamageReceived = battle.Player1.BattleStats.DamageTaken
            }
            
            playerDataService:UpdatePlayerStats(player1, statsUpdate)
            
            local rewards = result.RewardsEarned[battle.Player1.UserID]
            if rewards then
                playerDataService:UpdatePlayerEconomy(player1, "Coins", rewards.Coins)
                playerDataService:AddExperience(player1, rewards.Experience)
            end
        end
    end
    
    -- Update Player 2 (if not AI)
    if battle.Player2.UserID > 0 then
        local player2 = Players:GetPlayerByUserId(battle.Player2.UserID)
        if player2 then
            local statsUpdate = {
                BattlesWon = result.Winner == 2 and 1 or 0,
                BattlesLost = result.Winner ~= 2 and 1 or 0,
                TotalDamageDealt = battle.Player2.BattleStats.DamageDealt,
                TotalDamageReceived = battle.Player2.BattleStats.DamageTaken
            }
            
            playerDataService:UpdatePlayerStats(player2, statsUpdate)
            
            local rewards = result.RewardsEarned[battle.Player2.UserID]
            if rewards then
                playerDataService:UpdatePlayerEconomy(player2, "Coins", rewards.Coins)
                playerDataService:AddExperience(player2, rewards.Experience)
            end
        end
    end
end

function BattleService:_broadcastBattleUpdate(battle: BattleSession, updateData: any)
    -- Broadcast to Player 1
    if battle.Player1.UserID > 0 then
        local player1 = Players:GetPlayerByUserId(battle.Player1.UserID)
        if player1 then
            RemoteEventHandler:FireClient("BattleUpdate", player1, updateData)
        end
    end
    
    -- Broadcast to Player 2 (if not AI)
    if battle.Player2.UserID > 0 then
        local player2 = Players:GetPlayerByUserId(battle.Player2.UserID)
        if player2 then
            RemoteEventHandler:FireClient("BattleUpdate", player2, updateData)
        end
    end
    
    -- Broadcast to spectators
    for _, spectatorID in ipairs(battle.Spectators) do
        local spectator = Players:GetPlayerByUserId(spectatorID)
        if spectator then
            RemoteEventHandler:FireClient("BattleUpdate", spectator, updateData)
        end
    end
end

function BattleService:_processBattleUpdates()
    local currentTime = os.time()
    
    -- Process turn timers
    for battleID, timeLimit in pairs(self._turnTimers) do
        if currentTime >= timeLimit then
            local battle = self._activeBattles[battleID]
            if battle and battle.BattleState == "InProgress" then
                -- Force end turn
                self:_executeEndTurn(battle)
                self._turnTimers[battleID] = nil
            end
        end
    end
    
    -- Update battle statistics
    self._activePlayerCount = 0
    for _, battle in pairs(self._activeBattles) do
        if battle.Player1.UserID > 0 then
            self._activePlayerCount += 1
        end
        if battle.Player2.UserID > 0 then
            self._activePlayerCount += 1
        end
    end
end

function BattleService:_setupRemoteHandlers()
    -- Create remote events that this service will use
    RemoteEventHandler:GetRemoteEvent("BattleUpdate")
    
    -- Setup remote function handlers
    RemoteEventHandler:BindRemoteFunction("StartBattle", function(player, request: BattleTypes.StartBattleRequest)
        return self:StartBattle(player, request)
    end)
    
    RemoteEventHandler:BindRemoteFunction("GetBattleState", function(player)
        return self:GetBattleState(player)
    end)
    
    -- Setup remote event handlers
    RemoteEventHandler:ConnectRemoteEvent("BattleAction", function(player, actionData)
        local action: BattleAction = {
            ActionID = HttpService:GenerateGUID(false),
            PlayerID = player.UserId,
            ActionType = actionData.ActionType,
            ActionData = actionData.ActionData or {},
            Timestamp = os.time(),
            IsValid = false
        }
        
        self:ProcessAction(player, action)
    end)
end

function BattleService:_initializeAIOpponents()
    for difficulty, personality in pairs(AI_PERSONALITIES) do
        local cardDatabase = CardDatabase
        local aiDeck = {}
        
        -- Create AI deck with basic cards
        local basicCards = cardDatabase:GetCardsByRarity("Common")
        for i = 1, BATTLE_CONFIG.DeckSize do
            if basicCards[i] then
                table.insert(aiDeck, basicCards[i])
            end
        end
        
        self._aiOpponents[difficulty] = {
            AIID = "ai_" .. string.lower(difficulty),
            Name = "AI " .. difficulty,
            Difficulty = difficulty,
            Deck = aiDeck,
            Personality = personality,
            BehaviorSettings = {
                ThinkingTime = personality.Patience * 3 + 1,
                RandomnessFactor = 1 - personality.Adaptability,
                PredictiveDepth = math.floor(personality.Adaptability * 3) + 1,
                FavoriteStrategies = {"aggressive", "defensive"},
                CounterStrategies = {"adaptive"}
            }
        }
    end
    
    self:_log("AI opponents initialized: " .. TableUtils.getSize(self._aiOpponents))
end

function BattleService:_startMatchmakingProcessor()
    spawn(function()
        while true do
            wait(1)
            -- Process matchmaking queue
            if #self._battleQueue > 1 then
                local player1Request = table.remove(self._battleQueue, 1)
                local player2Request = table.remove(self._battleQueue, 1)
                
                local player1 = Players:GetPlayerByUserId(player1Request.PlayerID)
                local player2 = Players:GetPlayerByUserId(player2Request.PlayerID)
                
                if player1 and player2 then
                    self:CreateBattle(player1, player2, "Ranked")
                end
            end
        end
    end)
end

function BattleService:_createBasicDeck(collection: PlayerTypes.CardCollection): {string}
    local deckCards = {}
    
    -- Use owned cards or fallback to basic cards
    for cardID, count in pairs(collection.CardCounts) do
        if count > 0 and #deckCards < BATTLE_CONFIG.DeckSize then
            table.insert(deckCards, cardID)
        end
    end
    
    -- Fill with basic cards if needed
    while #deckCards < BATTLE_CONFIG.DeckSize do
        table.insert(deckCards, "naruto_001") -- Default card
    end
    
    return deckCards
end

function BattleService:_createEmptyBattleStats(): BattleTypes.PlayerBattleStats
    return {
        DamageDealt = 0,
        DamageTaken = 0,
        CardsPlayed = 0,
        SpecialAbilitiesUsed = 0,
        CriticalHits = 0,
        StatusEffectsApplied = 0,
        TurnsPlayed = 0,
        LongestCombo = 0,
        HighestSingleDamage = 0,
        CardsDestroyed = 0
    }
end

function BattleService:_getDefaultBattleSettings(): BattleTypes.BattleSettings
    return {
        TurnTimeLimit = BATTLE_CONFIG.DefaultTurnTime,
        MaxTurns = 50,
        StartingHealth = BATTLE_CONFIG.StartingHealth,
        StartingEnergy = BATTLE_CONFIG.StartingEnergy,
        DeckSize = BATTLE_CONFIG.DeckSize,
        HandSize = BATTLE_CONFIG.HandSize,
        AllowSpectators = false,
        RankedMatch = false
    }
end

function BattleService:_generateBattleID(): string
    return "battle_" .. tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
end

return BattleService.new() 
--- FILE: ./src/server/Services/AudioService.luau ---
--!strict
-- AudioService.luau
-- Centralized audio management with psychological design and frequency layering
-- Provides timing precision, spatial audio, and performance optimization

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")

local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local AudioTypes = require(ReplicatedStorage.Shared.Types.AudioTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type AudioSystemState = AudioTypes.AudioSystemState
type AudioServiceConfig = AudioTypes.AudioServiceConfig
type AudioContext = AudioTypes.AudioContext
type AudioCue = AudioTypes.AudioCue
type AudioSequence = AudioTypes.AudioSequence
type FrequencyLayerConfig = AudioTypes.FrequencyLayerConfig
type PsychologicalAudioConfig = AudioTypes.PsychologicalAudioConfig
type SpatialAudioConfig = AudioTypes.SpatialAudioConfig
type AudioAnalytics = AudioTypes.AudioAnalytics

local AudioService = {}
AudioService.__index = AudioService
setmetatable(AudioService, {__index = BaseService})

function AudioService.new()
	local self = BaseService.new("AudioService", {})
	setmetatable(self, AudioService)
	
	-- Core State
	self._systemState = {
		IsInitialized = false,
		CurrentContext = self:_createDefaultContext(),
		ActiveAudioSources = {},
		ActiveSequences = {},
		FrequencyConfig = self:_createDefaultFrequencyConfig(),
		SpatialConfig = self:_createDefaultSpatialConfig(),
		PerformanceConfig = self:_createDefaultPerformanceConfig(),
		Analytics = self:_createDefaultAnalytics(),
		MasterVolume = GameConstants.Audio.MasterVolume,
		SFXVolume = GameConstants.Audio.SFXVolume,
		MusicVolume = GameConstants.Audio.MusicVolume,
		VoiceVolume = 0.8,
		IsAudioEnabled = true,
		IsMuted = false,
		LastUpdateTime = 0
	} :: AudioSystemState
	
	-- Configuration
	self._config = {
		EnablePsychologicalDesign = true,
		EnableFrequencyLayering = true,
		EnableSpatialAudio = true,
		EnableAnalytics = true,
		MobileOptimizationLevel = 2,
		DebugMode = false
	} :: AudioServiceConfig
	
	-- Audio Management
	self._soundGroups = {} :: {[string]: SoundGroup}
	self._activeSounds = {} :: {[string]: Sound}
	self._audioQueue = {} :: {AudioCue}
	self._psychologicalTimers = {} :: {[string]: any}
	self._frequencyMixers = {} :: {[string]: any}
	
	-- Performance Tracking
	self._performanceMetrics = {
		ConcurrentSounds = 0,
		ConcurrentLayers = 0,
		CPUUsage = 0,
		MemoryUsage = 0,
		LatencyMS = 0
	}
	
	-- Events (using individual GetRemoteEvent calls)
	self._events = {
		AudioCueRequested = RemoteEventHandler:GetRemoteEvent("AudioCueRequested"),
		AudioSequenceRequested = RemoteEventHandler:GetRemoteEvent("AudioSequenceRequested"),
		AudioContextChanged = RemoteEventHandler:GetRemoteEvent("AudioContextChanged"),
		AudioSettingsChanged = RemoteEventHandler:GetRemoteEvent("AudioSettingsChanged"),
		PsychologicalEventTriggered = RemoteEventHandler:GetRemoteEvent("PsychologicalEventTriggered"),
		SpatialAudioUpdate = RemoteEventHandler:GetRemoteEvent("SpatialAudioUpdate")
	}
	
	return self
end

function AudioService:Initialize()
	self:_log("AudioService initializing...")
	
	-- Initialize SoundService settings
	self:_initializeSoundService()
	
	-- Create sound groups for frequency layering
	self:_createSoundGroups()
	
	-- Initialize frequency layer configuration
	self:_initializeFrequencyLayers()
	
	-- Setup psychological audio profiles
	self:_initializePsychologicalProfiles()
	
	-- Initialize spatial audio
	if self._config.EnableSpatialAudio then
		self:_initializeSpatialAudio()
	end
	
	-- Setup performance monitoring
	self:_initializePerformanceMonitoring()
	
	-- Setup remote event handlers
	self:_setupRemoteEventHandlers()
	
	self._systemState.IsInitialized = true
	self:_log("AudioService initialized successfully")
end

function AudioService:Start()
	self:_log("AudioService starting...")
	
	-- Start audio update loop
	self:_startAudioUpdateLoop()
	
	-- Start psychological timing system
	if self._config.EnablePsychologicalDesign then
		self:_startPsychologicalTimingSystem()
	end
	
	-- Start analytics collection
	if self._config.EnableAnalytics then
		self:_startAnalyticsCollection()
	end
	
	self:_log("AudioService started successfully")
end

function AudioService:Stop()
	self:_log("AudioService stopping...")
	
	-- Stop all active audio
	self:StopAllAudio()
	
	-- Cleanup timers
	for timerName, timer in pairs(self._psychologicalTimers) do
		if timer then
			timer:Disconnect()
		end
	end
	self._psychologicalTimers = {}
	
	-- Cleanup performance monitoring
	if self._performanceConnection then
		self._performanceConnection:Disconnect()
		self._performanceConnection = nil
	end
	
	BaseService.Stop(self)
	self:_log("AudioService stopped")
end

-- Public API

-- Play a single audio cue with psychological timing
function AudioService:PlayAudioCue(cueID: string, config: PsychologicalAudioConfig?): string
	if not self._systemState.IsInitialized or not self._systemState.IsAudioEnabled then
		return ""
	end
	
	-- Get or create audio cue
	local audioCue = self:_getAudioCue(cueID)
	if not audioCue then
		self:_logError("Audio cue not found: " .. cueID)
		return ""
	end
	
	-- Apply psychological configuration
	if config then
		audioCue = self:_applyPsychologicalConfig(audioCue, config)
	end
	
	-- Create unique instance ID
	local instanceID = self:_generateInstanceID(cueID)
	
	-- Apply frequency layering
	if self._config.EnableFrequencyLayering then
		self:_applyFrequencyLayering(audioCue, instanceID)
	end
	
	-- Apply spatial audio if configured
	if self._config.EnableSpatialAudio and config and config.SpatialEffects then
		self:_applySpatialAudio(audioCue, instanceID)
	end
	
	-- Play with timing precision
	self:_playAudioCueWithPrecision(audioCue, instanceID)
	
	-- Update analytics
	if self._config.EnableAnalytics then
		self:_recordAudioEvent("CueStarted", cueID, instanceID)
	end
	
	-- Fire event to clients
	self._events.AudioCueRequested:FireAllClients(cueID, instanceID, audioCue)
	
	return instanceID
end

-- Play an audio sequence with crossfading
function AudioService:PlayAudioSequence(sequenceID: string, config: PsychologicalAudioConfig?): string
	if not self._systemState.IsInitialized or not self._systemState.IsAudioEnabled then
		return ""
	end
	
	local sequence = self:_getAudioSequence(sequenceID)
	if not sequence then
		self:_logError("Audio sequence not found: " .. sequenceID)
		return ""
	end
	
	local instanceID = self:_generateInstanceID(sequenceID)
	
	-- Schedule sequence with psychological timing
	self:_scheduleAudioSequence(sequence, instanceID, config)
	
	-- Update system state
	self._systemState.ActiveSequences[instanceID] = sequence
	
	-- Fire event to clients
	self._events.AudioSequenceRequested:FireAllClients(sequenceID, instanceID, sequence)
	
	return instanceID
end

-- Update audio context for psychological adaptation
function AudioService:UpdateAudioContext(context: AudioContext)
	self._systemState.CurrentContext = context
	
	-- Adapt frequency layers based on context
	self:_adaptFrequencyLayers(context)
	
	-- Adjust psychological timing
	self:_adjustPsychologicalTiming(context)
	
	-- Update spatial environment
	if self._config.EnableSpatialAudio then
		self:_updateSpatialEnvironment(context)
	end
	
	-- Fire event to clients
	self._events.AudioContextChanged:FireAllClients(context)
	
	self:_log("Audio context updated: " .. context.CurrentScene)
end

-- Control frequency layer emphasis for psychological effect
function AudioService:SetFrequencyLayerEmphasis(layerName: string, emphasis: number)
	if not self._systemState.FrequencyConfig[layerName] then
		self:_logError("Unknown frequency layer: " .. layerName)
		return
	end
	
	-- Update layer configuration
	local layer = self._systemState.FrequencyConfig[layerName]
	layer.IntensityMultiplier = emphasis
	
	-- Apply changes to active sounds
	self:_updateActiveFrequencyLayers()
	
	-- Update analytics
	if self._config.EnableAnalytics then
		self:_recordFrequencyChange(layerName, emphasis)
	end
	
	self:_log("Frequency layer emphasis updated: " .. layerName .. " = " .. emphasis)
end

-- Trigger psychological audio event
function AudioService:TriggerPsychologicalEvent(eventType: string, intensity: number, duration: number?)
	if not self._config.EnablePsychologicalDesign then
		return
	end
	
	-- Create psychological audio response
	local audioResponse = self:_createPsychologicalResponse(eventType, intensity)
	
	-- Apply timing and frequency changes
	self:_applyPsychologicalResponse(audioResponse, duration or 1.0)
	
	-- Fire event to clients
	self._events.PsychologicalEventTriggered:FireAllClients(eventType, intensity)
	
	-- Update analytics
	if self._config.EnableAnalytics then
		self:_recordPsychologicalEvent(eventType, intensity)
	end
	
	self:_log("Psychological event triggered: " .. eventType .. " (intensity: " .. intensity .. ")")
end

-- Stop specific audio instance
function AudioService:StopAudio(instanceID: string)
	if self._activeSounds[instanceID] then
		self._activeSounds[instanceID]:Stop()
		self._activeSounds[instanceID] = nil
		self._performanceMetrics.ConcurrentSounds = math.max(0, self._performanceMetrics.ConcurrentSounds - 1)
	end
	
	if self._systemState.ActiveSequences[instanceID] then
		self._systemState.ActiveSequences[instanceID] = nil
	end
end

-- Stop all audio
function AudioService:StopAllAudio()
	for instanceID, sound in pairs(self._activeSounds) do
		sound:Stop()
	end
	self._activeSounds = {}
	self._systemState.ActiveSequences = {}
	self._performanceMetrics.ConcurrentSounds = 0
	self._performanceMetrics.ConcurrentLayers = 0
	
	self:_log("All audio stopped")
end

-- Get current audio system state (for debugging)
function AudioService:GetSystemState(): AudioSystemState
	return self._systemState
end

-- Get performance metrics
function AudioService:GetPerformanceMetrics()
	return self._performanceMetrics
end

-- Private Methods

function AudioService:_initializeSoundService()
	-- Configure SoundService for optimal performance
	SoundService.AmbientReverb = Enum.ReverbType.NoReverb
	SoundService.DistanceFactor = 3.33
	SoundService.DopplerScale = 1
	SoundService.RolloffScale = 1
end

function AudioService:_createSoundGroups()
	-- Create sound groups for frequency layering
	local frequencyGroups = {"SubBass", "MidBass", "LowMid", "Midrange", "UpperMid", "Presence", "Brilliance"}
	
	for _, groupName in ipairs(frequencyGroups) do
		local soundGroup = Instance.new("SoundGroup")
		soundGroup.Name = groupName
		soundGroup.Parent = SoundService
		soundGroup.Volume = 1.0
		self._soundGroups[groupName] = soundGroup
	end
	
	-- Create category groups
	local categoryGroups = {"SFX", "Music", "Voice", "Ambient"}
	
	for _, groupName in ipairs(categoryGroups) do
		local soundGroup = Instance.new("SoundGroup")
		soundGroup.Name = groupName
		soundGroup.Parent = SoundService
		soundGroup.Volume = 1.0
		self._soundGroups[groupName] = soundGroup
	end
end

function AudioService:_createDefaultContext(): AudioContext
	return {
		CurrentScene = "Menu",
		PlayerState = "Idle",
		TensionLevel = 0.0,
		ExcitementLevel = 0.0,
		RecentActions = {},
		SessionLength = 0,
		LastMajorEvent = "SessionStart",
		NextExpectedEvent = "CardRoll"
	}
end

function AudioService:_createDefaultFrequencyConfig(): FrequencyLayerConfig
	return {
		SubBass = {
			Name = "SubBass",
			FrequencyRange = {Low = 20, High = 60},
			Purpose = "impact",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "tension",
			Priority = 3
		},
		MidBass = {
			Name = "MidBass", 
			FrequencyRange = {Low = 60, High = 250},
			Purpose = "weight",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "satisfaction",
			Priority = 2
		},
		LowMid = {
			Name = "LowMid",
			FrequencyRange = {Low = 250, High = 500},
			Purpose = "fullness",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "calm",
			Priority = 4
		},
		Midrange = {
			Name = "Midrange",
			FrequencyRange = {Low = 500, High = 1000},
			Purpose = "presence",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "excitement",
			Priority = 1
		},
		UpperMid = {
			Name = "UpperMid",
			FrequencyRange = {Low = 1000, High = 4000},
			Purpose = "clarity",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "excitement",
			Priority = 1
		},
		Presence = {
			Name = "Presence",
			FrequencyRange = {Low = 4000, High = 8000},
			Purpose = "sparkle",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "excitement",
			Priority = 2
		},
		Brilliance = {
			Name = "Brilliance",
			FrequencyRange = {Low = 8000, High = 16000},
			Purpose = "magic",
			IntensityMultiplier = 1.0,
			PsychologicalEffect = "excitement",
			Priority = 3
		},
		ActiveLayers = {"Midrange", "UpperMid", "Presence"},
		MobileOptimization = true
	}
end

function AudioService:_createDefaultSpatialConfig(): SpatialAudioConfig
	return {
		IsEnabled = true,
		ListenerPosition = Vector3.new(0, 0, 0),
		ListenerOrientation = Vector3.new(0, 0, -1),
		RoomSize = "medium",
		ReverbAmount = 0.3,
		DopplerEffect = false,
		DistanceAttenuation = 0.5,
		MaxAudibleDistance = 500
	}
end

function AudioService:_createDefaultPerformanceConfig()
	return {
		MaxConcurrentSounds = 32,
		MaxConcurrentLayers = 7,
		MobileOptimizationLevel = 2,
		AudioCompressionLevel = 0.6,
		SampleRateOptimization = true,
		BitrateLimit = 128,
		CPUUsageLimit = 15,
		MemoryUsageLimit = 32
	}
end

function AudioService:_createDefaultAnalytics(): AudioAnalytics
	return {
		PlaybackEvents = {},
		PsychologicalResponse = {
			TensionCurve = {},
			SatisfactionSpikes = {},
			EngagementLevel = 0.5,
			AudioDropoffs = {}
		},
		PerformanceMetrics = {
			CPUUsage = 0,
			MemoryUsage = 0,
			LatencyMS = 0,
			DroppedFrames = 0
		},
		PlayerPreferences = {
			PreferredVolumeLevels = {},
			DisabledCategories = {},
			SpatialAudioUsage = true,
			QualityPreference = "Medium"
		}
	}
end

function AudioService:_initializeFrequencyLayers()
	-- Setup frequency layer processing
	for layerName, layer in pairs(self._systemState.FrequencyConfig) do
		if type(layer) == "table" and layer.Name then
			-- Initialize frequency layer processing
			self:_setupFrequencyLayerProcessor(layer)
		end
	end
end

function AudioService:_initializePsychologicalProfiles()
	-- Create psychological audio profiles for different rarities
	local psychProfiles = {
		Common = {
			RarityLevel = "Common",
			DopamineProfile = {
				BuildupCurve = "linear",
				PeakIntensity = 0.3,
				SustainDuration = 0.5,
				ReleaseCurve = "exponential",
				NextEventPrep = 0.2
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.1,
				ImpactTiming = 0.05,
				ResolutionFade = 0.3,
				NextCuePrep = 0.1
			},
			FrequencyEmphasis = {Midrange = 1.0, UpperMid = 0.8},
			SpatialEffects = false,
			CompressionLevel = 0.7
		},
		Legendary = {
			RarityLevel = "Legendary",
			DopamineProfile = {
				BuildupCurve = "exponential",
				PeakIntensity = 0.9,
				SustainDuration = 2.0,
				ReleaseCurve = "logarithmic",
				NextEventPrep = 1.0
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.5,
				ImpactTiming = 0.2,
				ResolutionFade = 1.5,
				NextCuePrep = 0.5
			},
			FrequencyEmphasis = {SubBass = 1.2, MidBass = 1.1, Presence = 1.3, Brilliance = 1.4},
			SpatialEffects = true,
			CompressionLevel = 0.3
		}
	}
	
	self._psychologicalProfiles = psychProfiles
end

function AudioService:_setupRemoteEventHandlers()
	-- Handle client audio requests
	self._events.AudioCueRequested.OnServerEvent:Connect(function(player: Player, cueID: string, config: any)
		-- Validate request
		if typeof(cueID) ~= "string" then return end
		
		-- Play audio cue
		local instanceID = self:PlayAudioCue(cueID, config)
		
		-- Send confirmation back to client
		self._events.AudioCueRequested:FireClient(player, cueID, instanceID)
	end)
	
	self._events.AudioSettingsChanged.OnServerEvent:Connect(function(player: Player, settings: any)
		-- Update player-specific audio settings
		self:_updatePlayerAudioSettings(player, settings)
	end)
end

function AudioService:_startAudioUpdateLoop()
	self._updateConnection = RunService.Heartbeat:Connect(function(deltaTime)
		self:_updateAudioSystem(deltaTime)
	end)
end

function AudioService:_updateAudioSystem(deltaTime: number)
	-- Update timing precision
	self._systemState.LastUpdateTime = tick()
	
	-- Update performance metrics
	self:_updatePerformanceMetrics()
	
	-- Process audio queue
	self:_processAudioQueue()
	
	-- Update psychological timing
	if self._config.EnablePsychologicalDesign then
		self:_updatePsychologicalTiming(deltaTime)
	end
	
	-- Update spatial audio
	if self._config.EnableSpatialAudio then
		self:_updateSpatialAudio(deltaTime)
	end
	
	-- Performance optimization
	if self._performanceMetrics.ConcurrentSounds > self._systemState.PerformanceConfig.MaxConcurrentSounds then
		self:_optimizeAudioPerformance()
	end
end

function AudioService:_generateInstanceID(baseID: string): string
	return baseID .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
end

function AudioService:_getAudioCue(cueID: string): AudioCue?
	-- This would connect to your audio asset system
	-- For now, return a basic structure
	return {
		ID = cueID,
		Name = cueID,
		SoundId = "rbxasset://sounds/" .. cueID .. ".mp3",
		Volume = 0.5,
		Pitch = 1.0,
		Duration = 1.0,
		Layers = {},
		Priority = 1,
		Category = "SFX",
		IsLooping = false,
		FadeInDuration = 0.1,
		FadeOutDuration = 0.1
	}
end

function AudioService:_logError(message: string)
	warn("[AudioService] ERROR: " .. message)
end

-- Placeholder methods for complex functionality
function AudioService:_initializeSpatialAudio() end
function AudioService:_initializePerformanceMonitoring() end
function AudioService:_startPsychologicalTimingSystem() end
function AudioService:_startAnalyticsCollection() end
function AudioService:_applyPsychologicalConfig(cue: AudioCue, config: PsychologicalAudioConfig): AudioCue return cue end
function AudioService:_applyFrequencyLayering(cue: AudioCue, instanceID: string) end
function AudioService:_applySpatialAudio(cue: AudioCue, instanceID: string) end
function AudioService:_playAudioCueWithPrecision(cue: AudioCue, instanceID: string) end
function AudioService:_recordAudioEvent(eventType: string, cueID: string, instanceID: string) end
function AudioService:_getAudioSequence(sequenceID: string): AudioSequence? return nil end
function AudioService:_scheduleAudioSequence(sequence: AudioSequence, instanceID: string, config: PsychologicalAudioConfig?) end
function AudioService:_adaptFrequencyLayers(context: AudioContext) end
function AudioService:_adjustPsychologicalTiming(context: AudioContext) end
function AudioService:_updateSpatialEnvironment(context: AudioContext) end
function AudioService:_updateActiveFrequencyLayers() end
function AudioService:_recordFrequencyChange(layerName: string, emphasis: number) end
function AudioService:_createPsychologicalResponse(eventType: string, intensity: number) return {} end
function AudioService:_applyPsychologicalResponse(response: any, duration: number) end
function AudioService:_recordPsychologicalEvent(eventType: string, intensity: number) end
function AudioService:_setupFrequencyLayerProcessor(layer: any) end
function AudioService:_updatePlayerAudioSettings(player: Player, settings: any) end
function AudioService:_updatePerformanceMetrics() end
function AudioService:_processAudioQueue() end
function AudioService:_updatePsychologicalTiming(deltaTime: number) end
function AudioService:_updateSpatialAudio(deltaTime: number) end
function AudioService:_optimizeAudioPerformance() end

return AudioService.new() 
--- FILE: ./src/server/Services/CardTestService.luau ---
--!strict
-- CardTestService.luau
-- Temporary service to test card database functionality
-- Displays card statistics and validates the system

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local BaseService = require(ReplicatedStorage.Shared.Core.BaseService)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local CardDatabase = require(ReplicatedStorage.Shared.Data.CardDatabase)

local CardTestService = {}
CardTestService.__index = CardTestService
setmetatable(CardTestService, {__index = BaseService})

function CardTestService.new()
	local self = BaseService.new("CardTestService", {})
	setmetatable(self, CardTestService)
	return self
end

function CardTestService:Initialize()
	self:_log("CardTestService initializing...")
	
	-- Test basic card lookup
	self:TestCardLookup()
	
	-- Test rarity distribution
	self:TestRarityDistribution()
	
	-- Test random card selection
	self:TestRandomCardSelection()
	
	-- Test pity system
	self:TestPitySystem()
	
	-- Display database statistics
	self:DisplayDatabaseStats()
end

function CardTestService:Start()
	self:_log("CardTestService started successfully!")
end

function CardTestService:TestCardLookup()
	self:_log("🔍 Testing card lookup...")
	
	-- Test getting specific cards
	local naruto = CardDatabase:GetCard("naruto_001")
	if naruto then
		self:_log("✅ Found Naruto card:", naruto.Name .. " (" .. naruto.Rarity .. ")")
	else
		self:_warn("❌ Failed to find Naruto card")
	end
	
	local goku = CardDatabase:GetCard("goku_002")
	if goku then
		self:_log("✅ Found Ultra Instinct Goku:", goku.Name .. " (" .. goku.Rarity .. ")")
	else
		self:_warn("❌ Failed to find Ultra Instinct Goku card")
	end
	
	-- Test invalid card
	local invalid = CardDatabase:GetCard("invalid_card")
	if not invalid then
		self:_log("✅ Correctly returned nil for invalid card")
	else
		self:_warn("❌ Should have returned nil for invalid card")
	end
end

function CardTestService:TestRarityDistribution()
	self:_log("🎲 Testing rarity distribution...")
	
	-- Get cards by rarity
	local rarities = {"Common", "Uncommon", "Rare", "Epic", "Legendary", "Ultimate"}
	
	for _, rarity in ipairs(rarities) do
		local cards = CardDatabase:GetCardsByRarity(rarity)
		self:_log(string.format("   %s cards: %d", rarity, #cards))
		
		-- Show some examples
		if #cards > 0 then
			for i = 1, math.min(3, #cards) do
				local card = cards[i]
				self:_log(string.format("     - %s (%s)", card.Name, card.Series))
			end
		end
	end
end

function CardTestService:TestRandomCardSelection()
	self:_log("🎰 Testing random card selection...")
	
	-- Test with default rates
	local testRolls = 100
	local results = {}
	
	for i = 1, testRolls do
		-- Get a random rarity based on drop rates first
		local randomRarity = self:_getRandomRarity()
		local card = CardDatabase:GetRandomCard(randomRarity)
		
		if card then
			if not results[card.Rarity] then
				results[card.Rarity] = 0
			end
			results[card.Rarity] = results[card.Rarity] + 1
		end
	end
	
	self:_log(string.format("Results from %d random rolls:", testRolls))
	for rarity, count in pairs(results) do
		local percentage = (count / testRolls) * 100
		local expectedPercentage = GameConstants.Balance.BaseDropRates[rarity] * 100
		self:_log(string.format("   %s: %d (%.1f%%) - Expected: %.1f%%", 
			rarity, count, percentage, expectedPercentage))
	end
end

function CardTestService:_getRandomRarity(): string
	local random = math.random()
	local cumulative = 0
	for rarity, rate in pairs(GameConstants.Balance.BaseDropRates) do
		cumulative = cumulative + rate
		if random <= cumulative then
			return rarity
		end
	end
	return "Common" -- Fallback
end

function CardTestService:TestPitySystem()
	self:_log("🎯 Testing pity system...")
	
	-- Test pity calculations
	local testCases = {
		{level = 1, rare = 0, epic = 0, legendary = 0},
		{level = 10, rare = 25, epic = 10, legendary = 20},
		{level = 20, rare = 50, epic = 60, legendary = 80},
		{level = 50, rare = 30, epic = 80, legendary = 90}
	}
	
	for _, testCase in ipairs(testCases) do
		local weights = CardDatabase:CalculateRarityWeights(
			testCase.level, testCase.rare, testCase.epic, testCase.legendary
		)
		
		self:_log(string.format("Level %d, Rolls since last (R:%d, E:%d, L:%d):", 
			testCase.level, testCase.rare, testCase.epic, testCase.legendary))
		
		for rarity, weight in pairs(weights) do
			self:_log(string.format("   %s: %.4f", rarity, weight))
		end
	end
end

function CardTestService:DisplayDatabaseStats()
	self:_log("📊 Card Database Statistics:")
	
	-- Overall stats
	local stats = CardDatabase:GetCollectionStats()
	self:_log(string.format("Total cards: %d", stats.totalCards))
	
	-- Rarity info
	local rarityInfo = CardDatabase:GetRarityInfo()
	self:_log("Rarity distribution:")
	for rarity, info in pairs(rarityInfo) do
		self:_log(string.format("   %s: %d cards (%.1f%%)", 
			rarity, info.count, info.percentage))
	end
	
	-- Series info
	local seriesInfo = CardDatabase:GetSeriesInfo()
	self:_log("Series distribution:")
	for series, info in pairs(seriesInfo) do
		self:_log(string.format("   %s: %d cards (%.1f%%)", 
			series, info.count, info.percentage))
	end
	
	-- Test search functionality
	local searchResults = CardDatabase:SearchCards("naruto")
	self:_log(string.format("Search results for 'naruto': %d cards", #searchResults))
	
	local gokuResults = CardDatabase:SearchCards("goku")
	self:_log(string.format("Search results for 'goku': %d cards", #gokuResults))
end

-- Test individual card validation
function CardTestService:TestCardValidation()
	self:_log("🔧 Testing card validation...")
	
	-- Get a valid card and test it
	local validCard = CardDatabase:GetCard("naruto_001")
	if validCard then
		local isValid = CardDatabase:ValidateCardData(validCard)
		if isValid then
			self:_log("✅ Valid card passed validation")
		else
			self:_warn("❌ Valid card failed validation")
		end
	end
	
	-- Test invalid card data
	local invalidCard = {
		ID = "", -- Invalid empty ID
		Name = "Test Card",
		Rarity = "InvalidRarity",
		Stats = {Attack = -10} -- Invalid negative attack
	}
	
	local isInvalid = CardDatabase:ValidateCardData(invalidCard)
	if not isInvalid then
		self:_log("✅ Invalid card correctly rejected")
	else
		self:_warn("❌ Invalid card incorrectly accepted")
	end
end

return CardTestService.new() 
--- FILE: ./src/server/init.server.luau ---
--!strict
-- Server initialization
-- Sets up the service registry and loads all server services

-- Core framework
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServiceRegistry = require(ReplicatedStorage.Shared.Core.ServiceRegistry)

-- Services will be loaded here
local services = {}

-- Load Services
local AudioService = require(script.Services.AudioService)
-- local AudioTestService = require(script.Services.AudioTestService)
local BattleService = require(script.Services.BattleService)
-- local BattleTestService = require(script.Services.BattleTestService)
local CardRollService = require(script.Services.CardRollService)
-- local CardRollTestService = require(script.Services.CardRollTestService)
-- local CardTestService = require(script.Services.CardTestService) -- Disabling to prevent server crash
local PlayerDataService = require(script.Services.PlayerDataService)
-- local PlayerDataTestService = require(script.Services.PlayerDataTestService)
local PolishEffectsService = require(script.Services.PolishEffectsService)
-- local PolishEffectsTestService = require(script.Services.PolishEffectsTestService)

-- Load all services from the Services folder
local function loadServices()
	local servicesFolder = script.Services
	if not servicesFolder then
		warn("Services folder not found")
		return
	end
	
	-- Skip test services to prevent crashes
	local testServices = {
		"AudioTestService",
		"BattleTestService", 
		"CardRollTestService",
		"CardTestService",
		"PlayerDataTestService",
		"PolishEffectsTestService",
	}
	
	for _, serviceModule in pairs(servicesFolder:GetChildren()) do
		if serviceModule:IsA("ModuleScript") then
			local serviceName = serviceModule.Name
			
			-- Skip test services
			local isTestService = false
			for _, testService in pairs(testServices) do
				if serviceName == testService then
					isTestService = true
					break
				end
			end
			
			if not isTestService then
				local success, service = pcall(require, serviceModule)
				
				if success then
					services[serviceName] = service
					ServiceRegistry:RegisterService(serviceName, service)
				else
					error("Failed to load service: " .. serviceName .. " - " .. tostring(service))
				end
			end
		end
	end
end

-- Initialize the server
local function initializeServer()
	print("🚀 Starting Anime Card Clash Server...")
	
	-- Load all services
	loadServices()
	
	-- Initialize services
	local success = ServiceRegistry:InitializeAll()
	if not success then
		error("Failed to initialize services")
	end
	
	-- Start services
	success = ServiceRegistry:StartAll()
	if not success then
		error("Failed to start services")
	end
	
	print("✅ Server initialized successfully!")
	
	-- List loaded services
	local serviceNames = {}
	for name in pairs(services) do
		table.insert(serviceNames, name)
	end
	print("📊 Services loaded:", table.concat(serviceNames, ", "))
end

-- Handle server shutdown
game:BindToClose(function()
	print("🛑 Server shutting down...")
	ServiceRegistry:StopAll()
	ServiceRegistry:Cleanup()
	print("✅ Server shutdown complete")
end)

-- Start the server
initializeServer()

-- Export for debugging
_G.ServiceRegistry = ServiceRegistry
_G.Services = services
--- FILE: ./src/shared/Types/CardTypes.luau ---
--!strict
-- CardTypes.luau
-- Type definitions for the card system
-- Incorporates research-based rarity system and visual properties

local GameConstants = require(script.Parent.Parent.Constants.GameConstants)

-- Card rarity enum
export type CardRarity = "Common" | "Uncommon" | "Rare" | "Epic" | "Legendary" | "Ultimate"

-- Card series/anime enum  
export type CardSeries = "Naruto" | "Dragon Ball" | "One Piece" | "Attack on Titan" | "Demon Slayer" | "Jujutsu Kaisen" | "My Hero Academia" | "Death Note" | "Fullmetal Alchemist" | "Hunter x Hunter"

-- Card type categories
export type CardType = "Fighter" | "Mage" | "Support" | "Tank" | "Assassin" | "Healer"

-- Visual effect data for card animations
export type CardVisualEffects = {
	BorderColor: Color3,
	EffectType: string,
	ImpactFrames: number,
	ScreenShakeIntensity: number,
	ParticleCount: number,
	SoundCategory: string,
	SpecialIntro: boolean?
}

-- Card statistics
export type CardStats = {
	Attack: number,
	Defense: number,
	Health: number,
	Speed: number,
	Energy: number, -- Cost to play the card
	Level: number -- Card level for upgrades
}

-- Complete card data structure
export type CardData = {
	-- Basic Info
	ID: string, -- Unique identifier (e.g., "naruto_001")
	Name: string, -- Character name
	Title: string?, -- Optional title (e.g., "The Seventh Hokage")
	Series: CardSeries,
	Rarity: CardRarity,
	Type: CardType,
	
	-- Stats
	Stats: CardStats,
	
	-- Visual Properties
	Image: string, -- Asset ID or path
	BackgroundImage: string?, -- Optional background for rare cards
	VisualEffects: CardVisualEffects,
	
	-- Gameplay
	SpecialAbility: string?, -- Description of special ability
	AbilityDamage: number?, -- Extra damage from ability
	AbilityCooldown: number?, -- Turns until ability can be used again
	
	-- Collection
	CollectionNumber: number, -- Number in series (1, 2, 3...)
	ReleaseDate: string, -- When card was added
	IsLimited: boolean, -- Limited time availability
	
	-- Metadata
	Description: string,
	FlavorText: string?, -- Lore/quote
	Artist: string?, -- Artist credit
	
	-- Technical
	ModelID: string?, -- 3D model reference if needed
	AnimationData: {[string]: any}? -- Animation configuration
}

-- Player's card instance (owned card with upgrades)
export type PlayerCard = {
	CardID: string, -- Reference to CardData.ID
	Level: number, -- Player's upgrade level for this card
	Experience: number, -- XP toward next level
	Quantity: number, -- How many copies player owns
	FirstObtained: number, -- Timestamp when first acquired
	IsFavorite: boolean, -- Player marked as favorite
	
	-- Calculated stats (base + level bonuses)
	CurrentStats: CardStats
}

-- Card pack/roll data
export type CardPack = {
	ID: string,
	Name: string,
	Description: string,
	Cost: number, -- In premium currency
	GuaranteedRarity: CardRarity?, -- Minimum rarity guaranteed
	CardCount: number, -- How many cards in pack
	Series: CardSeries?, -- Series-specific pack
	IsLimited: boolean, -- Limited time pack
	DropRates: {[CardRarity]: number} -- Override default drop rates
}

-- Roll result data
export type RollResult = {
	Cards: {CardData},
	TotalValue: number, -- Calculated value of roll
	HasPityBonus: boolean, -- Was pity system triggered
	IsGuaranteed: boolean, -- Was guaranteed rare
	Timestamp: number,
	PackUsed: string? -- Pack ID if from pack
}

-- Card deck for battles
export type CardDeck = {
	Name: string,
	Cards: {PlayerCard}, -- Up to 40 cards
	DateCreated: number,
	LastUsed: number,
	WinRate: number, -- Performance tracking
	TotalBattles: number
}

-- Battle card state
export type BattleCard = {
	PlayerCard: PlayerCard,
	CurrentHealth: number,
	StatusEffects: {string}, -- Active effects
	Cooldowns: {[string]: number}, -- Ability cooldowns
	Position: number, -- Position in battle lineup
	HasAttacked: boolean -- This turn
}

-- Card upgrade costs and requirements
export type CardUpgrade = {
	Level: number,
	ExperienceRequired: number,
	CostCoins: number,
	CostCards: number, -- Duplicate cards needed
	StatBonus: CardStats, -- Stat increase at this level
	UnlocksAbility: boolean? -- Does this level unlock special ability
}

-- Card collection progress
export type CollectionProgress = {
	SeriesName: CardSeries,
	TotalCards: number,
	OwnedCards: number,
	CompletionPercent: number,
	MissingCards: {string}, -- Card IDs not owned
	RarityBreakdown: {[CardRarity]: {owned: number, total: number}}
}

-- Card trading data (future feature)
export type TradeOffer = {
	ID: string,
	FromPlayer: number, -- UserID
	ToPlayer: number, -- UserID
	OfferedCards: {PlayerCard},
	RequestedCards: {PlayerCard},
	Status: "Pending" | "Accepted" | "Rejected" | "Expired",
	ExpiresAt: number,
	CreatedAt: number
}

-- Export utility type for validation
export type CardDataValidator = {
	IsValidRarity: (rarity: string) -> boolean,
	IsValidSeries: (series: string) -> boolean,
	IsValidType: (cardType: string) -> boolean,
	ValidateCardData: (card: CardData) -> boolean,
	ValidateStats: (stats: CardStats) -> boolean
}

return {} 
--- FILE: ./src/shared/Types/EffectsTypes.luau ---
--!strict
-- EffectsTypes.luau
-- Advanced visual effects type definitions for premium polish
-- Includes screen effects, particle systems, impact frames, and visual juice

-- Screen Effects Types
export type ScreenEffect = {
	Name: string,
	Type: string, -- "ChromaticAberration", "Bloom", "Distortion", "Vignette", "ColorGrading"
	Intensity: number, -- 0.0 to 1.0
	Duration: number,
	FadeInTime: number,
	FadeOutTime: number,
	EasingStyle: Enum.EasingStyle,
	EasingDirection: Enum.EasingDirection,
	IsLooping: boolean,
	Priority: number -- Higher priority effects override lower ones
}

export type ChromaticAberrationEffect = {
	Intensity: number, -- 0.0 to 1.0, controls color separation
	RedOffset: Vector2, -- Pixel offset for red channel
	GreenOffset: Vector2, -- Pixel offset for green channel  
	BlueOffset: Vector2, -- Pixel offset for blue channel
	RadialDistortion: number, -- 0.0 to 1.0, screen edge emphasis
	DistortionCenter: Vector2 -- Center point for radial effect
}

export type BloomEffect = {
	Intensity: number, -- 0.0 to 2.0, brightness multiplier
	Threshold: number, -- 0.0 to 1.0, brightness threshold for bloom
	Size: number, -- 0.0 to 5.0, bloom spread radius
	SoftKnee: number, -- 0.0 to 1.0, soft threshold transition
	Color: Color3, -- Bloom tint color
	Saturation: number -- 0.0 to 2.0, color saturation boost
}

export type DistortionEffect = {
	Type: string, -- "Wave", "Ripple", "Twist", "Bulge", "Pinch"
	Strength: number, -- 0.0 to 1.0, distortion intensity
	Center: Vector2, -- Distortion origin point
	Radius: number, -- Effect radius in pixels
	Frequency: number, -- For wave effects
	Speed: number, -- Animation speed
	Direction: Vector2 -- For directional effects
}

export type ColorGradingEffect = {
	Contrast: number, -- 0.0 to 2.0, default 1.0
	Brightness: number, -- -1.0 to 1.0, default 0.0
	Saturation: number, -- 0.0 to 2.0, default 1.0
	Hue: number, -- -180 to 180 degrees
	Temperature: number, -- -100 to 100, color temperature
	Tint: number, -- -100 to 100, green/magenta tint
	Gamma: number, -- 0.1 to 3.0, default 1.0
	ColorFilter: Color3 -- Multiplicative color filter
}

export type VignetteEffect = {
	Intensity: number, -- 0.0 to 1.0, darkness at edges
	Smoothness: number, -- 0.0 to 1.0, edge softness
	Roundness: number, -- 0.0 to 1.0, circular vs square shape
	Center: Vector2, -- Vignette center point
	Color: Color3, -- Vignette color (usually black)
	Feather: number -- 0.0 to 1.0, feathering amount
}

-- Particle System Types
export type ParticleConfig = {
	ParticleType: string, -- "Spark", "Glow", "Smoke", "Magic", "Energy", "Explosion"
	Count: number, -- Number of particles to spawn
	LifeTime: NumberRange, -- Particle lifetime range
	Size: NumberSequence, -- Size over lifetime
	Color: ColorSequence, -- Color over lifetime
	Transparency: NumberSequence, -- Transparency over lifetime
	Velocity: Vector3, -- Initial velocity
	VelocityVariation: Vector3, -- Velocity randomization
	Acceleration: Vector3, -- Constant acceleration (gravity, etc.)
	Drag: number, -- Air resistance
	RotationSpeed: NumberRange, -- Rotation speed range
	EmissionRate: number, -- Particles per second
	BurstCount: number, -- Particles in initial burst
	Texture: string, -- Particle texture ID
	BlendMode: Enum.BlendMode,
	ZOffset: number -- Depth sorting offset
}

export type ParticlePool = {
	ParticleType: string,
	PoolSize: number,
	ActiveParticles: {any}, -- Array of active particle objects
	InactiveParticles: {any}, -- Array of inactive particle objects
	CreatedCount: number, -- Total particles created
	RecycledCount: number, -- Total particles recycled
	MaxActiveParticles: number, -- Performance limit
	LastCleanupTime: number -- For optimization
}

export type ParticleSystem = {
	Name: string,
	Position: Vector3,
	IsActive: boolean,
	Duration: number, -- System lifetime, -1 for infinite
	Pools: {[string]: ParticlePool}, -- Particle type pools
	EmissionSettings: {[string]: ParticleConfig},
	PerformanceLevel: number, -- 0-3, adjusts quality
	AttachedTo: Instance?, -- Optional attachment point
	LocalSpace: boolean -- Particles move with attachment
}

-- Impact Frame Types  
export type ImpactFrame = {
	Name: string,
	Duration: number, -- Frame freeze duration (research: 50-200ms)
	Intensity: number, -- 0.0 to 1.0, effect strength
	FrameHold: number, -- Actual frame hold time (1-12 frames at 60fps)
	SlowMotion: number, -- 0.0 to 1.0, time scale during impact
	ScreenShake: boolean, -- Apply screen shake during impact
	ChromaticShift: boolean, -- Apply chromatic aberration
	SoundPunch: boolean, -- Audio emphasis during impact
	VisualPunch: boolean, -- Visual scaling/flash effect
	EaseInTime: number, -- Transition into impact
	EaseOutTime: number -- Transition out of impact
}

export type ImpactTiming = {
	AnticipationFrames: number, -- Windup frames before impact
	ImpactFrames: number, -- Actual impact duration
	RecoveryFrames: number, -- Frames after impact
	TotalSequenceTime: number, -- Complete sequence duration
	ImpactIntensityCurve: NumberSequence, -- Intensity over time
	TimingPrecision: number -- Frame precision (16.67ms for 60fps)
}

export type ImpactType = {
	Light: ImpactFrame, -- Quick hits, 50ms (3 frames)
	Medium: ImpactFrame, -- Standard hits, 100ms (6 frames)  
	Heavy: ImpactFrame, -- Strong hits, 167ms (10 frames)
	Ultimate: ImpactFrame, -- Legendary impacts, 200ms (12 frames)
	Critical: ImpactFrame -- Special critical hits
}

-- Visual Juice Types
export type JuiceEffect = {
	Name: string,
	Type: string, -- "Scale", "Rotation", "Position", "Color", "Glow", "Pulse"
	TriggerEvent: string, -- What triggers this effect
	StartValue: any, -- Initial value
	EndValue: any, -- Target value
	Duration: number,
	Delay: number, -- Delay before starting
	EasingStyle: Enum.EasingStyle,
	EasingDirection: Enum.EasingDirection,
	RepeatCount: number, -- -1 for infinite
	Reverses: boolean, -- Plays backwards after forward
	YieldUntilFinished: boolean
}

export type JuiceSequence = {
	Name: string,
	Effects: {JuiceEffect}, -- Multiple effects in sequence
	ParallelEffects: {JuiceEffect}, -- Effects that play simultaneously
	TotalDuration: number,
	IsLooping: boolean,
	Priority: number,
	InterruptBehavior: string -- "Cancel", "Complete", "Queue"
}

export type VisualJuiceConfig = {
	ButtonHover: JuiceSequence,
	ButtonPress: JuiceSequence,
	CardReveal: JuiceSequence,
	CardPull: JuiceSequence,
	RarityReveal: JuiceSequence,
	BattleHit: JuiceSequence,
	VictorySequence: JuiceSequence,
	LevelUp: JuiceSequence,
	ErrorFeedback: JuiceSequence,
	SuccessFeedback: JuiceSequence
}

-- Performance and Optimization Types
export type EffectsPerformanceConfig = {
	MaxScreenEffects: number, -- Concurrent screen effects limit
	MaxParticleSystems: number, -- Concurrent particle systems limit
	MaxParticlesPerSystem: number, -- Particles per system limit
	ParticlePoolSizes: {[string]: number}, -- Pool sizes by type
	EffectQualityLevel: number, -- 0-3, adjusts all effect quality
	MobileOptimizations: boolean,
	PerformanceMonitoring: boolean,
	AutoQualityAdjustment: boolean, -- Adjust quality based on performance
	FrameRateThreshold: number -- Minimum FPS before quality reduction
}

export type EffectsLODConfig = {
	HighQuality: EffectsPerformanceConfig, -- Desktop high-end
	MediumQuality: EffectsPerformanceConfig, -- Desktop mid-range  
	LowQuality: EffectsPerformanceConfig, -- Mobile/low-end
	UltraLowQuality: EffectsPerformanceConfig -- Emergency fallback
}

-- Animation and Timing Types
export type AnimationCurve = {
	CurveType: string, -- "Linear", "EaseIn", "EaseOut", "EaseInOut", "Bounce", "Elastic"
	Strength: number, -- Curve strength modifier
	Overshoot: number, -- For elastic/bounce curves
	Period: number, -- For periodic curves
	CustomPoints: {Vector2}? -- For custom bezier curves
}

export type TimingFunction = {
	Name: string,
	Function: (t: number) -> number, -- t goes from 0 to 1
	Description: string,
	RecommendedUse: string, -- When to use this timing function
	ResearchBasis: string -- Research supporting this timing
}

export type EffectTiming = {
	StartTime: number, -- When effect begins
	Duration: number, -- Effect duration
	FadeInTime: number, -- Fade in duration
	FadeOutTime: number, -- Fade out duration
	PeakTime: number, -- When effect reaches maximum
	TimingCurve: AnimationCurve,
	SyncWithAudio: boolean, -- Sync with audio events
	FrameAccurate: boolean -- Ensure frame-perfect timing
}

-- Research-Based Constants
export type EffectResearchData = {
	OptimalImpactDuration: NumberRange, -- 50-200ms from research
	AttentionGrabbingColors: {Color3}, -- Colors that grab attention
	SatisfactionCurves: {[string]: AnimationCurve}, -- Psychologically satisfying curves
	PerformanceLimits: {
		MobileParticleLimit: number, -- 50-100 particles max
		DesktopParticleLimit: number, -- 200-500 particles max  
		ScreenEffectLimit: number, -- 3-5 concurrent effects max
		FrameRateImpact: number -- % FPS impact per effect
	},
	UserPreferences: {
		PreferredEffectIntensity: NumberRange, -- Most players prefer 0.6-0.8
		MotionSensitivityThreshold: number, -- When to reduce effects
		FlashingSensitivityLimit: number -- Maximum flashing frequency
	}
}

-- Main Effects System State
export type EffectsSystemState = {
	IsInitialized: boolean,
	CurrentQualityLevel: number,
	ActiveScreenEffects: {[string]: ScreenEffect},
	ActiveParticleSystems: {[string]: ParticleSystem},
	ActiveImpactFrames: {[string]: ImpactFrame},
	ActiveJuiceSequences: {[string]: JuiceSequence},
	PerformanceConfig: EffectsPerformanceConfig,
	ResearchData: EffectResearchData,
	FrameRate: number, -- Current FPS
	EffectCount: number, -- Total active effects
	ParticleCount: number, -- Total active particles
	LastOptimizationTime: number
}

-- Service Interface Types
export type PolishEffectsServiceConfig = {
	EnableScreenEffects: boolean,
	EnableParticleEffects: boolean,
	EnableImpactFrames: boolean,
	EnableVisualJuice: boolean,
	AutoQualityAdjustment: boolean,
	MobileOptimizations: boolean,
	PerformanceMonitoring: boolean,
	DebugMode: boolean
}

export type PolishEffectsEvents = {
	ScreenEffectStarted: (effectName: string) -> (),
	ScreenEffectFinished: (effectName: string) -> (),
	ParticleSystemSpawned: (systemName: string, position: Vector3) -> (),
	ImpactFrameTriggered: (impactType: string, intensity: number) -> (),
	VisualJuiceTriggered: (sequenceName: string) -> (),
	QualityLevelChanged: (newLevel: number, reason: string) -> (),
	PerformanceWarning: (warningType: string, metrics: any) -> ()
}

return {} 
--- FILE: ./src/shared/Types/UITypes.luau ---
--!strict
-- UITypes.luau
-- Type definitions for the card reveal UI system and visual effects

local RollTypes = require(script.Parent.RollTypes)
local CardTypes = require(script.Parent.CardTypes)

type CardRollResult = RollTypes.CardRollResult
type CardData = CardTypes.CardData

-- Card Reveal UI Types
export type CardRevealRequest = {
    Cards: {CardRollResult},
    RevealType: RevealType,
    TotalDuration: number,
    AudioEnabled: boolean,
    EffectsEnabled: boolean,
    SkipAnimations: boolean?
}

export type RevealType = "Single" | "Multi" | "Batch" | "Guaranteed"

export type CardRevealState = {
    CurrentCard: number,
    TotalCards: number,
    RevealStartTime: number,
    IsRevealing: boolean,
    IsPaused: boolean,
    CanSkip: boolean,
    RevealProgress: number -- 0-1
}

export type CardRevealResult = {
    Success: boolean,
    CardsRevealed: number,
    TotalDuration: number,
    UserSkipped: boolean,
    ErrorMessage: string?
}

-- Animation Types
export type AnimationData = {
    Duration: number,
    EasingStyle: Enum.EasingStyle,
    EasingDirection: Enum.EasingDirection,
    RepeatCount: number,
    Reverses: boolean,
    DelayTime: number
}

export type CardAnimationSequence = {
    CardID: string,
    Rarity: string,
    Animations: {AnimationStep},
    TotalDuration: number,
    EffectIntensity: number
}

export type AnimationStep = {
    StepName: string,
    StartTime: number,
    Duration: number,
    AnimationType: AnimationType,
    Properties: {[string]: any},
    EasingData: AnimationData,
    AudioCue: string?
}

export type AnimationType = "Position" | "Size" | "Rotation" | "Transparency" | "Color" | "Effect"

-- Visual Effect Types
export type VisualEffect = {
    EffectID: string,
    EffectType: EffectType,
    Duration: number,
    StartTime: number,
    EndTime: number,
    Properties: EffectProperties,
    Target: Instance?,
    IsActive: boolean
}

export type EffectType = "Particle" | "Light" | "ScreenShake" | "Flash" | "Glow" | "Sparkle" | "Explosion" | "Aura"

export type EffectProperties = {
    Color: Color3?,
    Size: number?,
    Intensity: number?,
    Speed: number?,
    Lifetime: number?,
    EmissionRate: number?,
    SpreadAngle: number?,
    Texture: string?,
    Transparency: number?,
    Position: Vector3?,
    Rotation: Vector3?
}

-- Screen Effect Types
export type ScreenEffect = {
    EffectName: string,
    Duration: number,
    Intensity: number,
    Color: Color3?,
    StartTime: number,
    FadeInTime: number,
    FadeOutTime: number,
    Properties: {[string]: any}
}

export type ScreenShakeData = {
    Intensity: number,
    Duration: number,
    Frequency: number,
    Decay: number,
    Trauma: number,
    StartTime: number
}

-- Audio Types
export type AudioCue = {
    SoundID: string,
    Volume: number,
    Pitch: number,
    PlayTime: number,
    Duration: number,
    FadeIn: number?,
    FadeOut: number?,
    Loop: boolean,
    Rarity: string?
}

export type AudioSequence = {
    SequenceID: string,
    AudioCues: {AudioCue},
    TotalDuration: number,
    IsPlaying: boolean,
    CurrentCue: number
}

-- UI Element Types
export type CardDisplayElement = {
    Frame: GuiObject,
    CardImage: ImageLabel,
    RarityBorder: ImageLabel,
    NameLabel: TextLabel,
    StatsFrame: Frame,
    EffectContainer: Frame,
    IsVisible: boolean,
    CurrentCard: CardData?
}

export type RevealUIElements = {
    MainFrame: ScreenGui,
    RevealContainer: Frame,
    CardDisplays: {CardDisplayElement},
    ProgressBar: Frame,
    SkipButton: TextButton,
    ContinueButton: TextButton,
    BackgroundOverlay: Frame,
    EffectsLayer: Frame
}

-- Layout Types
export type CardLayoutConfig = {
    CardSize: UDim2,
    CardSpacing: number,
    MaxCardsPerRow: number,
    AnimationStartPosition: UDim2,
    AnimationEndPosition: UDim2,
    ScaleMultiplier: number
}

export type ResponsiveLayout = {
    Mobile: CardLayoutConfig,
    Tablet: CardLayoutConfig,
    Desktop: CardLayoutConfig,
    Console: CardLayoutConfig
}

-- Input Types
export type RevealInputAction = {
    ActionType: InputActionType,
    InputObject: InputObject?,
    Timestamp: number,
    IsProcessed: boolean
}

export type InputActionType = "Skip" | "Continue" | "Pause" | "Resume" | "Tap" | "Hold"

-- Performance Types
export type PerformanceMetrics = {
    FrameRate: number,
    MemoryUsage: number,
    ActiveAnimations: number,
    ActiveEffects: number,
    RenderTime: number,
    LastUpdateTime: number
}

export type OptimizationSettings = {
    MaxConcurrentAnimations: number,
    MaxParticleCount: number,
    EffectQuality: EffectQuality,
    ReduceMotion: boolean,
    SkipComplexEffects: boolean
}

export type EffectQuality = "Low" | "Medium" | "High" | "Ultra"

-- Rarity Specific Types
export type RarityVisualConfig = {
    BorderColor: Color3,
    GlowColor: Color3,
    ParticleColor: Color3,
    EffectIntensity: number,
    AnimationDuration: number,
    AudioFrequency: number,
    ScreenShakeIntensity: number,
    FlashIntensity: number
}

export type RarityConfigs = {
    [string]: RarityVisualConfig -- Rarity name -> config
}

-- Timing Types
export type TimingCalculation = {
    OptimalRevealTime: number,
    PsychologicalDelay: number,
    AnticipationPhase: number,
    RevealPhase: number,
    SatisfactionPhase: number,
    TotalTime: number
}

export type TimingPhase = "Anticipation" | "Buildup" | "Reveal" | "Satisfaction" | "Transition"

-- Event Types
export type UIEvent = {
    EventType: UIEventType,
    EventData: {[string]: any},
    Timestamp: number,
    PlayerID: number?
}

export type UIEventType = "RevealStarted" | "RevealCompleted" | "CardRevealed" | "EffectTriggered" | "UserSkipped" | "AnimationFinished"

-- Controller State Types
export type ControllerState = {
    IsInitialized: boolean,
    IsRevealing: boolean,
    CurrentRevealID: string?,
    QueuedReveals: {CardRevealRequest},
    ActiveEffects: {VisualEffect},
    UIElements: RevealUIElements?,
    PerformanceMode: EffectQuality,
    LastRevealTime: number
}

-- Configuration Types
export type UIConfiguration = {
    RarityConfigs: RarityConfigs,
    ResponsiveLayouts: ResponsiveLayout,
    AnimationSettings: AnimationSettings,
    AudioSettings: AudioSettings,
    PerformanceSettings: PerformanceSettings
}

export type AnimationSettings = {
    DefaultDuration: number,
    EasingStyle: Enum.EasingStyle,
    EasingDirection: Enum.EasingDirection,
    ScaleMultiplier: number,
    FadeInTime: number,
    FadeOutTime: number,
    StaggerDelay: number
}

export type AudioSettings = {
    MasterVolume: number,
    SFXVolume: number,
    MusicVolume: number,
    AudioEnabled: boolean,
    FrequencyEnabled: boolean,
    SpatialAudioEnabled: boolean
}

export type PerformanceSettings = {
    MaxFPS: number,
    EffectQuality: EffectQuality,
    ParticleLimit: number,
    AnimationLimit: number,
    AutoOptimize: boolean,
    PerformanceMonitoring: boolean
}

-- Utility Types
export type Color3WithAlpha = {
    Color: Color3,
    Alpha: number
}

export type Vector3WithTime = {
    Vector: Vector3,
    Time: number
}

export type AnimationPromise = {
    IsCompleted: boolean,
    IsCancelled: boolean,
    OnCompleted: (boolean) -> (),
    OnProgress: (number) -> (),
    Cancel: () -> ()
}

-- Service Response Types
export type UIServiceResponse<T> = {
    Success: boolean,
    Data: T?,
    ErrorMessage: string?,
    ProcessingTime: number
}

return {} 
--- FILE: ./src/shared/Types/AudioTypes.luau ---
--!strict
-- AudioTypes.luau
-- Comprehensive audio type definitions for psychological audio design
-- Supports frequency layering, timing precision, and spatial audio

-- Basic Audio Types
export type AudioFrequencyRange = {
	Low: number,
	High: number
}

export type AudioLayer = {
	Name: string,
	FrequencyRange: AudioFrequencyRange,
	Volume: number,
	Pitch: number,
	Reverb: number,
	Delay: number,
	IsActive: boolean
}

export type AudioCue = {
	ID: string,
	Name: string,
	SoundId: string,
	Volume: number,
	Pitch: number,
	Duration: number,
	Layers: {AudioLayer},
	Priority: number,
	Category: string,
	IsLooping: boolean,
	FadeInDuration: number,
	FadeOutDuration: number
}

export type AudioSequence = {
	ID: string,
	Name: string,
	AudioCues: {AudioCue},
	TotalDuration: number,
	IsLooping: boolean,
	CrossfadeDuration: number,
	SyncWindow: number -- 2ms precision window
}

-- Psychological Audio Design
export type PsychologicalTiming = {
	AnticipationDelay: number, -- Build tension
	ImpactTiming: number, -- Peak satisfaction moment
	ResolutionFade: number, -- Emotional release
	NextCuePrep: number -- Prepare for next audio event
}

export type DopamineProfile = {
	BuildupCurve: string, -- "linear", "exponential", "logarithmic"
	PeakIntensity: number, -- 0.0 to 1.0
	SustainDuration: number,
	ReleaseCurve: string,
	NextEventPrep: number -- Priming for next dopamine hit
}

export type PsychologicalAudioConfig = {
	RarityLevel: string,
	DopamineProfile: DopamineProfile,
	PsychologicalTiming: PsychologicalTiming,
	FrequencyEmphasis: {[string]: number}, -- Which frequency bands to emphasize
	SpatialEffects: boolean,
	CompressionLevel: number -- Dynamic range compression for mobile
}

-- Frequency Layering System
export type FrequencyLayer = {
	Name: string, -- "SubBass", "MidBass", "Presence", "Brilliance"
	FrequencyRange: AudioFrequencyRange,
	Purpose: string, -- "impact", "clarity", "magic", "weight"
	IntensityMultiplier: number,
	PsychologicalEffect: string, -- "tension", "satisfaction", "excitement", "calm"
	Priority: number -- For mobile optimization
}

export type FrequencyLayerConfig = {
	SubBass: FrequencyLayer, -- 20-60Hz: Visceral impact
	MidBass: FrequencyLayer, -- 60-250Hz: Weight and power  
	LowMid: FrequencyLayer, -- 250-500Hz: Fullness
	Midrange: FrequencyLayer, -- 500-1000Hz: Core presence
	UpperMid: FrequencyLayer, -- 1000-4000Hz: Clarity and cut
	Presence: FrequencyLayer, -- 4000-8000Hz: Sparkle
	Brilliance: FrequencyLayer, -- 8000-16000Hz: Magic and air
	ActiveLayers: {string}, -- Which layers are currently active
	MobileOptimization: boolean
}

-- Spatial Audio
export type SpatialAudioConfig = {
	IsEnabled: boolean,
	ListenerPosition: Vector3,
	ListenerOrientation: Vector3,
	RoomSize: string, -- "small", "medium", "large"
	ReverbAmount: number,
	DopplerEffect: boolean,
	DistanceAttenuation: number,
	MaxAudibleDistance: number
}

export type AudioSource = {
	ID: string,
	Position: Vector3,
	Orientation: Vector3,
	Volume: number,
	AttenuationRadius: number,
	IsDirectional: boolean,
	ConeAngle: number,
	IsLooping: boolean,
	CurrentCue: AudioCue?
}

-- Audio Context and Environment
export type AudioContext = {
	CurrentScene: string, -- "Menu", "CardRoll", "Battle", "Collection"
	PlayerState: string, -- "Idle", "Rolling", "Battling", "Browsing"
	TensionLevel: number, -- 0.0 to 1.0
	ExcitementLevel: number, -- 0.0 to 1.0
	RecentActions: {string}, -- Last 5 player actions for context
	SessionLength: number, -- How long player has been playing
	LastMajorEvent: string, -- Last significant event for pacing
	NextExpectedEvent: string -- What's coming next
}

export type AudioEnvironment = {
	AmbientProfile: string, -- "Calm", "Tense", "Exciting", "Magical"
	ReverbSettings: {
		RoomSize: number,
		Wetness: number,
		Decay: number,
		DiffusionLevel: number
	},
	CompressionSettings: {
		Threshold: number,
		Ratio: number,
		Attack: number,
		Release: number,
		MakeupGain: number
	},
	EQSettings: {
		LowShelf: number,
		LowMid: number,
		HighMid: number,
		HighShelf: number
	}
}

-- Performance and Optimization
export type AudioPerformanceConfig = {
	MaxConcurrentSounds: number,
	MaxConcurrentLayers: number,
	MobileOptimizationLevel: number, -- 0-3
	AudioCompressionLevel: number,
	SampleRateOptimization: boolean,
	BitrateLimit: number,
	CPUUsageLimit: number, -- % of CPU for audio
	MemoryUsageLimit: number -- MB limit for audio
}

export type AudioStreamingConfig = {
	PreloadDistance: number, -- Distance to preload audio
	StreamingQuality: string, -- "Low", "Medium", "High"
	BufferSize: number,
	CompressionType: string, -- "OGG", "MP3", "WAV"
	AdaptiveQuality: boolean, -- Adjust quality based on performance
	NetworkOptimization: boolean
}

-- Analytics and Monitoring
export type AudioAnalytics = {
	PlaybackEvents: {string},
	PsychologicalResponse: {
		TensionCurve: {number},
		SatisfactionSpikes: {number},
		EngagementLevel: number,
		AudioDropoffs: {string} -- Where players mute/lower audio
	},
	PerformanceMetrics: {
		CPUUsage: number,
		MemoryUsage: number,
		LatencyMS: number,
		DroppedFrames: number
	},
	PlayerPreferences: {
		PreferredVolumeLevels: {[string]: number},
		DisabledCategories: {string},
		SpatialAudioUsage: boolean,
		QualityPreference: string
	}
}

-- Main Audio System State
export type AudioSystemState = {
	IsInitialized: boolean,
	CurrentContext: AudioContext,
	ActiveAudioSources: {[string]: AudioSource},
	ActiveSequences: {[string]: AudioSequence},
	FrequencyConfig: FrequencyLayerConfig,
	SpatialConfig: SpatialAudioConfig,
	PerformanceConfig: AudioPerformanceConfig,
	Analytics: AudioAnalytics,
	MasterVolume: number,
	SFXVolume: number,
	MusicVolume: number,
	VoiceVolume: number,
	IsAudioEnabled: boolean,
	IsMuted: boolean,
	LastUpdateTime: number
}

-- Service Interface Types
export type AudioServiceConfig = {
	EnablePsychologicalDesign: boolean,
	EnableFrequencyLayering: boolean,
	EnableSpatialAudio: boolean,
	EnableAnalytics: boolean,
	MobileOptimizationLevel: number,
	DebugMode: boolean
}

export type AudioServiceEvents = {
	AudioCueStarted: (cueID: string) -> (),
	AudioCueFinished: (cueID: string) -> (),
	SequenceStarted: (sequenceID: string) -> (),
	SequenceFinished: (sequenceID: string) -> (),
	PsychologicalEventTriggered: (eventType: string, intensity: number) -> (),
	FrequencyLayerChanged: (layerName: string, isActive: boolean) -> (),
	SpatialAudioEvent: (sourceID: string, eventType: string) -> (),
	AudioError: (errorType: string, message: string) -> ()
}

return {} 
--- FILE: ./src/shared/Types/BattleTypes.luau ---
--!strict
-- BattleTypes.luau
-- Type definitions for the elevated 2D battle system

local CardTypes = require(script.Parent.CardTypes)
local PlayerTypes = require(script.Parent.PlayerTypes)
local UITypes = require(script.Parent.UITypes)

type CardData = CardTypes.CardData
type PlayerData = PlayerTypes.PlayerData

-- Battle Core Types
export type BattleSession = {
    BattleID: string,
    Player1: BattlePlayer,
    Player2: BattlePlayer,
    CurrentTurn: number,
    ActivePlayer: number, -- 1 or 2
    BattleState: BattleState,
    TurnTimer: number,
    BattleStartTime: number,
    BattleEndTime: number?,
    Winner: number?, -- 1, 2, or nil for draw
    BattleType: BattleType,
    Spectators: {number}, -- UserIDs
    BattleSettings: BattleSettings
}

export type BattlePlayer = {
    UserID: number,
    Username: string,
    Deck: {BattleCard},
    Hand: {BattleCard},
    ActiveCard: BattleCard?,
    Health: number,
    MaxHealth: number,
    Energy: number,
    MaxEnergy: number,
    Shield: number,
    StatusEffects: {StatusEffect},
    IsReady: boolean,
    LastActionTime: number,
    BattleStats: PlayerBattleStats
}

export type BattleCard = {
    InstanceID: string,
    CardData: CardData,
    CurrentHealth: number,
    MaxHealth: number,
    Attack: number,
    Defense: number,
    Energy: number,
    StatusEffects: {StatusEffect},
    Position: CardPosition,
    CanAttack: boolean,
    TurnsOnField: number,
    DamageDealt: number,
    DamageTaken: number
}

export type CardPosition = "Hand" | "Active" | "Graveyard" | "Deck"

export type BattleState = "Waiting" | "Starting" | "InProgress" | "Paused" | "Finished" | "Cancelled"

export type BattleType = "Ranked" | "Casual" | "Practice" | "Tournament" | "AI"

export type BattleSettings = {
    TurnTimeLimit: number,
    MaxTurns: number,
    StartingHealth: number,
    StartingEnergy: number,
    DeckSize: number,
    HandSize: number,
    AllowSpectators: boolean,
    RankedMatch: boolean
}

-- Action Types
export type BattleAction = {
    ActionID: string,
    PlayerID: number,
    ActionType: ActionType,
    ActionData: ActionData,
    Timestamp: number,
    IsValid: boolean,
    ProcessingTime: number?,
    VisualEffects: {VisualActionEffect}?
}

export type ActionType = "PlayCard" | "Attack" | "UseSpecial" | "EndTurn" | "Surrender" | "UseItem"

export type ActionData = {
    SourceCardID: string?,
    TargetCardID: string?,
    TargetPlayerID: number?,
    Position: CardPosition?,
    SpecialData: {[string]: any}?
}

export type VisualActionEffect = {
    EffectType: string,
    SourcePosition: Vector2?,
    TargetPosition: Vector2?,
    Duration: number,
    Intensity: number,
    Properties: {[string]: any}
}

-- Damage and Effects Types
export type DamageCalculation = {
    BaseAttack: number,
    BaseDamage: number,
    AttackModifiers: {DamageModifier},
    DefenseModifiers: {DamageModifier},
    FinalDamage: number,
    IsCritical: boolean,
    CriticalMultiplier: number,
    DamageType: DamageType,
    Penetration: number,
    MitigatedDamage: number
}

export type DamageModifier = {
    ModifierType: string,
    Value: number,
    Source: string,
    Duration: number?
}

export type DamageType = "Physical" | "Special" | "True" | "Healing"

export type StatusEffect = {
    EffectID: string,
    EffectType: StatusEffectType,
    Stacks: number,
    Duration: number,
    Intensity: number,
    Source: string,
    TickDamage: number?,
    StatModifiers: {StatModifier}?,
    VisualEffect: string?
}

export type StatusEffectType = "Poison" | "Burn" | "Freeze" | "Stun" | "Shield" | "Rage" | "Heal" | "Buff" | "Debuff"

export type StatModifier = {
    StatName: string,
    ModifierType: "Add" | "Multiply" | "Set",
    Value: number,
    Duration: number
}

-- Turn Management Types
export type TurnPhase = "Draw" | "Main" | "Attack" | "End"

export type TurnData = {
    TurnNumber: number,
    PlayerID: number,
    Phase: TurnPhase,
    PhaseStartTime: number,
    ActionsPerformed: {BattleAction},
    TimeRemaining: number,
    CanPerformActions: boolean
}

-- Battle Events Types
export type BattleEvent = {
    EventID: string,
    EventType: BattleEventType,
    PlayerID: number?,
    EventData: {[string]: any},
    Timestamp: number,
    TurnNumber: number,
    ShouldBroadcast: boolean
}

export type BattleEventType = "BattleStart" | "TurnStart" | "TurnEnd" | "CardPlayed" | "Attack" | "Damage" | 
    "StatusEffectApplied" | "StatusEffectRemoved" | "CardDestroyed" | "PlayerDefeated" | "BattleEnd"

-- Visual Effects Integration Types
export type BattleVisualEffect = {
    EffectID: string,
    EffectType: BattleEffectType,
    SourceCard: BattleCard?,
    TargetCard: BattleCard?,
    SourcePlayer: number?,
    TargetPlayer: number?,
    EffectData: BattleEffectData,
    Timing: EffectTiming,
    Priority: number
}

export type BattleEffectType = "CardPlay" | "Attack" | "Damage" | "Heal" | "StatusEffect" | "CardDestroy" | "SpecialAbility"

export type BattleEffectData = {
    Duration: number,
    Intensity: number,
    ImpactFrames: number,
    ScreenShakeIntensity: number,
    ParticleCount: number,
    AudioCues: {string},
    ColorOverride: Color3?,
    PositionData: EffectPositionData?
}

export type EffectPositionData = {
    StartPosition: Vector2,
    EndPosition: Vector2,
    ArcHeight: number?,
    Speed: number,
    EasingStyle: string
}

export type EffectTiming = {
    StartDelay: number,
    ImpactTime: number,
    EffectDuration: number,
    FadeOutTime: number
}

-- AI Battle Types
export type AIOpponent = {
    AIID: string,
    Name: string,
    Difficulty: AIDifficulty,
    Deck: {CardData},
    Personality: AIPersonality,
    BehaviorSettings: AIBehaviorSettings
}

export type AIDifficulty = "Easy" | "Medium" | "Hard" | "Expert" | "Master"

export type AIPersonality = {
    Aggression: number, -- 0-1
    Defense: number, -- 0-1
    RiskTaking: number, -- 0-1
    Patience: number, -- 0-1
    Adaptability: number -- 0-1
}

export type AIBehaviorSettings = {
    ThinkingTime: number,
    RandomnessFactor: number,
    PredictiveDepth: number,
    FavoriteStrategies: {string},
    CounterStrategies: {string}
}

-- Battle Statistics Types
export type PlayerBattleStats = {
    DamageDealt: number,
    DamageTaken: number,
    CardsPlayed: number,
    SpecialAbilitiesUsed: number,
    CriticalHits: number,
    StatusEffectsApplied: number,
    TurnsPlayed: number,
    LongestCombo: number,
    HighestSingleDamage: number,
    CardsDestroyed: number
}

export type BattleResult = {
    BattleID: string,
    Winner: number?,
    Loser: number?,
    BattleDuration: number,
    TotalTurns: number,
    Player1Stats: PlayerBattleStats,
    Player2Stats: PlayerBattleStats,
    ExperienceGained: {[number]: number},
    RewardsEarned: {[number]: BattleRewards},
    RankingChanges: {[number]: number}?
}

export type BattleRewards = {
    Coins: number,
    Experience: number,
    Cards: {CardData}?,
    Items: {string}?,
    Achievements: {string}?
}

-- Matchmaking Types
export type MatchmakingRequest = {
    PlayerID: number,
    BattleType: BattleType,
    PreferredDifficulty: AIDifficulty?,
    SkillRating: number,
    SearchStartTime: number,
    MaxWaitTime: number
}

export type MatchmakingResult = {
    Success: boolean,
    BattleSession: BattleSession?,
    WaitTime: number,
    ErrorMessage: string?
}

-- Battle UI Types
export type BattleUIState = {
    IsActive: boolean,
    CurrentPhase: TurnPhase,
    SelectedCard: BattleCard?,
    ValidTargets: {BattleCard},
    CanEndTurn: boolean,
    ShowingResults: boolean,
    AnimationsPlaying: number,
    UILocked: boolean
}

export type BattleUIElements = {
    MainFrame: ScreenGui,
    BattleField: Frame,
    Player1Area: Frame,
    Player2Area: Frame,
    HandContainer: Frame,
    ActionButtons: Frame,
    StatusDisplay: Frame,
    TimerDisplay: Frame,
    EffectsLayer: Frame
}

export type CardUIData = {
    Frame: GuiObject,
    CardID: string,
    Position: Vector2,
    IsAnimating: boolean,
    IsSelected: boolean,
    IsValidTarget: boolean,
    EffectContainer: Frame
}

-- Animation Types
export type BattleAnimation = {
    AnimationID: string,
    AnimationType: BattleAnimationType,
    SourceCard: CardUIData?,
    TargetCard: CardUIData?,
    Duration: number,
    ImpactFrame: number,
    EffectIntensity: number,
    OnComplete: (() -> ())?,
    OnImpact: (() -> ())?
}

export type BattleAnimationType = "CardPlay" | "Attack" | "Block" | "Special" | "Destroy" | "Heal" | "StatusEffect"

-- Network Types
export type BattleMessage = {
    MessageType: BattleMessageType,
    BattleID: string,
    PlayerID: number,
    MessageData: any,
    Timestamp: number,
    Sequence: number
}

export type BattleMessageType = "Action" | "StateUpdate" | "Event" | "Chat" | "Disconnect" | "Reconnect"

-- Service Response Types
export type BattleServiceResponse<T> = {
    Success: boolean,
    Data: T?,
    ErrorMessage: string?,
    ProcessingTime: number,
    BattleID: string?
}

export type ActionValidationResult = {
    IsValid: boolean,
    ErrorReason: string?,
    SuggestedActions: {ActionType}?
}

export type StartBattleRequest = {
	BattleType: "PVE" | "PVP_RANDOM" | "PVP_FRIEND",
	OpponentId: string?, -- For PVE or specific PVP
	DeckId: string?,
	BattlefieldId: string?
}

-- Configuration Types
export type BattleConfiguration = {
    GameplaySettings: GameplaySettings,
    VisualSettings: BattleVisualSettings,
    AudioSettings: BattleAudioSettings,
    PerformanceSettings: BattlePerformanceSettings
}

export type GameplaySettings = {
    DefaultTurnTime: number,
    MaxBattleDuration: number,
    StartingResources: {[string]: number},
    DamageScaling: number,
    CriticalChance: number,
    StatusEffectDurations: {[string]: number}
}

export type BattleVisualSettings = {
    ImpactFrameDuration: number,
    ScreenShakeIntensity: number,
    ParticleQuality: string,
    AnimationSpeed: number,
    EffectLayering: boolean,
    MobileOptimizations: boolean
}

export type BattleAudioSettings = {
    SFXVolume: number,
    MusicVolume: number,
    SpatialAudio: boolean,
    AudioCompression: string,
    ImpactSoundTiming: number
}

export type BattlePerformanceSettings = {
    MaxConcurrentAnimations: number,
    ParticleLimit: number,
    EffectQuality: string,
    FrameRateTarget: number,
    MemoryLimit: number
}

return {} 
--- FILE: ./src/shared/Types/PlayerTypes.luau ---
--!strict
-- PlayerTypes.luau
-- Comprehensive type definitions for player data management

local CardTypes = require(script.Parent.CardTypes)

-- Player Statistics
export type PlayerStats = {
    Level: number,
    Experience: number,
    ExperienceToNext: number,
    TotalRolls: number,
    RollsToNextPity: number,
    BattlesWon: number,
    BattlesLost: number,
    WinRate: number,
    HighestWinStreak: number,
    CurrentWinStreak: number,
    TotalDamageDealt: number,
    TotalDamageReceived: number,
    FavoriteCard: string?, -- Card ID
    PlayTime: number, -- in seconds
    FirstLoginTime: number, -- Unix timestamp
    LastLoginTime: number, -- Unix timestamp
    LoginStreak: number,
    DailyRollsUsed: number,
    DailyRollsResetTime: number -- Unix timestamp
}

-- Card Collection Data
export type CardCollection = {
    OwnedCards: {[string]: CardInstance}, -- Card ID -> CardInstance
    CardCounts: {[string]: number}, -- Card ID -> count
    TotalCardsOwned: number,
    UniqueCardsOwned: number,
    FavoriteCards: {string}, -- Array of Card IDs
    RecentlyObtained: {string}, -- Array of Card IDs with timestamps
    CollectionValue: number -- Total value of collection
}

-- Individual Card Instance
export type CardInstance = {
    ID: string,
    CardID: string, -- Reference to CardData
    ObtainedTime: number, -- Unix timestamp
    TimesUsed: number,
    WinsWithCard: number,
    LossesWithCard: number,
    DamageDealt: number,
    IsNew: boolean,
    IsFavorite: boolean
}

-- Player Progression
export type PlayerProgression = {
    CurrentDeck: {string}, -- Array of Card IDs (max 5)
    UnlockedFeatures: {string}, -- Array of feature names
    Achievements: {string}, -- Array of achievement IDs
    QuestProgress: {[string]: number}, -- Quest ID -> progress
    CompletedQuests: {string}, -- Array of quest IDs
    TutorialProgress: {[string]: boolean}, -- Tutorial step -> completed
    LastSeenNews: string?, -- News ID
    Settings: PlayerSettings
}

-- Player Settings
export type PlayerSettings = {
    SoundEnabled: boolean,
    MusicEnabled: boolean,
    SoundVolume: number,
    MusicVolume: number,
    ScreenShakeEnabled: boolean,
    ScreenShakeIntensity: number,
    AutoPlay: boolean,
    SkipAnimations: boolean,
    ShowDamageNumbers: boolean,
    ShowCardTooltips: boolean,
    ChatEnabled: boolean,
    FriendRequestsEnabled: boolean,
    DataCollectionConsent: boolean
}

-- Pity System Data
export type PityData = {
    CommonPity: number,
    RarePity: number,
    EpicPity: number,
    LegendaryPity: number,
    MythicalPity: number,
    UltimatePity: number,
    LastLegendaryRoll: number,
    LastMythicalRoll: number,
    LastUltimateRoll: number,
    GuaranteedNext: string?, -- Rarity type
    RollHistory: {RollResult} -- Last 100 rolls
}

-- Roll Result
export type RollResult = {
    CardID: string,
    Rarity: string,
    RollTime: number,
    PityUsed: boolean,
    RollType: string -- "daily", "premium", "bonus"
}

-- Complete Player Data
export type PlayerData = {
    UserID: number,
    Username: string,
    Stats: PlayerStats,
    Collection: CardCollection,
    Progression: PlayerProgression,
    PityData: PityData,
    Economy: PlayerEconomy,
    Social: PlayerSocial,
    DataVersion: number,
    LastSaveTime: number,
    IsDirty: boolean -- For save optimization
}

-- Player Economy
export type PlayerEconomy = {
    Coins: number,
    Gems: number,
    DailyRolls: number,
    PremiumRolls: number,
    BattleTokens: number,
    LastDailyReward: number,
    LastWeeklyReward: number,
    PurchaseHistory: {PurchaseRecord},
    SpentTotal: number,
    EarnedTotal: number
}

-- Purchase Record
export type PurchaseRecord = {
    ProductID: string,
    ProductName: string,
    Price: number,
    Currency: string,
    PurchaseTime: number,
    DevProductID: number?
}

-- Player Social Data
export type PlayerSocial = {
    Friends: {number}, -- Array of UserIDs
    BlockedUsers: {number}, -- Array of UserIDs
    GuildID: string?,
    GuildRank: string?,
    RecentOpponents: {RecentOpponent},
    Reputation: number,
    ReportsMade: number,
    ReportsReceived: number,
    LastReportTime: number
}

-- Recent Opponent
export type RecentOpponent = {
    UserID: number,
    Username: string,
    BattleTime: number,
    BattleResult: string, -- "win", "loss", "draw"
    BattleRating: number?
}

-- Data Service Response Types
export type DataServiceResponse<T> = {
    Success: boolean,
    Data: T?,
    ErrorMessage: string?
}

export type SaveResult = {
    Success: boolean,
    SaveTime: number,
    ErrorMessage: string?
}

-- Player Session Data (runtime only)
export type PlayerSession = {
    UserID: number,
    SessionStartTime: number,
    LastActivityTime: number,
    ActiveBattleID: string?,
    CurrentLocation: string, -- "lobby", "battle", "collection", etc.
    PendingNotifications: {string},
    TempData: {[string]: any},
    IsAFK: boolean,
    AFKStartTime: number?
}

return {} 
--- FILE: ./src/shared/Types/RollTypes.luau ---
--!strict
-- RollTypes.luau
-- Type definitions for the card roll system with pity mechanics

local CardTypes = require(script.Parent.CardTypes)
local PlayerTypes = require(script.Parent.PlayerTypes)

type CardData = CardTypes.CardData

-- Roll Request Types
export type RollRequest = {
    Player: Player,
    RollType: RollType,
    Count: number,
    UseGuarantee: boolean?,
    SpecificRarity: string?
}

export type RollType = "Daily" | "Premium" | "Bonus" | "Event" | "Pity"

-- Roll Result Types
export type RollResult = {
    Success: boolean,
    Cards: {CardRollResult},
    TotalCards: number,
    PityUsed: {string}, -- Which pity types were used
    GuaranteeUsed: boolean,
    RollCost: RollCost,
    TimingData: RollTimingData,
    ErrorMessage: string?
}

export type CardRollResult = {
    Card: CardData,
    Rarity: string,
    IsNew: boolean,
    IsPityResult: boolean,
    PityCount: number,
    RollPosition: number, -- Position in the roll sequence
    AnimationDelay: number, -- Milliseconds delay for reveal
    EffectIntensity: number -- 0-1 for visual effects
}

export type RollCost = {
    Currency: string, -- "Coins", "Gems", "DailyRolls", "PremiumRolls"
    Amount: number,
    OriginalAmount: number,
    Discount: number?
}

export type RollTimingData = {
    RequestTime: number,
    ProcessTime: number,
    ResponseTime: number,
    OptimalRevealTime: number, -- Calculated optimal reveal timing
    PsychologicalDelay: number -- Additional delay for anticipation
}

-- Pity System Types
export type PityConfig = {
    SoftPityStart: number,
    HardPityLimit: number,
    SoftPityIncrease: number,
    BaseRate: number,
    MaxRate: number,
    RarityName: string
}

export type PityCalculation = {
    CurrentPity: number,
    SoftPityActive: boolean,
    HardPityActive: boolean,
    CurrentRate: number,
    BaseRate: number,
    NextGuaranteeIn: number
}

export type PitySystemState = {
    [string]: PityCalculation -- Rarity -> PityCalculation
}

-- Roll Animation Types
export type RollAnimation = {
    Duration: number,
    RevealSequence: {RevealStep},
    AudioCues: {AudioCue},
    VisualEffects: {VisualEffect}
}

export type RevealStep = {
    StepIndex: number,
    Delay: number,
    RevealType: string, -- "fade", "flip", "burst", "cascade"
    Intensity: number,
    AudioTrigger: string?
}

export type AudioCue = {
    SoundName: string,
    Timing: number,
    Frequency: number,
    Volume: number,
    Rarity: string?
}

export type VisualEffect = {
    EffectName: string,
    Timing: number,
    Duration: number,
    Intensity: number,
    Rarity: string?
}

-- Roll Statistics Types
export type RollSession = {
    SessionID: string,
    Player: Player,
    StartTime: number,
    EndTime: number?,
    TotalRolls: number,
    TotalCost: RollCost,
    CardsObtained: {CardRollResult},
    PityUsages: {string},
    AverageRevealTime: number,
    PsychologicalScore: number -- Engagement metric
}

export type RollStatistics = {
    TotalRolls: number,
    RollsByRarity: {[string]: number},
    AverageRollsPerRarity: {[string]: number},
    PityUsageRate: number,
    OptimalTimingHitRate: number,
    PlayerEngagementScore: number
}

-- Roll Economy Types
export type RollPricing = {
    DailyRolls: {
        Cost: number,
        Currency: string,
        Limit: number,
        ResetTime: number
    },
    PremiumRolls: {
        Cost: number,
        Currency: string,
        BonusMultiplier: number
    },
    BulkDiscounts: {BulkDiscount}
}

export type BulkDiscount = {
    Quantity: number,
    DiscountPercent: number,
    BonusRolls: number?
}

-- Roll Event Types
export type RollEvent = {
    EventID: string,
    EventName: string,
    StartTime: number,
    EndTime: number,
    RateBoosts: {[string]: number}, -- Rarity -> multiplier
    SpecialCards: {string}, -- Special event cards
    BonusRolls: number,
    EventCurrency: string?
}

-- Roll Validation Types
export type RollValidation = {
    IsValid: boolean,
    CanAfford: boolean,
    HasRollsRemaining: boolean,
    CooldownRemaining: number,
    ErrorReason: string?
}

-- Roll Queue Types (for high-load scenarios)
export type RollQueueItem = {
    RequestID: string,
    Player: Player,
    Request: RollRequest,
    Priority: number,
    QueueTime: number,
    EstimatedProcessTime: number
}

export type RollQueue = {
    Items: {RollQueueItem},
    ProcessingCount: number,
    AverageProcessTime: number,
    MaxQueueSize: number
}

-- Roll Analytics Types
export type RollAnalytics = {
    HourlyRolls: {[number]: number},
    PopularRarities: {[string]: number},
    PitySystemEfficiency: number,
    RevenuePerRoll: number,
    PlayerRetentionByRolls: {[number]: number}
}

-- Roll Configuration Types
export type RollSystemConfig = {
    PityConfigs: {[string]: PityConfig},
    TimingConfig: RollTimingConfig,
    AnimationConfig: RollAnimationConfig,
    EconomyConfig: RollEconomyConfig,
    ValidationConfig: RollValidationConfig
}

export type RollTimingConfig = {
    OptimalRevealBase: number, -- Base optimal reveal time (2000ms)
    PsychologicalDelayMin: number,
    PsychologicalDelayMax: number,
    RarityDelayMultiplier: {[string]: number},
    AnticipationBuildupTime: number,
    SatisfactionHoldTime: number
}

export type RollAnimationConfig = {
    DefaultDuration: number,
    RarityDurations: {[string]: number},
    EffectIntensities: {[string]: number},
    AudioFrequencies: {[string]: number},
    VisualLayers: {[string]: number}
}

export type RollEconomyConfig = {
    DailyRollCount: number,
    PremiumRollCost: number,
    BulkDiscountTiers: {BulkDiscount},
    EventMultipliers: {[string]: number}
}

export type RollValidationConfig = {
    MaxRollsPerSecond: number,
    MaxRollsPerMinute: number,
    CooldownBetweenRolls: number,
    MaxConcurrentRolls: number,
    AntiCheatValidation: boolean
}

-- Service Response Types
export type RollServiceResponse<T> = {
    Success: boolean,
    Data: T?,
    ErrorMessage: string?,
    ProcessingTime: number,
    RequestID: string?
}

return {} 
--- FILE: ./src/shared/Core/RemoteEventHandler.luau ---
--!strict
-- RemoteEventHandler.luau
-- Handles all client-server communication
-- Provides type-safe remote event and remote function management

local RemoteEventHandler = {}
RemoteEventHandler.__index = RemoteEventHandler

-- Services
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

-- Constants
local REMOTE_EVENTS_FOLDER = "RemoteEvents"
local REMOTE_FUNCTIONS_FOLDER = "RemoteFunctions"

-- Storage
local remoteEvents: {[string]: RemoteEvent} = {}
local remoteFunctions: {[string]: RemoteFunction} = {}
local initialized = false

-- Debug logging
local DEBUG_ENABLED = RunService:IsStudio()

local function debugLog(message: string, data: any?)
	if not DEBUG_ENABLED then return end
	
	local timestamp = os.date("%H:%M:%S")
	if data then
		print(string.format("[%s] [RemoteEventHandler] %s", timestamp, message), data)
	else
		print(string.format("[%s] [RemoteEventHandler] %s", timestamp, message))
	end
end

-- Initialize remote event folders
local function initializeFolders()
	if initialized then return end
	
	-- Create remote events folder
	local remoteEventsFolder = ReplicatedStorage:FindFirstChild(REMOTE_EVENTS_FOLDER)
	if not remoteEventsFolder then
		remoteEventsFolder = Instance.new("Folder")
		remoteEventsFolder.Name = REMOTE_EVENTS_FOLDER
		remoteEventsFolder.Parent = ReplicatedStorage
	end
	
	-- Create remote functions folder
	local remoteFunctionsFolder = ReplicatedStorage:FindFirstChild(REMOTE_FUNCTIONS_FOLDER)
	if not remoteFunctionsFolder then
		remoteFunctionsFolder = Instance.new("Folder")
		remoteFunctionsFolder.Name = REMOTE_FUNCTIONS_FOLDER
		remoteFunctionsFolder.Parent = ReplicatedStorage
	end
	
	initialized = true
	debugLog("Remote event folders initialized")
end

-- Get or create remote event
function RemoteEventHandler:GetRemoteEvent(eventName: string): RemoteEvent
	assert(type(eventName) == "string", "Event name must be a string")
	
	initializeFolders()
	
	-- Check cache first
	if remoteEvents[eventName] then
		return remoteEvents[eventName]
	end
	
	-- Get folder
	local folder = ReplicatedStorage:FindFirstChild(REMOTE_EVENTS_FOLDER)
	if not folder then
		error("Remote events folder not found")
	end
	
	-- Find or create remote event
	local remoteEvent = folder:FindFirstChild(eventName)
	if not remoteEvent then
		if RunService:IsServer() then
			-- Server creates the remote event
			remoteEvent = Instance.new("RemoteEvent")
			remoteEvent.Name = eventName
			remoteEvent.Parent = folder
			debugLog("Created remote event: " .. eventName)
		else
			-- Client waits for remote event
			debugLog("Waiting for remote event: " .. eventName)
			remoteEvent = folder:WaitForChild(eventName)
		end
	end
	
	-- Cache and return
	remoteEvents[eventName] = remoteEvent
	return remoteEvent
end

-- Get or create remote function
function RemoteEventHandler:GetRemoteFunction(functionName: string): RemoteFunction
	assert(type(functionName) == "string", "Function name must be a string")
	
	initializeFolders()
	
	-- Check cache first
	if remoteFunctions[functionName] then
		return remoteFunctions[functionName]
	end
	
	-- Get folder
	local folder = ReplicatedStorage:FindFirstChild(REMOTE_FUNCTIONS_FOLDER)
	if not folder then
		error("Remote functions folder not found")
	end
	
	-- Find or create remote function
	local remoteFunction = folder:FindFirstChild(functionName)
	if not remoteFunction then
		if RunService:IsServer() then
			-- Server creates the remote function
			remoteFunction = Instance.new("RemoteFunction")
			remoteFunction.Name = functionName
			remoteFunction.Parent = folder
			debugLog("Created remote function: " .. functionName)
		else
			-- Client waits for remote function
			debugLog("Waiting for remote function: " .. functionName)
			remoteFunction = folder:WaitForChild(functionName)
		end
	end
	
	-- Cache and return
	remoteFunctions[functionName] = remoteFunction
	return remoteFunction
end

-- Server-side methods
function RemoteEventHandler:ConnectRemoteEvent(eventName: string, callback: (player: Player, ...any) -> ()): RBXScriptConnection
	if not RunService:IsServer() then
		error("ConnectRemoteEvent can only be called on the server")
	end
	
	local remoteEvent = self:GetRemoteEvent(eventName)
	debugLog("Connected server callback for event: " .. eventName)
	
	return remoteEvent.OnServerEvent:Connect(callback)
end

function RemoteEventHandler:BindRemoteFunction(functionName: string, callback: (player: Player, ...any) -> ...any)
	if not RunService:IsServer() then
		error("BindRemoteFunction can only be called on the server")
	end
	
	local remoteFunction = self:GetRemoteFunction(functionName)
	remoteFunction.OnServerInvoke = callback
	debugLog("Bound server callback for function: " .. functionName)
end

function RemoteEventHandler:FireClient(player: Player, eventName: string, ...): ()
	if not RunService:IsServer() then
		error("FireClient can only be called on the server")
	end
	
	local remoteEvent = self:GetRemoteEvent(eventName)
	remoteEvent:FireClient(player, ...)
end

function RemoteEventHandler:FireAllClients(eventName: string, ...): ()
	if not RunService:IsServer() then
		error("FireAllClients can only be called on the server")
	end
	
	local remoteEvent = self:GetRemoteEvent(eventName)
	remoteEvent:FireAllClients(...)
end

-- Client-side methods
function RemoteEventHandler:ConnectRemoteEventClient(eventName: string, callback: (...any) -> ()): RBXScriptConnection
	if RunService:IsServer() then
		error("ConnectRemoteEventClient can only be called on the client")
	end
	
	local remoteEvent = self:GetRemoteEvent(eventName)
	debugLog("Connected client callback for event: " .. eventName)
	
	return remoteEvent.OnClientEvent:Connect(callback)
end

function RemoteEventHandler:FireServer(eventName: string, ...): ()
	if RunService:IsServer() then
		error("FireServer can only be called on the client")
	end
	
	local remoteEvent = self:GetRemoteEvent(eventName)
	remoteEvent:FireServer(...)
end

function RemoteEventHandler:InvokeServer(functionName: string, ...): ...any
	if RunService:IsServer() then
		error("InvokeServer can only be called on the client")
	end
	
	local remoteFunction = self:GetRemoteFunction(functionName)
	return remoteFunction:InvokeServer(...)
end

-- Utility methods
function RemoteEventHandler:GetAllRemoteEvents(): {[string]: RemoteEvent}
	local eventsCopy = {}
	for name, event in pairs(remoteEvents) do
		eventsCopy[name] = event
	end
	return eventsCopy
end

function RemoteEventHandler:GetAllRemoteFunctions(): {[string]: RemoteFunction}
	local functionsCopy = {}
	for name, func in pairs(remoteFunctions) do
		functionsCopy[name] = func
	end
	return functionsCopy
end

function RemoteEventHandler:Cleanup()
	-- Clear caches
	table.clear(remoteEvents)
	table.clear(remoteFunctions)
	
	-- Remove folders if server
	if RunService:IsServer() then
		local remoteEventsFolder = ReplicatedStorage:FindFirstChild(REMOTE_EVENTS_FOLDER)
		if remoteEventsFolder then
			remoteEventsFolder:Destroy()
		end
		
		local remoteFunctionsFolder = ReplicatedStorage:FindFirstChild(REMOTE_FUNCTIONS_FOLDER)
		if remoteFunctionsFolder then
			remoteFunctionsFolder:Destroy()
		end
	end
	
	initialized = false
	debugLog("RemoteEventHandler cleaned up")
end

-- Export
return RemoteEventHandler 
--- FILE: ./src/shared/Core/BaseService.luau ---
--!strict
-- BaseService.luau
-- Base class for all server-side services
-- Provides common functionality and lifecycle management

local BaseService = {}
BaseService.__index = BaseService

-- Service lifecycle states
export type ServiceState = "Uninitialized" | "Initializing" | "Initialized" | "Starting" | "Started" | "Stopped" | "Error"

-- Base service type
export type BaseService = {
	Name: string,
	Dependencies: {string}?,
	
	Initialize: (self: BaseService) -> (),
	Start: (self: BaseService) -> (),
	Stop: (self: BaseService) -> (),
	Cleanup: (self: BaseService) -> (),
	
	_connections: {RBXScriptConnection},
	_isService: boolean,
	_state: ServiceState,
}

-- Constructor
function BaseService.new(name: string, dependencies: {string}?): BaseService
	local self = setmetatable({}, BaseService)
	
	self.Name = name
	self.Dependencies = dependencies or {}
	self._connections = {}
	self._isService = true
	self._state = "Uninitialized"
	
	return self
end

-- Lifecycle methods (to be overridden by subclasses)
function BaseService:Initialize()
	-- Override in subclasses
end

function BaseService:Start()
	-- Override in subclasses
end

function BaseService:Stop()
	-- Override in subclasses
	self:_disconnectAll()
end

function BaseService:Cleanup()
	self:Stop()
	
	-- Clear all references
	table.clear(self._connections)
	self._state = "Stopped"
end

-- Utility methods
function BaseService:_connectEvent(event: RBXScriptSignal, callback: (...any) -> ()): RBXScriptConnection
	local connection = event:Connect(callback)
	table.insert(self._connections, connection)
	return connection
end

function BaseService:_disconnectAll()
	for _, connection in ipairs(self._connections) do
		if connection.Connected then
			connection:Disconnect()
		end
	end
	table.clear(self._connections)
end

-- State management
function BaseService:GetState(): ServiceState
	return self._state
end

function BaseService:_setState(state: ServiceState)
	self._state = state
end

-- Debug logging
function BaseService:_log(message: string, data: any?)
	if not game:GetService("RunService"):IsStudio() then return end
	
	local timestamp = os.date("%H:%M:%S")
	if data then
		print(string.format("[%s] [%s] %s", timestamp, self.Name, message), data)
	else
		print(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

function BaseService:_warn(message: string, data: any?)
	local timestamp = os.date("%H:%M:%S")
	if data then
		warn(string.format("[%s] [%s] %s", timestamp, self.Name, message), data)
	else
		warn(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

function BaseService:_logError(message: string)
	warn(string.format("[%s] ERROR: %s", self.Name, message))
end

function BaseService:_error(message: string, data: any?)
	local timestamp = os.date("%H:%M:%S")
	if data then
		error(string.format("[%s] [%s] %s", timestamp, self.Name, message) .. " " .. tostring(data))
	else
		error(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

-- Export
return BaseService 
--- FILE: ./src/shared/Core/BaseController.luau ---
--!strict
-- BaseController.luau
-- Base class for all client-side controllers
-- Provides common functionality and lifecycle management

local BaseController = {}
BaseController.__index = BaseController

-- Controller lifecycle states
export type ControllerState = "Uninitialized" | "Initializing" | "Initialized" | "Starting" | "Started" | "Stopped" | "Error"

-- Base controller type
export type BaseController = {
	Name: string,
	Dependencies: {string}?,
	
	Initialize: (self: BaseController) -> (),
	Start: (self: BaseController) -> (),
	Stop: (self: BaseController) -> (),
	Cleanup: (self: BaseController) -> (),
	
	_connections: {RBXScriptConnection},
	_isController: boolean,
	_state: ControllerState,
}

-- Constructor
function BaseController.new(name: string, dependencies: {string}?): BaseController
	local self = setmetatable({}, BaseController)
	
	self.Name = name
	self.Dependencies = dependencies or {}
	self._connections = {}
	self._isController = true
	self._state = "Uninitialized"
	
	return self
end

-- Lifecycle methods (to be overridden by subclasses)
function BaseController:Initialize()
	-- Override in subclasses
end

function BaseController:Start()
	-- Override in subclasses
end

function BaseController:Stop()
	-- Override in subclasses
	self:_disconnectAll()
end

function BaseController:Cleanup()
	self:Stop()
	
	-- Clear all references
	table.clear(self._connections)
	self._state = "Stopped"
end

-- Utility methods
function BaseController:_connectEvent(event: RBXScriptSignal, callback: (...any) -> ()): RBXScriptConnection
	local connection = event:Connect(callback)
	table.insert(self._connections, connection)
	return connection
end

function BaseController:_disconnectAll()
	for _, connection in ipairs(self._connections) do
		if connection.Connected then
			connection:Disconnect()
		end
	end
	table.clear(self._connections)
end

-- Input handling utilities
function BaseController:_connectInput(inputType: Enum.KeyCode | Enum.UserInputType, callback: () -> ()): RBXScriptConnection
	local UserInputService = game:GetService("UserInputService")
	
	local connection = UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end
		
		if input.KeyCode == inputType or input.UserInputType == inputType then
			callback()
		end
	end)
	
	table.insert(self._connections, connection)
	return connection
end

function BaseController:_connectTouchInput(guiObject: GuiObject, callback: () -> ()): RBXScriptConnection
	local connection = guiObject.Activated:Connect(callback)
	table.insert(self._connections, connection)
	return connection
end

-- State management
function BaseController:GetState(): ControllerState
	return self._state
end

function BaseController:_setState(state: ControllerState)
	self._state = state
end

-- Debug logging
function BaseController:_log(message: string, data: any?)
	if not game:GetService("RunService"):IsStudio() then return end
	
	local timestamp = os.date("%H:%M:%S")
	if data then
		print(string.format("[%s] [%s] %s", timestamp, self.Name, message), data)
	else
		print(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

function BaseController:_warn(message: string, data: any?)
	local timestamp = os.date("%H:%M:%S")
	if data then
		warn(string.format("[%s] [%s] %s", timestamp, self.Name, message), data)
	else
		warn(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

function BaseController:_error(message: string, data: any?)
	local timestamp = os.date("%H:%M:%S")
	if data then
		error(string.format("[%s] [%s] %s", timestamp, self.Name, message) .. " " .. tostring(data))
	else
		error(string.format("[%s] [%s] %s", timestamp, self.Name, message))
	end
end

-- Export
return BaseController 
--- FILE: ./src/shared/Core/ServiceRegistry.luau ---
--!strict
-- ServiceRegistry.luau
-- Core service registry for modular architecture
-- Handles service initialization, dependencies, and lifecycle management

local ServiceRegistry = {}
ServiceRegistry.__index = ServiceRegistry

-- Service states
local ServiceState = {
	Uninitialized = "Uninitialized",
	Initializing = "Initializing", 
	Initialized = "Initialized",
	Starting = "Starting",
	Started = "Started",
	Stopped = "Stopped",
	Error = "Error"
}

-- Private storage
local services = {}
local serviceStates = {}
local initializationQueue = {}
local isStarted = false

-- Debug logging
local DEBUG_ENABLED = game:GetService("RunService"):IsStudio()

local function debugLog(message: string, data: any?)
	if not DEBUG_ENABLED then return end
	
	local timestamp = os.date("%H:%M:%S")
	if data then
		print(string.format("[%s] [ServiceRegistry] %s", timestamp, message), data)
	else
		print(string.format("[%s] [ServiceRegistry] %s", timestamp, message))
	end
end

-- Service registry methods
function ServiceRegistry:RegisterService(serviceName: string, service: any): any
	assert(type(serviceName) == "string", "Service name must be a string")
	assert(service, "Service cannot be nil")
	assert(not services[serviceName], "Service already exists: " .. serviceName)
	assert(not isStarted, "Cannot register services after ServiceRegistry has started")
	
	-- Set service metadata
	service.Name = serviceName
	service._isService = true
	service.ServiceRegistry = ServiceRegistry -- Add this line so services can access other services
	
	-- Store service
	services[serviceName] = service
	serviceStates[serviceName] = ServiceState.Uninitialized
	
	debugLog("Registered service: " .. serviceName)
	return service
end

function ServiceRegistry:GetService(serviceName: string): any
	assert(type(serviceName) == "string", "Service name must be a string")
	
	local service = services[serviceName]
	if not service then
		error("Service not found: " .. serviceName)
	end
	
	return service
end

function ServiceRegistry:GetServiceState(serviceName: string): string
	assert(type(serviceName) == "string", "Service name must be a string")
	return serviceStates[serviceName] or ServiceState.Uninitialized
end

function ServiceRegistry:GetAllServices(): {[string]: any}
	local servicesCopy = {}
	for name, service in pairs(services) do
		servicesCopy[name] = service
	end
	return servicesCopy
end

function ServiceRegistry:InitializeAll(): boolean
	if isStarted then
		warn("ServiceRegistry already started")
		return false
	end
	
	debugLog("Initializing all services...")
	
	-- Initialize services with dependency resolution
	local initialized = {}
	local function initializeService(serviceName: string)
		if initialized[serviceName] then
			return true
		end
		
		local service = services[serviceName]
		if not service then
			error("Service not found during initialization: " .. serviceName)
		end
		
		-- Skip if already initialized
		if serviceStates[serviceName] == ServiceState.Initialized then
			initialized[serviceName] = true
			return true
		end
		
		-- Set initializing state
		serviceStates[serviceName] = ServiceState.Initializing
		debugLog("Initializing service: " .. serviceName)
		
		-- Initialize dependencies first
		if service.Dependencies then
			for _, depName in ipairs(service.Dependencies) do
				if not initializeService(depName) then
					serviceStates[serviceName] = ServiceState.Error
					error("Failed to initialize dependency: " .. depName .. " for service: " .. serviceName)
				end
			end
		end
		
		-- Initialize the service
		local success, result = pcall(function()
			if service.Initialize then
				service:Initialize()
			end
		end)
		
		if success then
			serviceStates[serviceName] = ServiceState.Initialized
			initialized[serviceName] = true
			debugLog("Successfully initialized service: " .. serviceName)
			return true
		else
			serviceStates[serviceName] = ServiceState.Error
			error("Failed to initialize service: " .. serviceName .. " - " .. tostring(result))
		end
	end
	
	-- Initialize all services
	for serviceName in pairs(services) do
		if not initialized[serviceName] then
			initializeService(serviceName)
		end
	end
	
	debugLog("All services initialized successfully")
	return true
end

function ServiceRegistry:StartAll(): boolean
	if isStarted then
		warn("ServiceRegistry already started")
		return false
	end
	
	debugLog("Starting all services...")
	
	-- Start all services
	for serviceName, service in pairs(services) do
		if serviceStates[serviceName] == ServiceState.Initialized then
			serviceStates[serviceName] = ServiceState.Starting
			debugLog("Starting service: " .. serviceName)
			
			local success, result = pcall(function()
				if service.Start then
					service:Start()
				end
			end)
			
			if success then
				serviceStates[serviceName] = ServiceState.Started
				debugLog("Successfully started service: " .. serviceName)
			else
				serviceStates[serviceName] = ServiceState.Error
				error("Failed to start service: " .. serviceName .. " - " .. tostring(result))
			end
		end
	end
	
	isStarted = true
	debugLog("All services started successfully")
	return true
end

function ServiceRegistry:StopAll(): boolean
	if not isStarted then
		warn("ServiceRegistry not started")
		return false
	end
	
	debugLog("Stopping all services...")
	
	-- Stop all services in reverse order
	local serviceNames = {}
	for serviceName in pairs(services) do
		table.insert(serviceNames, serviceName)
	end
	
	for i = #serviceNames, 1, -1 do
		local serviceName = serviceNames[i]
		local service = services[serviceName]
		
		if serviceStates[serviceName] == ServiceState.Started then
			debugLog("Stopping service: " .. serviceName)
			
			local success, result = pcall(function()
				if service.Stop then
					service:Stop()
				end
			end)
			
			if success then
				serviceStates[serviceName] = ServiceState.Stopped
				debugLog("Successfully stopped service: " .. serviceName)
			else
				serviceStates[serviceName] = ServiceState.Error
				warn("Failed to stop service: " .. serviceName .. " - " .. tostring(result))
			end
		end
	end
	
	isStarted = false
	debugLog("All services stopped")
	return true
end

-- Cleanup
function ServiceRegistry:Cleanup()
	self:StopAll()
	
	-- Clear all references
	table.clear(services)
	table.clear(serviceStates)
	table.clear(initializationQueue)
	
	debugLog("ServiceRegistry cleaned up")
end

-- Export
return ServiceRegistry 
--- FILE: ./src/shared/Constants/GameConstants.luau ---
--!strict
-- GameConstants.luau
-- All game constants in one place
-- Based on industry research and optimization data

local GameConstants = {}

-- Card Rarities
GameConstants.Rarity = {
	Common = "Common",
	Uncommon = "Uncommon", 
	Rare = "Rare",
	Epic = "Epic",
	Legendary = "Legendary",
	Ultimate = "Ultimate"
}

-- Rarity Colors (Industry Standard)
GameConstants.RarityColors = {
	Common = Color3.fromRGB(255, 255, 255), -- #ffffff
	Uncommon = Color3.fromRGB(30, 255, 0), -- #1eff00
	Rare = Color3.fromRGB(0, 112, 221), -- #0070dd
	Epic = Color3.fromRGB(163, 53, 238), -- #a335ee
	Legendary = Color3.fromRGB(255, 128, 0), -- #ff8000
	Ultimate = Color3.fromRGB(255, 0, 255) -- #ff00ff (Custom)
}

-- Animation Timings (Based on Research)
GameConstants.AnimationTiming = {
	-- Card Animations
	CardDraw = 0.3, -- 250-400ms optimal
	CardPlay = 0.25, -- 200-350ms optimal
	CardReveal = 1.0, -- 0.8-1.2s for rarity reveal
	
	-- Attack Phases
	AttackAnticipation = 0.2, -- 200ms
	AttackStrike = 0.15, -- 150ms
	AttackReturn = 0.25, -- 250ms
	
	-- Impact Frames (60fps)
	LightImpact = 0.05, -- 3 frames
	MediumImpact = 0.1, -- 6 frames
	HeavyImpact = 0.2, -- 12 frames
	UltimateImpact = 0.3, -- 18 frames
	
	-- UI Transitions
	UIFadeIn = 0.15,
	UIFadeOut = 0.1,
	ScreenTransition = 0.3
}

-- Screen Shake Parameters (Trauma System)
GameConstants.ScreenShake = {
	TraumaPower = 2.5, -- 2-3 optimal
	DecayRate = 0.8, -- 0.8 standard
	MaxRotation = 0.1, -- 0.1 radians
	
	-- Intensity by impact
	Light = 0.1, -- 2-4 pixel displacement
	Medium = 0.3, -- 6-10 pixel displacement
	Heavy = 0.6, -- 12-20 pixel displacement
	Ultimate = 1.0 -- Maximum trauma
}

-- Audio Settings
GameConstants.Audio = {
	-- Volume levels
	MasterVolume = 0.8,
	SFXVolume = 0.7,
	MusicVolume = 0.5,
	
	-- Timing precision
	AudioSyncWindow = 0.002, -- 2ms for perceived simultaneity
	
	-- Frequency ranges
	SubBass = {20, 60}, -- Visceral impact
	MidBass = {60, 250}, -- Weight and power
	Presence = {1000, 4000}, -- Clarity and cut
	Brilliance = {4000, 16000} -- Sparkle and magic
}

-- Performance Settings
GameConstants.Performance = {
	-- Mobile optimization
	MaxConcurrentTweens = 50,
	MaxParticles = 100,
	TextureMemoryLimit = 50 * 1024 * 1024, -- 50MB
	
	-- Frame rate targets
	TargetFPS = 60,
	MinimumFPS = 30,
	
	-- LOD distances
	HighDetailRadius = 100,
	MediumDetailRadius = 300,
	LowDetailRadius = 500
}

GameConstants.Settings = {
	AutoSaveInterval = 300,
	DefaultVolume = 0.5
}

-- UI Sizing (Mobile-First)
GameConstants.UI = {
	-- Touch targets
	MinTouchTarget = 44, -- iOS minimum
	AndroidMinTouchTarget = 48, -- Android minimum
	
	-- Card sizing (percentage of screen width)
	CardWidthPercent = 0.22, -- 20-25% optimal
	CardAspectRatio = 3/4, -- 3:4 standard
	
	-- Safe areas
	TopSafeArea = 0.1, -- 10% of screen
	BottomSafeArea = 0.25, -- 25% for card hand
	SideSafeArea = 0.05, -- 5% each side
	
	-- Spacing
	CardSpacing = 8, -- 8px minimum
	UIMargin = 16, -- 16px standard
	ButtonPadding = 12 -- 12px standard
}

-- Game Balance
GameConstants.Balance = {
	-- Starting values
	StartingLevel = 1,
	StartingRolls = 0,
	StartingCards = 0,
	
	-- Progression
	RollsPerLevel = 50, -- Estimated from research
	MaxLevel = 100,
	
	-- Pity system
	PityThreshold = 50, -- Rolls before pity kicks in
	PityIncrement = 0.1, -- 10% increase per roll
	
	-- Base drop rates (before pity)
	BaseDropRates = {
		Common = 0.70, -- 70%
		Uncommon = 0.20, -- 20%
		Rare = 0.07, -- 7%
		Epic = 0.025, -- 2.5%
		Legendary = 0.005, -- 0.5%
		Ultimate = 0.0001 -- 0.01%
	}
}

-- Battle System
GameConstants.Battle = {
	-- HP values
	PlayerHP = 100,
	EnemyBaseHP = 100,
	
	-- Turn timing
	TurnDuration = 30, -- 30 seconds per turn
	AnimationBuffer = 2, -- 2 seconds for animations
	
	-- Deck limits
	MinDeckSize = 20,
	MaxDeckSize = 40,
	HandSize = 5,
	
	-- Damage scaling
	BaseDamage = 10,
	LevelScaling = 1.1 -- 10% per level
}

-- Remote Events
GameConstants.RemoteEvents = {
	-- Card system
	RollCard = "RollCard",
	CardRolled = "CardRolled",
	
	-- Battle system
	StartBattle = "StartBattle",
	PlayCard = "PlayCard",
	EndBattle = "EndBattle",
	
	-- Player data
	PlayerDataChanged = "PlayerDataChanged",
	SavePlayerData = "SavePlayerData"
}

-- Debug Settings
GameConstants.Debug = {
	EnableLogging = true,
	LogLevel = "INFO", -- DEBUG, INFO, WARN, ERROR
	ShowFPS = true,
	ShowMemory = true,
	EnableCheats = false
}

-- Economy
-- Correct placement for the Economy table
GameConstants.Economy = {
	RollCosts = {
		Standard = 100,
		Premium = 500,
	}
}

-- Export
return GameConstants 
--- FILE: ./src/shared/Utils/TableUtils.luau ---
--!strict
-- TableUtils.luau
-- Utility functions for table operations

local TableUtils = {}

-- Deep copy a table
function TableUtils.deepCopy(original: any): any
	local copy: any
	
	if type(original) == "table" then
		copy = {}
		for key, value in pairs(original) do
			copy[TableUtils.deepCopy(key)] = TableUtils.deepCopy(value)
		end
	else
		copy = original
	end
	
	return copy
end

-- Merge two tables
function TableUtils.merge(target: {[any]: any}, source: {[any]: any}): {[any]: any}
	for key, value in pairs(source) do
		target[key] = value
	end
	return target
end

-- Check if table is empty
function TableUtils.isEmpty(tbl: {[any]: any}): boolean
	return next(tbl) == nil
end

-- Get table size
function TableUtils.getSize(tbl: {[any]: any}): number
	local count = 0
	for _ in pairs(tbl) do
		count += 1
	end
	return count
end

-- Get random element from table
function TableUtils.getRandom(tbl: {any}): any
	if #tbl == 0 then
		return nil
	end
	
	local randomIndex = math.random(1, #tbl)
	return tbl[randomIndex]
end

-- Get table keys
function TableUtils.getKeys(tbl: {[any]: any}): {any}
	local keys = {}
	for key in pairs(tbl) do
		table.insert(keys, key)
	end
	return keys
end

-- Get table values
function TableUtils.getValues(tbl: {[any]: any}): {any}
	local values = {}
	for _, value in pairs(tbl) do
		table.insert(values, value)
	end
	return values
end

-- Filter table by predicate
function TableUtils.filter(tbl: {any}, predicate: (any) -> boolean): {any}
	local filtered = {}
	for _, value in ipairs(tbl) do
		if predicate(value) then
			table.insert(filtered, value)
		end
	end
	return filtered
end

-- Map table with function
function TableUtils.map(tbl: {any}, func: (any) -> any): {any}
	local mapped = {}
	for i, value in ipairs(tbl) do
		mapped[i] = func(value)
	end
	return mapped
end

-- Find element in table
function TableUtils.find(tbl: {any}, predicate: (any) -> boolean): any
	for _, value in ipairs(tbl) do
		if predicate(value) then
			return value
		end
	end
	return nil
end

-- Shuffle table (Fisher-Yates algorithm)
function TableUtils.shuffle(tbl: {any}): {any}
	local shuffled = TableUtils.deepCopy(tbl)
	
	for i = #shuffled, 2, -1 do
		local j = math.random(i)
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	end
	
	return shuffled
end

-- Clear table
function TableUtils.clear(tbl: {[any]: any}): {[any]: any}
	table.clear(tbl)
	return tbl
end

-- Export
return TableUtils 
--- FILE: ./src/shared/Data/CardDatabase.luau ---
--!strict
-- CardDatabase.luau
-- Main interface for card database with validation and rarity management
-- Incorporates research-based drop rates and psychological timing

local GameConstants = require(script.Parent.Parent.Constants.GameConstants)
local CardTypes = require(script.Parent.Parent.Types.CardTypes)
local AnimeCharacters = require(script.Parent.AnimeCharacters)
local TableUtils = require(script.Parent.Parent.Utils.TableUtils)

local CardDatabase = {}

-- Private card registry
local cardRegistry: {[string]: CardTypes.CardData} = {}
local rarityGroups: {[string]: {CardTypes.CardData}} = {}
local seriesGroups: {[string]: {CardTypes.CardData}} = {}
local typeGroups: {[string]: {CardTypes.CardData}} = {}

-- Initialize the database
local function initializeDatabase()
	-- Clear existing data
	table.clear(cardRegistry)
	table.clear(rarityGroups)
	table.clear(seriesGroups)
	table.clear(typeGroups)
	
	-- Load all characters
	local allCharacters = AnimeCharacters:GetAllCharacters()
	
	-- Register each card and organize by groups
	for _, cardData in ipairs(allCharacters) do
		-- Validate card data
		if CardDatabase:ValidateCardData(cardData) then
			-- Register card
			cardRegistry[cardData.ID] = cardData
			
			-- Group by rarity
			if not rarityGroups[cardData.Rarity] then
				rarityGroups[cardData.Rarity] = {}
			end
			table.insert(rarityGroups[cardData.Rarity], cardData)
			
			-- Group by series
			if not seriesGroups[cardData.Series] then
				seriesGroups[cardData.Series] = {}
			end
			table.insert(seriesGroups[cardData.Series], cardData)
			
			-- Group by type
			if not typeGroups[cardData.Type] then
				typeGroups[cardData.Type] = {}
			end
			table.insert(typeGroups[cardData.Type], cardData)
		else
			warn("Invalid card data for ID:", cardData.ID)
		end
	end
	
	print("📋 Card Database initialized with", TableUtils.getSize(cardRegistry), "cards")
	
	-- Print statistics
	for rarity, cards in pairs(rarityGroups) do
		print(string.format("   %s: %d cards", rarity, #cards))
	end
end

-- Card lookup functions
function CardDatabase:GetCard(cardID: string): CardTypes.CardData?
	return cardRegistry[cardID]
end

function CardDatabase:GetAllCards(): {[string]: CardTypes.CardData}
	return TableUtils.deepCopy(cardRegistry)
end

function CardDatabase:GetCardsByRarity(rarity: CardTypes.CardRarity): {CardTypes.CardData}
	return TableUtils.deepCopy(rarityGroups[rarity] or {})
end

function CardDatabase:GetCardsBySeries(series: CardTypes.CardSeries): {CardTypes.CardData}
	return TableUtils.deepCopy(seriesGroups[series] or {})
end

function CardDatabase:GetCardsByType(cardType: CardTypes.CardType): {CardTypes.CardData}
	return TableUtils.deepCopy(typeGroups[cardType] or {})
end

-- Random card selection with weighted probabilities
function CardDatabase:GetRandomCard(rarity: string): CardTypes.CardData?
	if not rarityGroups[rarity] then
		warn("No cards found for rarity: " .. rarity)
		
		-- Fallback to Common if the requested rarity has no cards
		if rarityGroups["Common"] and #rarityGroups["Common"] > 0 then
			local cardsOfRarity = rarityGroups["Common"]
			local randomIndex = math.random(1, #cardsOfRarity)
			return cardsOfRarity[randomIndex]
		end
		
		return nil
	end
	
	local cardsOfRarity = rarityGroups[rarity]
	if #cardsOfRarity == 0 then
		warn("No cards in rarity table: " .. rarity)
		return nil
	end
	
	local randomIndex = math.random(1, #cardsOfRarity)
	return cardsOfRarity[randomIndex]
end

-- Get multiple random cards (for packs)
function CardDatabase:GetRandomCards(count: number, rarityWeights: {[string]: number}?): {CardTypes.CardData}
	local cards = {}
	
	for i = 1, count do
		local card = self:GetRandomCard(rarityWeights)
		if card then
			table.insert(cards, card)
		end
	end
	
	return cards
end

-- Rarity calculation with pity system
function CardDatabase:CalculateRarityWeights(playerLevel: number, rollsSinceLastRare: number, rollsSinceLastEpic: number, rollsSinceLastLegendary: number): {[string]: number}
	local weights = TableUtils.deepCopy(GameConstants.Balance.BaseDropRates)
	
	-- Level-based improvements (research shows players expect progression)
	local levelBonus = math.min(playerLevel * 0.005, 0.1) -- Cap at 10% bonus
	weights.Rare = weights.Rare + levelBonus
	weights.Epic = weights.Epic + (levelBonus * 0.5)
	weights.Legendary = weights.Legendary + (levelBonus * 0.2)
	
	-- Pity system (based on research: prevent frustration, encourage continued play)
	-- Rare pity kicks in after 20 rolls
	if rollsSinceLastRare >= 20 then
		local rarePityBonus = math.min((rollsSinceLastRare - 20) * 0.02, 0.3) -- Up to 30% bonus
		weights.Rare = weights.Rare + rarePityBonus
		weights.Common = weights.Common - rarePityBonus -- Reduce common to compensate
	end
	
	-- Epic pity kicks in after 50 rolls  
	if rollsSinceLastEpic >= 50 then
		local epicPityBonus = math.min((rollsSinceLastEpic - 50) * 0.005, 0.1) -- Up to 10% bonus
		weights.Epic = weights.Epic + epicPityBonus
		weights.Common = weights.Common - epicPityBonus
	end
	
	-- Legendary pity (research shows 74-90 roll guarantee optimal)
	if rollsSinceLastLegendary >= 74 then
		local legendaryPityBonus = math.min((rollsSinceLastLegendary - 74) * 0.02, 0.32) -- Soft pity 32%
		weights.Legendary = weights.Legendary + legendaryPityBonus
		weights.Common = weights.Common - (legendaryPityBonus * 0.5)
		weights.Uncommon = weights.Uncommon - (legendaryPityBonus * 0.3)
		weights.Rare = weights.Rare - (legendaryPityBonus * 0.2)
	end
	
	-- Guaranteed legendary at 90 rolls (based on Genshin research)
	if rollsSinceLastLegendary >= 90 then
		weights.Legendary = 1.0
		weights.Common = 0
		weights.Uncommon = 0
		weights.Rare = 0
		weights.Epic = 0
		weights.Ultimate = 0
	end
	
	-- Ultimate rarity is extremely rare and not affected by pity
	-- Only available from special events or perfect luck
	
	-- Ensure weights don't go below 0
	for rarity, weight in pairs(weights) do
		weights[rarity] = math.max(weight, 0)
	end
	
	return weights
end

-- Card validation
function CardDatabase:ValidateCardData(cardData: CardTypes.CardData): boolean
	-- Check required fields
	if not cardData.ID or type(cardData.ID) ~= "string" or cardData.ID == "" then
		return false
	end
	
	if not cardData.Name or type(cardData.Name) ~= "string" or cardData.Name == "" then
		return false
	end
	
	-- Validate rarity
	if not self:IsValidRarity(cardData.Rarity) then
		return false
	end
	
	-- Validate series
	if not self:IsValidSeries(cardData.Series) then
		return false
	end
	
	-- Validate type
	if not self:IsValidType(cardData.Type) then
		return false
	end
	
	-- Validate stats
	if not self:ValidateStats(cardData.Stats) then
		return false
	end
	
	-- Validate visual effects
	if not self:ValidateVisualEffects(cardData.VisualEffects) then
		return false
	end
	
	return true
end

function CardDatabase:IsValidRarity(rarity: string): boolean
	return TableUtils.find(TableUtils.getValues(GameConstants.Rarity), function(validRarity)
		return validRarity == rarity
	end) ~= nil
end

function CardDatabase:IsValidSeries(series: string): boolean
	local validSeries = {"Naruto", "Dragon Ball", "One Piece", "Attack on Titan", "Demon Slayer", "Jujutsu Kaisen", "My Hero Academia", "Death Note", "Fullmetal Alchemist", "Hunter x Hunter"}
	return TableUtils.find(validSeries, function(validSeriesName)
		return validSeriesName == series
	end) ~= nil
end

function CardDatabase:IsValidType(cardType: string): boolean
	local validTypes = {"Fighter", "Mage", "Support", "Tank", "Assassin", "Healer"}
	return TableUtils.find(validTypes, function(validType)
		return validType == cardType
	end) ~= nil
end

function CardDatabase:ValidateStats(stats: CardTypes.CardStats): boolean
	-- Check all stats exist and are numbers
	local requiredStats = {"Attack", "Defense", "Health", "Speed", "Energy", "Level"}
	
	for _, statName in ipairs(requiredStats) do
		if not stats[statName] or type(stats[statName]) ~= "number" then
			return false
		end
	end
	
	-- Validate ranges (based on card balance research)
	if stats.Attack < 0 or stats.Attack > 250 then return false end
	if stats.Defense < 0 or stats.Defense > 200 then return false end
	if stats.Health < 0 or stats.Health > 300 then return false end
	if stats.Speed < 0 or stats.Speed > 200 then return false end
	if stats.Energy < 0 or stats.Energy > 15 then return false end
	if stats.Level < 1 or stats.Level > 100 then return false end
	
	return true
end

function CardDatabase:ValidateVisualEffects(effects: CardTypes.CardVisualEffects): boolean
	-- Check all required fields exist
	if not effects.BorderColor or typeof(effects.BorderColor) ~= "Color3" then
		return false
	end
	
	if not effects.EffectType or type(effects.EffectType) ~= "string" then
		return false
	end
	
	if not effects.ImpactFrames or type(effects.ImpactFrames) ~= "number" or effects.ImpactFrames < 1 then
		return false
	end
	
	if not effects.ScreenShakeIntensity or type(effects.ScreenShakeIntensity) ~= "number" or effects.ScreenShakeIntensity < 0 then
		return false
	end
	
	if not effects.ParticleCount or type(effects.ParticleCount) ~= "number" or effects.ParticleCount < 0 then
		return false
	end
	
	if not effects.SoundCategory or type(effects.SoundCategory) ~= "string" then
		return false
	end
	
	return true
end

-- Card rarity information
function CardDatabase:GetRarityInfo(): {[string]: {count: number, percentage: number}}
	local info = {}
	local totalCards = TableUtils.getSize(cardRegistry)
	
	for rarity, cards in pairs(rarityGroups) do
		info[rarity] = {
			count = #cards,
			percentage = totalCards > 0 and (#cards / totalCards * 100) or 0
		}
	end
	
	return info
end

-- Series information
function CardDatabase:GetSeriesInfo(): {[string]: {count: number, percentage: number}}
	local info = {}
	local totalCards = TableUtils.getSize(cardRegistry)
	
	for series, cards in pairs(seriesGroups) do
		info[series] = {
			count = #cards,
			percentage = totalCards > 0 and (#cards / totalCards * 100) or 0
		}
	end
	
	return info
end

-- Card search functionality
function CardDatabase:SearchCards(query: string): {CardTypes.CardData}
	local results = {}
	local lowerQuery = string.lower(query)
	
	for _, card in pairs(cardRegistry) do
		-- Search in name, title, description, and flavor text
		local searchFields = {
			string.lower(card.Name),
			string.lower(card.Title or ""),
			string.lower(card.Description),
			string.lower(card.FlavorText or ""),
			string.lower(card.Series),
			string.lower(card.Type),
			string.lower(card.Rarity)
		}
		
		for _, field in ipairs(searchFields) do
			if string.find(field, lowerQuery) then
				table.insert(results, card)
				break
			end
		end
	end
	
	return results
end

-- Card collection statistics
function CardDatabase:GetCollectionStats(): {totalCards: number, byRarity: {[string]: number}, bySeries: {[string]: number}}
	return {
		totalCards = TableUtils.getSize(cardRegistry),
		byRarity = TableUtils.map(TableUtils.getKeys(rarityGroups), function(rarity)
			return #rarityGroups[rarity]
		end),
		bySeries = TableUtils.map(TableUtils.getKeys(seriesGroups), function(series)
			return #seriesGroups[series]
		end)
	}
end

-- Initialize database on module load
initializeDatabase()

-- Export
return CardDatabase 
--- FILE: ./src/shared/Data/AnimeCharacters.luau ---
--!strict
-- AnimeCharacters.luau
-- Database of anime characters with balanced stats and visual effects
-- Uses research-based rarity distribution and psychological appeal

local GameConstants = require(script.Parent.Parent.Constants.GameConstants)

-- Character database organized by series and rarity
local AnimeCharacters = {}

-- Naruto Series
AnimeCharacters.Naruto = {
	-- Common Cards (70% drop rate)
	{
		ID = "naruto_001",
		Name = "Naruto Uzumaki",
		Title = "Genin Ninja",
		Series = "Naruto",
		Rarity = "Common",
		Type = "Fighter",
		Stats = {
			Attack = 45,
			Defense = 35,
			Health = 80,
			Speed = 55,
			Energy = 3,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/naruto_genin.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Common,
			EffectType = "BasicShine",
			ImpactFrames = 2,
			ScreenShakeIntensity = GameConstants.ScreenShake.Light,
			ParticleCount = 10,
			SoundCategory = "Common",
			SpecialIntro = false
		},
		SpecialAbility = "Shadow Clone",
		AbilityDamage = 15,
		AbilityCooldown = 3,
		CollectionNumber = 1,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A young ninja with dreams of becoming Hokage.",
		FlavorText = "Believe it!",
		Artist = "Studio Team"
	},
	
	{
		ID = "sakura_001",
		Name = "Sakura Haruno",
		Title = "Medical Ninja",
		Series = "Naruto", 
		Rarity = "Common",
		Type = "Healer",
		Stats = {
			Attack = 30,
			Defense = 40,
			Health = 70,
			Speed = 45,
			Energy = 2,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/sakura_genin.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Common,
			EffectType = "BasicShine",
			ImpactFrames = 2,
			ScreenShakeIntensity = GameConstants.ScreenShake.Light,
			ParticleCount = 10,
			SoundCategory = "Common",
			SpecialIntro = false
		},
		SpecialAbility = "Medical Jutsu",
		AbilityDamage = 0, -- Healing ability
		AbilityCooldown = 4,
		CollectionNumber = 2,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A skilled medical ninja with incredible strength.",
		FlavorText = "Cha!",
		Artist = "Studio Team"
	},
	
	-- Uncommon Cards (20% drop rate)
	{
		ID = "sasuke_001",
		Name = "Sasuke Uchiha",
		Title = "Last Uchiha",
		Series = "Naruto",
		Rarity = "Uncommon",
		Type = "Assassin",
		Stats = {
			Attack = 65,
			Defense = 45,
			Health = 75,
			Speed = 80,
			Energy = 4,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/sasuke_sharingan.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Uncommon,
			EffectType = "GreenAura",
			ImpactFrames = 3,
			ScreenShakeIntensity = GameConstants.ScreenShake.Medium,
			ParticleCount = 20,
			SoundCategory = "Uncommon",
			SpecialIntro = false
		},
		SpecialAbility = "Sharingan",
		AbilityDamage = 25,
		AbilityCooldown = 3,
		CollectionNumber = 3,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "An elite ninja seeking power and revenge.",
		FlavorText = "I will restore my clan.",
		Artist = "Studio Team"
	},
	
	-- Rare Cards (7% drop rate)
	{
		ID = "kakashi_001",
		Name = "Kakashi Hatake",
		Title = "Copy Ninja",
		Series = "Naruto",
		Rarity = "Rare",
		Type = "Mage",
		Stats = {
			Attack = 85,
			Defense = 70,
			Health = 90,
			Speed = 75,
			Energy = 5,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/kakashi_sharingan.png",
		BackgroundImage = "rbxasset://textures/backgrounds/lightning.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Rare,
			EffectType = "BlueFlames",
			ImpactFrames = 4,
			ScreenShakeIntensity = GameConstants.ScreenShake.Medium,
			ParticleCount = 30,
			SoundCategory = "Rare",
			SpecialIntro = false
		},
		SpecialAbility = "Chidori",
		AbilityDamage = 40,
		AbilityCooldown = 4,
		CollectionNumber = 4,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "The infamous Copy Ninja who has mastered 1000 jutsu.",
		FlavorText = "In the ninja world, those who break the rules are scum, but those who abandon their friends are worse than scum.",
		Artist = "Studio Team"
	},
	
	-- Epic Cards (2.5% drop rate)
	{
		ID = "itachi_001",
		Name = "Itachi Uchiha",
		Title = "Prodigy of the Uchiha",
		Series = "Naruto",
		Rarity = "Epic",
		Type = "Mage",
		Stats = {
			Attack = 110,
			Defense = 85,
			Health = 100,
			Speed = 95,
			Energy = 6,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/itachi_akatsuki.png",
		BackgroundImage = "rbxasset://textures/backgrounds/genjutsu.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Epic,
			EffectType = "PurpleLightning",
			ImpactFrames = 6,
			ScreenShakeIntensity = GameConstants.ScreenShake.Heavy,
			ParticleCount = 50,
			SoundCategory = "Epic",
			SpecialIntro = false
		},
		SpecialAbility = "Tsukuyomi",
		AbilityDamage = 60,
		AbilityCooldown = 5,
		CollectionNumber = 5,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A legendary ninja who sacrificed everything for peace.",
		FlavorText = "Those who forgive themselves, and are able to accept their true nature... They are the strong ones.",
		Artist = "Studio Team"
	},
	
	-- Legendary Cards (0.5% drop rate)
	{
		ID = "naruto_002",
		Name = "Naruto Uzumaki",
		Title = "Seventh Hokage",
		Series = "Naruto",
		Rarity = "Legendary",
		Type = "Fighter",
		Stats = {
			Attack = 150,
			Defense = 120,
			Health = 180,
			Speed = 110,
			Energy = 8,
			Level = 1
		},
		Image = "rbxasset://textures/naruto/naruto_hokage.png",
		BackgroundImage = "rbxasset://textures/backgrounds/village_hidden_leaf.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Legendary,
			EffectType = "GoldenNova",
			ImpactFrames = 8,
			ScreenShakeIntensity = GameConstants.ScreenShake.Heavy,
			ParticleCount = 100,
			SoundCategory = "Legendary",
			SpecialIntro = false
		},
		SpecialAbility = "Rasengan Barrage",
		AbilityDamage = 80,
		AbilityCooldown = 6,
		CollectionNumber = 6,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "The Seventh Hokage who brought peace to the ninja world.",
		FlavorText = "I'm not gonna run away, I never go back on my word! That's my nindō: my ninja way!",
		Artist = "Studio Team"
	}
}

-- Dragon Ball Series
AnimeCharacters.DragonBall = {
	-- Common Cards
	{
		ID = "goku_001",
		Name = "Son Goku",
		Title = "Saiyan Warrior",
		Series = "Dragon Ball",
		Rarity = "Common",
		Type = "Fighter",
		Stats = {
			Attack = 50,
			Defense = 40,
			Health = 85,
			Speed = 60,
			Energy = 3,
			Level = 1
		},
		Image = "rbxasset://textures/dragonball/goku_base.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Common,
			EffectType = "BasicShine",
			ImpactFrames = 2,
			ScreenShakeIntensity = GameConstants.ScreenShake.Light,
			ParticleCount = 10,
			SoundCategory = "Common",
			SpecialIntro = false
		},
		SpecialAbility = "Kamehameha",
		AbilityDamage = 20,
		AbilityCooldown = 3,
		CollectionNumber = 1,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A pure-hearted Saiyan warrior.",
		FlavorText = "I am the hope of the universe!",
		Artist = "Studio Team"
	},
	
	-- Ultimate Card (0.01% drop rate)
	{
		ID = "goku_002",
		Name = "Son Goku",
		Title = "Ultra Instinct",
		Series = "Dragon Ball",
		Rarity = "Ultimate",
		Type = "Fighter",
		Stats = {
			Attack = 200,
			Defense = 150,
			Health = 250,
			Speed = 180,
			Energy = 10,
			Level = 1
		},
		Image = "rbxasset://textures/dragonball/goku_ultra_instinct.png",
		BackgroundImage = "rbxasset://textures/backgrounds/universe.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Ultimate,
			EffectType = "RainbowCosmos",
			ImpactFrames = 12,
			ScreenShakeIntensity = GameConstants.ScreenShake.Ultimate,
			ParticleCount = 200,
			SoundCategory = "Ultimate",
			SpecialIntro = true
		},
		SpecialAbility = "Ultra Instinct",
		AbilityDamage = 120,
		AbilityCooldown = 8,
		CollectionNumber = 2,
		ReleaseDate = "2024-01-01",
		IsLimited = true,
		Description = "The ultimate form achieved through perfect instinct.",
		FlavorText = "This is the power of Ultra Instinct!",
		Artist = "Studio Team"
	}
}

-- One Piece Series
AnimeCharacters.OnePiece = {
	-- Common Cards
	{
		ID = "luffy_001",
		Name = "Monkey D. Luffy",
		Title = "Straw Hat Captain",
		Series = "One Piece",
		Rarity = "Common",
		Type = "Fighter",
		Stats = {
			Attack = 48,
			Defense = 35,
			Health = 90,
			Speed = 65,
			Energy = 3,
			Level = 1
		},
		Image = "rbxasset://textures/onepiece/luffy_base.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Common,
			EffectType = "BasicShine",
			ImpactFrames = 2,
			ScreenShakeIntensity = GameConstants.ScreenShake.Light,
			ParticleCount = 10,
			SoundCategory = "Common",
			SpecialIntro = false
		},
		SpecialAbility = "Gum Gum Pistol",
		AbilityDamage = 18,
		AbilityCooldown = 2,
		CollectionNumber = 1,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A rubber man with dreams of becoming Pirate King.",
		FlavorText = "I'm gonna be King of the Pirates!",
		Artist = "Studio Team"
	},
	
	-- Legendary Cards
	{
		ID = "luffy_002",
		Name = "Monkey D. Luffy",
		Title = "Gear Fifth",
		Series = "One Piece",
		Rarity = "Legendary",
		Type = "Fighter",
		Stats = {
			Attack = 145,
			Defense = 110,
			Health = 200,
			Speed = 130,
			Energy = 8,
			Level = 1
		},
		Image = "rbxasset://textures/onepiece/luffy_gear5.png",
		BackgroundImage = "rbxasset://textures/backgrounds/liberation.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Legendary,
			EffectType = "GoldenNova",
			ImpactFrames = 8,
			ScreenShakeIntensity = GameConstants.ScreenShake.Heavy,
			ParticleCount = 100,
			SoundCategory = "Legendary",
			SpecialIntro = false
		},
		SpecialAbility = "Bajrang Gun",
		AbilityDamage = 90,
		AbilityCooldown = 7,
		CollectionNumber = 2,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "The awakened form of the legendary Sun God Nika.",
		FlavorText = "The most ridiculous power in the world!",
		Artist = "Studio Team"
	}
}

-- Attack on Titan Series
AnimeCharacters.AttackOnTitan = {
	-- Uncommon Cards
	{
		ID = "eren_001",
		Name = "Eren Yeager",
		Title = "Attack Titan",
		Series = "Attack on Titan",
		Rarity = "Uncommon",
		Type = "Tank",
		Stats = {
			Attack = 70,
			Defense = 60,
			Health = 120,
			Speed = 40,
			Energy = 5,
			Level = 1
		},
		Image = "rbxasset://textures/aot/eren_titan.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Uncommon,
			EffectType = "GreenAura",
			ImpactFrames = 3,
			ScreenShakeIntensity = GameConstants.ScreenShake.Medium,
			ParticleCount = 20,
			SoundCategory = "Uncommon",
			SpecialIntro = false
		},
		SpecialAbility = "Titan Transformation",
		AbilityDamage = 35,
		AbilityCooldown = 5,
		CollectionNumber = 1,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A young soldier who can transform into a Titan.",
		FlavorText = "I will destroy every last Titan!",
		Artist = "Studio Team"
	}
}

-- Demon Slayer Series  
AnimeCharacters.DemonSlayer = {
	-- Rare Cards
	{
		ID = "tanjiro_001",
		Name = "Tanjiro Kamado",
		Title = "Water Breathing",
		Series = "Demon Slayer",
		Rarity = "Rare",
		Type = "Fighter",
		Stats = {
			Attack = 80,
			Defense = 65,
			Health = 95,
			Speed = 85,
			Energy = 4,
			Level = 1
		},
		Image = "rbxasset://textures/demonslayer/tanjiro_water.png",
		BackgroundImage = "rbxasset://textures/backgrounds/water_waves.png",
		VisualEffects = {
			BorderColor = GameConstants.RarityColors.Rare,
			EffectType = "BlueFlames",
			ImpactFrames = 4,
			ScreenShakeIntensity = GameConstants.ScreenShake.Medium,
			ParticleCount = 30,
			SoundCategory = "Rare",
			SpecialIntro = false
		},
		SpecialAbility = "Water Breathing: Tenth Form",
		AbilityDamage = 45,
		AbilityCooldown = 4,
		CollectionNumber = 1,
		ReleaseDate = "2024-01-01",
		IsLimited = false,
		Description = "A kind-hearted demon slayer seeking to cure his sister.",
		FlavorText = "I will not let anyone else die!",
		Artist = "Studio Team"
	}
}

-- Get all characters as flat array
function AnimeCharacters:GetAllCharacters()
	local allCharacters = {}
	
	for seriesName, characters in pairs(self) do
		if type(characters) == "table" and seriesName ~= "GetAllCharacters" and seriesName ~= "GetCharactersByRarity" and seriesName ~= "GetCharactersBySeries" then
			for _, character in ipairs(characters) do
				table.insert(allCharacters, character)
			end
		end
	end
	
	return allCharacters
end

-- Get characters by rarity
function AnimeCharacters:GetCharactersByRarity(rarity: string)
	local characters = {}
	local allCharacters = self:GetAllCharacters()
	
	for _, character in ipairs(allCharacters) do
		if character.Rarity == rarity then
			table.insert(characters, character)
		end
	end
	
	return characters
end

-- Get characters by series
function AnimeCharacters:GetCharactersBySeries(series: string)
	local characters = {}
	local allCharacters = self:GetAllCharacters()
	
	for _, character in ipairs(allCharacters) do
		if character.Series == series then
			table.insert(characters, character)
		end
	end
	
	return characters
end

return AnimeCharacters
--- FILE: ./src/shared/init.luau ---
--!strict
-- Shared module index
-- Exports all core modules for easy access

local Shared = {}

-- Core framework
Shared.ServiceRegistry = require(script.Core.ServiceRegistry)
Shared.BaseService = require(script.Core.BaseService)
Shared.BaseController = require(script.Core.BaseController)
Shared.RemoteEventHandler = require(script.Core.RemoteEventHandler)

-- Utilities
Shared.TableUtils = require(script.Utils.TableUtils)

-- Constants
Shared.GameConstants = require(script.Constants.GameConstants)

-- Types
Shared.CardTypes = require(script.Types.CardTypes)
Shared.AudioTypes = require(script.Types.AudioTypes)
Shared.EffectsTypes = require(script.Types.EffectsTypes)

-- Data
Shared.CardDatabase = require(script.Data.CardDatabase)
Shared.AnimeCharacters = require(script.Data.AnimeCharacters)

-- Export
return Shared 
--- FILE: ./src/client/init.client.luau ---
--!strict
-- Client initialization
-- Sets up the service registry and loads all client controllers

-- Core framework
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServiceRegistry = require(ReplicatedStorage.Shared.Core.ServiceRegistry)

-- Controllers will be loaded here
local controllers = {}

-- Load Controllers (they auto-register themselves)
local TestSceneController = require(script.Controllers.TestSceneController)
local BattleController = require(script.Controllers.BattleController)
local AudioController = require(script.Controllers.AudioController)
local EffectsController = require(script.Controllers.EffectsController)
local PolishEffectsController = require(script.Controllers.PolishEffectsController)
local CardRevealTestController = require(script.Controllers.CardRevealTestController)
-- DISABLED: local CardRollController = require(script.Controllers.CardRollController) -- Causing banner UI issues
local CardRevealController = require(script.Controllers.CardRevealController)
local TestCombatController = require(script.Controllers.TestCombatController)

-- Load all controllers from the Controllers folder
local function loadControllers()
	local controllersFolder = script.Controllers
	if not controllersFolder then
		warn("Controllers folder not found")
		return
	end
	
	for _, controllerModule in pairs(controllersFolder:GetChildren()) do
		if controllerModule:IsA("ModuleScript") then
			local controllerName = controllerModule.Name
			local success, controller = pcall(require, controllerModule)
			
			if success then
				controllers[controllerName] = controller
				ServiceRegistry:RegisterService(controllerName, controller)
			else
				error("Failed to load controller: " .. controllerName .. " - " .. tostring(controller))
			end
		end
	end
end

-- Initialize the client
local function initializeClient()
	print("🎮 Starting Anime Card Clash Client...")
	
	-- Load all controllers
	loadControllers()
	
	-- Initialize controllers
	local success = ServiceRegistry:InitializeAll()
	if not success then
		error("Failed to initialize controllers")
	end
	
	-- Start controllers
	success = ServiceRegistry:StartAll()
	if not success then
		error("Failed to start controllers")
	end
	
	print("✅ Client initialized successfully!")
	
	-- List loaded controllers
	local controllerNames = {}
	for name in pairs(controllers) do
		table.insert(controllerNames, name)
	end
	print("📊 Controllers loaded:", table.concat(controllerNames, ", "))
end

-- Handle client cleanup (BindToClose only works on server)
-- Client cleanup will happen automatically when the player leaves

-- Start the client
initializeClient()

-- Export for debugging
_G.ServiceRegistry = ServiceRegistry
_G.Controllers = controllers
--- FILE: ./src/client/Controllers/CardRevealTestController.luau ---
--!strict
-- CardRevealTestController.luau
-- Test controller for CardRevealController functionality

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local UITypes = require(ReplicatedStorage.Shared.Types.UITypes)
local RollTypes = require(ReplicatedStorage.Shared.Types.RollTypes)

local CardRevealTestController = {}
CardRevealTestController.__index = CardRevealTestController
setmetatable(CardRevealTestController, {__index = BaseController})

function CardRevealTestController.new()
    local self = BaseController.new("CardRevealTestController", {"CardRevealController", "EffectsController"})
    setmetatable(self, CardRevealTestController)
    
    return self
end

function CardRevealTestController:Initialize()
    self:_log("CardRevealTestController initializing...")
end

function CardRevealTestController:Start()
    self:_log("CardRevealTestController starting...")
    
    --[[
    -- Start testing after a short delay
    spawn(function()
        wait(3)
        self:_startTesting()
    end)
    --]]
end

function CardRevealTestController:_startTesting()
    self:_log("🎨 Starting Card Reveal UI testing...")
    
    local cardRevealController = self.ServiceRegistry:GetService("CardRevealController")
    local effectsController = self.ServiceRegistry:GetService("EffectsController")
    
    -- Test 1: Single card reveal
    self:_testSingleCardReveal(cardRevealController)
    
    -- Test 2: Multiple card reveal
    spawn(function()
        wait(6)
        self:_testMultipleCardReveal(cardRevealController)
    end)
    
    -- Test 3: High rarity card reveal
    spawn(function()
        wait(12)
        self:_testHighRarityReveal(cardRevealController)
    end)
    
    -- Test 4: Batch reveal
    spawn(function()
        wait(18)
        self:_testBatchReveal(cardRevealController)
    end)
    
    -- Test 5: Skip functionality
    spawn(function()
        wait(24)
        self:_testSkipFunctionality(cardRevealController)
    end)
    
    -- Test 6: Responsive design
    spawn(function()
        wait(30)
        self:_testResponsiveDesign(cardRevealController)
    end)
    
    -- Test 7: Effects system
    spawn(function()
        wait(36)
        self:_testEffectsSystem(effectsController)
    end)
    
    -- Test 8: Performance metrics
    spawn(function()
        wait(42)
        self:_testPerformanceMetrics(cardRevealController, effectsController)
    end)
end

function CardRevealTestController:_testSingleCardReveal(controller)
    self:_log("Testing single card reveal...")
    
    local testCard = self:_createTestCard("naruto_001", "Naruto Uzumaki", "Rare", 1200, 800)
    
    local request = {
        Cards = {testCard},
        RevealType = "Single",
        TotalDuration = 2.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ Single card reveal successful")
        self:_log("   - Cards revealed: " .. result.CardsRevealed)
        self:_log("   - Total duration: " .. result.TotalDuration .. "s")
    else
        self:_logError("❌ Single card reveal failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testMultipleCardReveal(controller)
    self:_log("Testing multiple card reveal...")
    
    local testCards = {
        self:_createTestCard("naruto_001", "Naruto Uzumaki", "Rare", 1200, 800),
        self:_createTestCard("sasuke_001", "Sasuke Uchiha", "Epic", 1400, 900),
        self:_createTestCard("sakura_001", "Sakura Haruno", "Common", 1000, 1200)
    }
    
    local request = {
        Cards = testCards,
        RevealType = "Multi",
        TotalDuration = 4.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ Multiple card reveal successful")
        self:_log("   - Cards revealed: " .. result.CardsRevealed)
        
        -- Monitor reveal state
        spawn(function()
            while controller:IsRevealing() do
                local state = controller:GetCurrentRevealState()
                if state then
                    self:_log("   - Progress: " .. string.format("%.1f", state.RevealProgress * 100) .. "%")
                end
                wait(0.5)
            end
        end)
    else
        self:_logError("❌ Multiple card reveal failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testHighRarityReveal(controller)
    self:_log("Testing high rarity card reveal...")
    
    local testCards = {
        self:_createTestCard("goku_001", "Goku Super Saiyan", "Legendary", 2000, 1500),
        self:_createTestCard("saitama_001", "One Punch Man", "Mythical", 9999, 1000),
        self:_createTestCard("zeno_001", "Zeno Sama", "Ultimate", 10000, 10000)
    }
    
    local request = {
        Cards = testCards,
        RevealType = "Guaranteed",
        TotalDuration = 6.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ High rarity reveal successful")
        self:_log("   - Expected intense effects for high rarity cards")
        
        -- Test effects controller integration
        local effectsController = self.ServiceRegistry:GetService("EffectsController")
        if effectsController then
            self:_log("   - Effects controller active: " .. effectsController:GetActiveEffectCount() .. " effects")
        end
    else
        self:_logError("❌ High rarity reveal failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testBatchReveal(controller)
    self:_log("Testing batch reveal...")
    
    local testCards = {}
    local rarities = {"Common", "Rare", "Epic", "Legendary", "Mythical"}
    
    for i = 1, 8 do
        local rarity = rarities[math.random(1, #rarities)]
        table.insert(testCards, self:_createTestCard("batch_" .. i, "Test Card " .. i, rarity, 1000 + i * 100, 800 + i * 50))
    end
    
    local request = {
        Cards = testCards,
        RevealType = "Batch",
        TotalDuration = 5.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ Batch reveal successful")
        self:_log("   - Batch size: " .. result.CardsRevealed)
        
        -- Test layout calculation
        local state = controller:GetCurrentRevealState()
        if state then
            self:_log("   - Total cards: " .. state.TotalCards)
            self:_log("   - Layout should handle " .. state.TotalCards .. " cards responsively")
        end
    else
        self:_logError("❌ Batch reveal failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testSkipFunctionality(controller)
    self:_log("Testing skip functionality...")
    
    local testCards = {
        self:_createTestCard("skip_test_1", "Skip Test 1", "Epic", 1300, 900),
        self:_createTestCard("skip_test_2", "Skip Test 2", "Legendary", 1800, 1200),
        self:_createTestCard("skip_test_3", "Skip Test 3", "Rare", 1100, 700)
    }
    
    local request = {
        Cards = testCards,
        RevealType = "Multi",
        TotalDuration = 6.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ Skip test started")
        
        -- Wait a bit, then skip
        spawn(function()
            wait(2)
            
            if controller:IsRevealing() then
                local skipSuccess = controller:SkipCurrentReveal()
                if skipSuccess then
                    self:_log("✅ Skip functionality successful")
                    self:_log("   - Reveal was skipped successfully")
                else
                    self:_logError("❌ Skip functionality failed")
                end
            else
                self:_log("⚠️  Reveal finished before skip test")
            end
        end)
    else
        self:_logError("❌ Skip test setup failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testResponsiveDesign(controller)
    self:_log("Testing responsive design...")
    
    local testCards = {
        self:_createTestCard("responsive_1", "Mobile Test", "Common", 1000, 800),
        self:_createTestCard("responsive_2", "Tablet Test", "Rare", 1200, 900),
        self:_createTestCard("responsive_3", "Desktop Test", "Epic", 1400, 1000)
    }
    
    local request = {
        Cards = testCards,
        RevealType = "Multi",
        TotalDuration = 3.0,
        AudioEnabled = true,
        EffectsEnabled = true,
        SkipAnimations = false
    }
    
    local result = controller:RevealCards(request)
    
    if result.Success then
        self:_log("✅ Responsive design test successful")
        
        -- Check device detection
        local stats = controller:GetRevealStatistics()
        self:_log("   - Device type: " .. stats.DeviceType)
        self:_log("   - Layout adapted for device type")
        
        -- Test different screen sizes (simulation)
        local screenSize = workspace.CurrentCamera.ViewportSize
        self:_log("   - Screen size: " .. screenSize.X .. "x" .. screenSize.Y)
        
        if screenSize.X < 768 then
            self:_log("   - Mobile layout detected")
        elseif screenSize.X < 1024 then
            self:_log("   - Tablet layout detected")
        else
            self:_log("   - Desktop layout detected")
        end
    else
        self:_logError("❌ Responsive design test failed: " .. (result.ErrorMessage or "Unknown error"))
    end
end

function CardRevealTestController:_testEffectsSystem(effectsController)
    self:_log("Testing effects system...")
    
    if not effectsController then
        self:_logError("❌ Effects controller not available")
        return
    end
    
    -- Test screen shake
    effectsController:TriggerScreenShake(0.5, 1.0)
    self:_log("✅ Screen shake triggered")
    
    -- Test screen flash
    local flashID = effectsController:PlayScreenFlash(Color3.new(1, 0.8, 0), 0.6, 0.5)
    self:_log("✅ Screen flash triggered: " .. flashID)
    
    -- Test performance metrics
    local metrics = effectsController:GetPerformanceMetrics()
    self:_log("📊 Effects performance metrics:")
    self:_log("   - Active effects: " .. metrics.ActiveEffects)
    self:_log("   - Memory usage: " .. string.format("%.2f", metrics.MemoryUsage) .. "KB")
    self:_log("   - Frame rate: " .. string.format("%.1f", metrics.FrameRate) .. "FPS")
    
    -- Test effect cleanup
    spawn(function()
        wait(3)
        effectsController:ClearAllEffects()
        self:_log("✅ Effects cleared successfully")
    end)
end

function CardRevealTestController:_testPerformanceMetrics(revealController, effectsController)
    self:_log("Testing performance metrics...")
    
    -- Get reveal statistics
    local revealStats = revealController:GetRevealStatistics()
    self:_log("📊 Reveal Statistics:")
    self:_log("   - Total reveals: " .. revealStats.RevealCount)
    self:_log("   - Average reveal time: " .. string.format("%.2f", revealStats.AverageRevealTime) .. "s")
    self:_log("   - Skip rate: " .. string.format("%.2f", revealStats.SkipRate * 100) .. "%")
    self:_log("   - Queue size: " .. revealStats.QueueSize)
    
    -- Get effects metrics
    if effectsController then
        local effectsMetrics = effectsController:GetPerformanceMetrics()
        self:_log("📊 Effects Metrics:")
        self:_log("   - Active animations: " .. effectsMetrics.ActiveAnimations)
        self:_log("   - Active effects: " .. effectsMetrics.ActiveEffects)
        self:_log("   - Render time: " .. string.format("%.2f", effectsMetrics.RenderTime) .. "ms")
    end
    
    -- Test memory usage
    local memoryBefore = collectgarbage("count")
    
    -- Stress test with multiple reveals
    local stressCards = {}
    for i = 1, 10 do
        table.insert(stressCards, self:_createTestCard("stress_" .. i, "Stress Test " .. i, "Common", 1000, 800))
    end
    
    local stressRequest = {
        Cards = stressCards,
        RevealType = "Batch",
        TotalDuration = 2.0,
        AudioEnabled = false,
        EffectsEnabled = false,
        SkipAnimations = true
    }
    
    local stressResult = revealController:RevealCards(stressRequest)
    
    if stressResult.Success then
        local memoryAfter = collectgarbage("count")
        local memoryUsed = memoryAfter - memoryBefore
        
        self:_log("📊 Stress Test Results:")
        self:_log("   - Memory usage: " .. string.format("%.2f", memoryUsed) .. "KB")
        self:_log("   - Performance impact: " .. (memoryUsed < 100 and "Low" or "High"))
    end
end

function CardRevealTestController:TestInputHandling()
    self:_log("Testing input handling...")
    
    local revealController = self.ServiceRegistry:GetService("CardRevealController")
    
    -- Test keyboard input
    self:_log("   - Testing keyboard input (Space to skip, Enter to continue)")
    
    -- Test mobile touch input
    if UserInputService.TouchEnabled then
        self:_log("   - Testing mobile touch input (double tap to skip)")
    end
    
    -- Test button interactions
    self:_log("   - Testing UI button interactions")
    
    self:_log("✅ Input handling test completed")
end

function CardRevealTestController:TestErrorHandling()
    self:_log("Testing error handling...")
    
    local revealController = self.ServiceRegistry:GetService("CardRevealController")
    
    -- Test invalid request
    local invalidRequest = {
        Cards = {},
        RevealType = "Invalid",
        TotalDuration = -1,
        AudioEnabled = true,
        EffectsEnabled = true
    }
    
    local result = revealController:RevealCards(invalidRequest)
    
    if not result.Success then
        self:_log("✅ Invalid request properly rejected")
        self:_log("   - Error: " .. (result.ErrorMessage or "Unknown"))
    else
        self:_log("⚠️  Invalid request was accepted (should be rejected)")
    end
    
    -- Test nil card data
    local nilCardRequest = {
        Cards = nil,
        RevealType = "Single",
        TotalDuration = 2.0,
        AudioEnabled = true,
        EffectsEnabled = true
    }
    
    local nilResult = revealController:RevealCards(nilCardRequest)
    
    if not nilResult.Success then
        self:_log("✅ Nil card request properly handled")
    else
        self:_log("⚠️  Nil card request should have failed")
    end
end

function CardRevealTestController:TestAnimationTiming()
    self:_log("Testing animation timing...")
    
    local revealController = self.ServiceRegistry:GetService("CardRevealController")
    
    -- Test different timing scenarios
    local timingTests = {
        {duration = 1.0, name = "Fast"},
        {duration = 3.0, name = "Normal"},
        {duration = 6.0, name = "Slow"}
    }
    
    for i, test in ipairs(timingTests) do
        spawn(function()
            wait(i * 8) -- Stagger tests
            
            self:_log("   - Testing " .. test.name .. " timing (" .. test.duration .. "s)")
            
            local testCard = self:_createTestCard("timing_" .. i, "Timing Test " .. i, "Epic", 1300, 900)
            
            local request = {
                Cards = {testCard},
                RevealType = "Single",
                TotalDuration = test.duration,
                AudioEnabled = true,
                EffectsEnabled = true,
                SkipAnimations = false
            }
            
            local startTime = os.clock()
            local result = revealController:RevealCards(request)
            
            if result.Success then
                -- Monitor actual timing
                spawn(function()
                    while revealController:IsRevealing() do
                        wait(0.1)
                    end
                    
                    local actualTime = os.clock() - startTime
                    self:_log("   - " .. test.name .. " timing actual: " .. string.format("%.2f", actualTime) .. "s")
                end)
            end
        end)
    end
end

function CardRevealTestController:_createTestCard(id: string, name: string, rarity: string, attack: number, defense: number): RollTypes.CardRollResult
    local cardData = {
        ID = id,
        Name = name,
        Rarity = rarity,
        Attack = attack,
        Defense = defense,
        Health = 100,
        Cost = 5,
        Special = "Test Special",
        Series = "Test Series",
        Type = "Fighter",
        Image = "rbxasset://textures/face.png",
        Description = "A test card for reveal testing"
    }
    
    return {
        Card = cardData,
        Rarity = rarity,
        IsNew = true,
        IsPityResult = false,
        PityCount = 0,
        RollPosition = 1,
        AnimationDelay = 2000, -- 2 seconds
        EffectIntensity = rarity == "Ultimate" and 1.0 or (rarity == "Mythical" and 0.9 or (rarity == "Legendary" and 0.8 or 0.5))
    }
end

return CardRevealTestController.new() 
--- FILE: ./src/client/Controllers/EffectsController.luau ---
--!strict
-- EffectsController.luau
-- Advanced visual effects system for card reveals with rarity-based intensity

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local TweenService = game:GetService("TweenService")
local Debris = game:GetService("Debris")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local UITypes = require(ReplicatedStorage.Shared.Types.UITypes)
local RollTypes = require(ReplicatedStorage.Shared.Types.RollTypes)

type VisualEffect = UITypes.VisualEffect
type ScreenEffect = UITypes.ScreenEffect
type ScreenShakeData = UITypes.ScreenShakeData
type AudioCue = UITypes.AudioCue
type RarityVisualConfig = UITypes.RarityVisualConfig

local EffectsController = {}
EffectsController.__index = EffectsController
setmetatable(EffectsController, {__index = BaseController})

-- Rarity Visual Configurations (Research-based)
local RARITY_CONFIGS = {
    Common = {
        BorderColor = Color3.new(0.7, 0.7, 0.7),
        GlowColor = Color3.new(0.8, 0.8, 0.8),
        ParticleColor = Color3.new(0.9, 0.9, 0.9),
        EffectIntensity = 0.1,
        AnimationDuration = 0.5,
        AudioFrequency = 440,
        ScreenShakeIntensity = 0.0,
        FlashIntensity = 0.1
    },
    Rare = {
        BorderColor = Color3.new(0.2, 0.8, 0.2),
        GlowColor = Color3.new(0.3, 1.0, 0.3),
        ParticleColor = Color3.new(0.4, 0.9, 0.4),
        EffectIntensity = 0.3,
        AnimationDuration = 0.8,
        AudioFrequency = 523,
        ScreenShakeIntensity = 0.1,
        FlashIntensity = 0.2
    },
    Epic = {
        BorderColor = Color3.new(0.5, 0.2, 0.8),
        GlowColor = Color3.new(0.6, 0.3, 1.0),
        ParticleColor = Color3.new(0.7, 0.4, 0.9),
        EffectIntensity = 0.5,
        AnimationDuration = 1.2,
        AudioFrequency = 659,
        ScreenShakeIntensity = 0.2,
        FlashIntensity = 0.4
    },
    Legendary = {
        BorderColor = Color3.new(1.0, 0.5, 0.0),
        GlowColor = Color3.new(1.0, 0.6, 0.1),
        ParticleColor = Color3.new(1.0, 0.7, 0.2),
        EffectIntensity = 0.8,
        AnimationDuration = 1.8,
        AudioFrequency = 784,
        ScreenShakeIntensity = 0.4,
        FlashIntensity = 0.6
    },
    Mythical = {
        BorderColor = Color3.new(0.8, 0.2, 0.8),
        GlowColor = Color3.new(1.0, 0.3, 1.0),
        ParticleColor = Color3.new(0.9, 0.4, 0.9),
        EffectIntensity = 0.9,
        AnimationDuration = 2.2,
        AudioFrequency = 880,
        ScreenShakeIntensity = 0.6,
        FlashIntensity = 0.8
    },
    Ultimate = {
        BorderColor = Color3.new(1.0, 0.8, 0.0),
        GlowColor = Color3.new(1.0, 0.9, 0.1),
        ParticleColor = Color3.new(1.0, 1.0, 0.2),
        EffectIntensity = 1.0,
        AnimationDuration = 3.0,
        AudioFrequency = 1047,
        ScreenShakeIntensity = 0.8,
        FlashIntensity = 1.0
    }
}

-- Screen Shake Configuration
local SCREEN_SHAKE_CONFIG = {
    TraumaPower = 2.0,
    DecayRate = 0.8,
    MaxOffset = 20,
    MaxRotation = 2,
    NoiseScale = 100,
    UpdateFrequency = 0.016 -- 60 FPS
}

function EffectsController.new()
    	local self = BaseController.new("EffectsController", {})
    setmetatable(self, EffectsController)
    
    -- Effect tracking
    self._activeEffects = {} :: {[string]: VisualEffect}
    self._screenEffects = {} :: {[string]: ScreenEffect}
    self._audioSequences = {} :: {[string]: UITypes.AudioSequence}
    
    -- Screen shake system
    self._screenShakeData = {
        Intensity = 0,
        Duration = 0,
        Frequency = 0,
        Decay = 0,
        Trauma = 0,
        StartTime = 0
    }
    
    -- Camera reference
    self._camera = workspace.CurrentCamera
    self._originalCFrame = self._camera.CFrame
    
    -- Performance tracking
    self._effectCount = 0
    self._particleCount = 0
    self._audioCount = 0
    
    -- Effect pools for performance
    self._particlePool = {}
    self._effectPool = {}
    
    return self
end

function EffectsController:Initialize()
    self:_log("EffectsController initializing...")
    
    -- Initialize screen shake system
    self._screenShakeConnection = RunService.Heartbeat:Connect(function()
        self:_updateScreenShake()
    end)
    
    -- Initialize particle pools
    self:_initializeParticlePools()
    
    -- Initialize audio system
    self:_initializeAudioSystem()
    
    self:_log("EffectsController initialized successfully")
end

function EffectsController:Start()
    self:_log("EffectsController starting...")
    
    -- Start performance monitoring
    self:_startPerformanceMonitoring()
    
    self:_log("EffectsController started successfully")
end

function EffectsController:Stop()
    self:_log("EffectsController stopping...")
    
    -- Clear all effects
    self:ClearAllEffects()
    
    -- Clean up connections
    if self._screenShakeConnection then
        self._screenShakeConnection:Disconnect()
    end
    
    if self._performanceConnection then
        self._performanceConnection:Disconnect()
    end
    
    self:_log("EffectsController stopped")
end

-- Public Methods

function EffectsController:PlayCardRevealEffects(cardResult: RollTypes.CardRollResult, targetElement: GuiObject): string
    local effectID = self:_generateEffectID()
    local rarity = cardResult.Rarity
    local config = RARITY_CONFIGS[rarity] or RARITY_CONFIGS.Common
    
    self:_log("Playing card reveal effects for " .. rarity .. " card")
    
    -- Create visual effect sequence
    local effectSequence = self:_createCardEffectSequence(cardResult, targetElement, config)
    
    -- Play particle effects
    if cardResult.EffectIntensity > 0.3 then
        self:_playParticleEffects(targetElement, config, cardResult.EffectIntensity)
    end
    
    -- Play screen effects
    if cardResult.EffectIntensity > 0.5 then
        self:_playScreenEffects(config, cardResult.EffectIntensity)
    end
    
    -- Play audio effects
    self:_playAudioEffects(rarity, config, cardResult.IsPityResult)
    
    -- Trigger screen shake for high rarity cards
    if cardResult.EffectIntensity > 0.6 then
        self:TriggerScreenShake(config.ScreenShakeIntensity * cardResult.EffectIntensity, 0.5)
    end
    
    -- Store effect for tracking
    self._activeEffects[effectID] = {
        EffectID = effectID,
        EffectType = "CardReveal",
        Duration = config.AnimationDuration * 1000,
        StartTime = os.clock(),
        EndTime = os.clock() + config.AnimationDuration,
        Properties = {
            Rarity = rarity,
            Intensity = cardResult.EffectIntensity,
            IsPityResult = cardResult.IsPityResult
        },
        Target = targetElement,
        IsActive = true
    }
    
    return effectID
end

function EffectsController:TriggerScreenShake(intensity: number, duration: number)
    local currentTime = os.clock()
    
    -- Apply trauma-based screen shake
    local trauma = math.min(1.0, intensity)
    
    self._screenShakeData = {
        Intensity = intensity,
        Duration = duration,
        Frequency = 30, -- 30 Hz frequency
        Decay = SCREEN_SHAKE_CONFIG.DecayRate,
        Trauma = trauma,
        StartTime = currentTime
    }
    
    self:_log("Screen shake triggered: intensity=" .. intensity .. ", duration=" .. duration)
end

function EffectsController:PlayScreenFlash(color: Color3, intensity: number, duration: number): string
    local effectID = self:_generateEffectID()
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    -- Create flash effect
    local flashFrame = Instance.new("Frame")
    flashFrame.Name = "ScreenFlash_" .. effectID
    flashFrame.Size = UDim2.new(1, 0, 1, 0)
    flashFrame.Position = UDim2.new(0, 0, 0, 0)
    flashFrame.BackgroundColor3 = color
    flashFrame.BackgroundTransparency = 1
    flashFrame.ZIndex = 1000
    flashFrame.Parent = playerGui
    
    -- Animate flash
    local flashIn = TweenService:Create(flashFrame, TweenInfo.new(duration * 0.1), {
        BackgroundTransparency = 1 - intensity
    })
    
    local flashOut = TweenService:Create(flashFrame, TweenInfo.new(duration * 0.9), {
        BackgroundTransparency = 1
    })
    
    flashIn:Play()
    flashIn.Completed:Connect(function()
        flashOut:Play()
        flashOut.Completed:Connect(function()
            flashFrame:Destroy()
        end)
    end)
    
    -- Track effect
    self._screenEffects[effectID] = {
        EffectName = "ScreenFlash",
        Duration = duration,
        Intensity = intensity,
        Color = color,
        StartTime = os.clock(),
        FadeInTime = duration * 0.1,
        FadeOutTime = duration * 0.9,
        Properties = {
            Frame = flashFrame
        }
    }
    
    return effectID
end

function EffectsController:CreateParticleEffect(target: GuiObject, config: RarityVisualConfig, duration: number): string
    local effectID = self:_generateEffectID()
    
    -- Create particle container
    local particleContainer = Instance.new("Frame")
    particleContainer.Name = "ParticleContainer_" .. effectID
    particleContainer.Size = UDim2.new(1, 0, 1, 0)
    particleContainer.Position = UDim2.new(0, 0, 0, 0)
    particleContainer.BackgroundTransparency = 1
    particleContainer.ZIndex = 50
    particleContainer.Parent = target
    
    -- Create multiple particle systems
    local particleCount = math.floor(config.EffectIntensity * 20) + 5
    
    for i = 1, particleCount do
        spawn(function()
            self:_createParticle(particleContainer, config, duration)
        end)
    end
    
    -- Schedule cleanup
    Debris:AddItem(particleContainer, duration)
    
    return effectID
end

function EffectsController:CreateGlowEffect(target: GuiObject, config: RarityVisualConfig, duration: number): string
    local effectID = self:_generateEffectID()
    
    -- Create glow effect
    local glowFrame = Instance.new("Frame")
    glowFrame.Name = "GlowEffect_" .. effectID
    glowFrame.Size = UDim2.new(1, 20, 1, 20)
    glowFrame.Position = UDim2.new(0, -10, 0, -10)
    glowFrame.BackgroundColor3 = config.GlowColor
    glowFrame.BackgroundTransparency = 1
    glowFrame.ZIndex = target.ZIndex - 1
    glowFrame.Parent = target.Parent
    
    -- Add corner radius if target has one
    if target:FindFirstChild("UICorner") then
        local corner = Instance.new("UICorner")
        corner.CornerRadius = target.UICorner.CornerRadius
        corner.Parent = glowFrame
    end
    
    -- Animate glow
    local glowIn = TweenService:Create(glowFrame, TweenInfo.new(duration * 0.2), {
        BackgroundTransparency = 0.3
    })
    
    local glowPulse = TweenService:Create(glowFrame, TweenInfo.new(duration * 0.6, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        BackgroundTransparency = 0.1
    })
    
    local glowOut = TweenService:Create(glowFrame, TweenInfo.new(duration * 0.2), {
        BackgroundTransparency = 1
    })
    
    glowIn:Play()
    glowIn.Completed:Connect(function()
        glowPulse:Play()
        
        spawn(function()
            wait(duration * 0.6)
            glowPulse:Cancel()
            glowOut:Play()
            glowOut.Completed:Connect(function()
                glowFrame:Destroy()
            end)
        end)
    end)
    
    return effectID
end

function EffectsController:PlayAudioSequence(rarity: string, isPityResult: boolean): string
    local sequenceID = self:_generateEffectID()
    local config = RARITY_CONFIGS[rarity] or RARITY_CONFIGS.Common
    
    -- Create audio sequence
    local audioSequence = {
        SequenceID = sequenceID,
        AudioCues = {},
        TotalDuration = 0,
        IsPlaying = true,
        CurrentCue = 1
    }
    
    -- Add base reveal sound
    table.insert(audioSequence.AudioCues, {
        SoundID = "rbxasset://sounds/electronicpingshort.wav",
        Volume = 0.3,
        Pitch = config.AudioFrequency / 440,
        PlayTime = 0,
        Duration = 0.5,
        FadeIn = 0.1,
        FadeOut = 0.1,
        Loop = false,
        Rarity = rarity
    })
    
    -- Add pity result sound
    if isPityResult then
        table.insert(audioSequence.AudioCues, {
            SoundID = "rbxasset://sounds/button_rollover.wav",
            Volume = 0.5,
            Pitch = 1.2,
            PlayTime = 0.3,
            Duration = 0.8,
            FadeIn = 0.2,
            FadeOut = 0.2,
            Loop = false,
            Rarity = rarity
        })
    end
    
    -- Add rarity-specific sound
    if config.EffectIntensity > 0.5 then
        table.insert(audioSequence.AudioCues, {
            SoundID = "rbxasset://sounds/impact_generic.mp3",
            Volume = config.EffectIntensity * 0.4,
            Pitch = 0.8 + (config.EffectIntensity * 0.4),
            PlayTime = 0.5,
            Duration = 1.0,
            FadeIn = 0.1,
            FadeOut = 0.3,
            Loop = false,
            Rarity = rarity
        })
    end
    
    -- Calculate total duration
    local totalDuration = 0
    for _, cue in ipairs(audioSequence.AudioCues) do
        totalDuration = math.max(totalDuration, cue.PlayTime + cue.Duration)
    end
    audioSequence.TotalDuration = totalDuration
    
    -- Play sequence
    self:_playAudioSequence(audioSequence)
    
    -- Store sequence
    self._audioSequences[sequenceID] = audioSequence
    
    return sequenceID
end

function EffectsController:ClearAllEffects()
    -- Clear visual effects
    for effectID, effect in pairs(self._activeEffects) do
        if effect.Target and effect.Target.Parent then
            -- Clean up effect elements
            local effectElements = effect.Target:GetChildren()
            for _, element in ipairs(effectElements) do
                if string.find(element.Name, "Effect") or string.find(element.Name, "Particle") then
                    element:Destroy()
                end
            end
        end
    end
    
    -- Clear screen effects
    for effectID, effect in pairs(self._screenEffects) do
        if effect.Properties.Frame then
            effect.Properties.Frame:Destroy()
        end
    end
    
    -- Clear audio sequences
    for sequenceID, sequence in pairs(self._audioSequences) do
        -- Stop audio playback
        sequence.IsPlaying = false
    end
    
    -- Reset screen shake
    self._screenShakeData.Trauma = 0
    self._screenShakeData.Intensity = 0
    
    -- Clear tracking tables
    self._activeEffects = {}
    self._screenEffects = {}
    self._audioSequences = {}
    
    self:_log("All effects cleared")
end

function EffectsController:GetActiveEffectCount(): number
    return self._effectCount
end

function EffectsController:GetPerformanceMetrics(): UITypes.PerformanceMetrics
    return {
        FrameRate = 1 / RunService.Heartbeat:Wait(),
        MemoryUsage = collectgarbage("count"),
        ActiveAnimations = #TweenService:GetPlayingTweens(),
        ActiveEffects = self._effectCount,
        RenderTime = RunService.Heartbeat:Wait() * 1000,
        LastUpdateTime = os.clock()
    }
end

-- Private Methods

function EffectsController:_createCardEffectSequence(cardResult: RollTypes.CardRollResult, targetElement: GuiObject, config: RarityVisualConfig): UITypes.CardAnimationSequence
    local sequence = {
        CardID = cardResult.Card.ID,
        Rarity = cardResult.Rarity,
        Animations = {},
        TotalDuration = config.AnimationDuration,
        EffectIntensity = cardResult.EffectIntensity
    }
    
    -- Scale animation
    table.insert(sequence.Animations, {
        StepName = "ScaleUp",
        StartTime = 0,
        Duration = config.AnimationDuration * 0.3,
        AnimationType = "Size",
        Properties = {
            Size = UDim2.new(1.1, 0, 1.1, 0)
        },
        EasingData = {
            Duration = config.AnimationDuration * 0.3,
            EasingStyle = Enum.EasingStyle.Back,
            EasingDirection = Enum.EasingDirection.Out,
            RepeatCount = 0,
            Reverses = false,
            DelayTime = 0
        },
        AudioCue = "scale_up"
    })
    
    -- Scale back
    table.insert(sequence.Animations, {
        StepName = "ScaleDown",
        StartTime = config.AnimationDuration * 0.3,
        Duration = config.AnimationDuration * 0.2,
        AnimationType = "Size",
        Properties = {
            Size = UDim2.new(1, 0, 1, 0)
        },
        EasingData = {
            Duration = config.AnimationDuration * 0.2,
            EasingStyle = Enum.EasingStyle.Back,
            EasingDirection = Enum.EasingDirection.Out,
            RepeatCount = 0,
            Reverses = false,
            DelayTime = 0
        }
    })
    
    -- Play animation sequence
    self:_playAnimationSequence(sequence, targetElement)
    
    return sequence
end

function EffectsController:_playAnimationSequence(sequence: UITypes.CardAnimationSequence, targetElement: GuiObject)
    for _, animation in ipairs(sequence.Animations) do
        spawn(function()
            wait(animation.StartTime)
            
            local tween = TweenService:Create(
                targetElement,
                TweenInfo.new(
                    animation.Duration,
                    animation.EasingData.EasingStyle,
                    animation.EasingData.EasingDirection,
                    animation.EasingData.RepeatCount,
                    animation.EasingData.Reverses,
                    animation.EasingData.DelayTime
                ),
                animation.Properties
            )
            
            tween:Play()
            
            if animation.AudioCue then
                -- Play audio cue
                self:_playAudioCue(animation.AudioCue)
            end
        end)
    end
end

function EffectsController:_playParticleEffects(target: GuiObject, config: RarityVisualConfig, intensity: number)
    -- Create sparkle particles
    self:CreateParticleEffect(target, config, config.AnimationDuration * 0.8)
    
    -- Create glow effect
    self:CreateGlowEffect(target, config, config.AnimationDuration)
    
    -- Create additional effects for high-rarity cards
    if intensity > 0.7 then
        -- Create burst effect
        spawn(function()
            wait(config.AnimationDuration * 0.2)
            self:_createBurstEffect(target, config)
        end)
    end
end

function EffectsController:_playScreenEffects(config: RarityVisualConfig, intensity: number)
    -- Screen flash for high-intensity effects
    if intensity > 0.6 then
        self:PlayScreenFlash(config.GlowColor, config.FlashIntensity * intensity, 0.3)
    end
    
    -- Screen distortion for ultimate rarity
    if intensity >= 1.0 then
        self:_createScreenDistortion(config, 0.5)
    end
end

function EffectsController:_playAudioEffects(rarity: string, config: RarityVisualConfig, isPityResult: boolean)
    self:PlayAudioSequence(rarity, isPityResult)
end

function EffectsController:_createParticle(container: Frame, config: RarityVisualConfig, duration: number)
    local particle = Instance.new("Frame")
    particle.Name = "Particle"
    particle.Size = UDim2.new(0, math.random(2, 6), 0, math.random(2, 6))
    particle.Position = UDim2.new(math.random(), 0, math.random(), 0)
    particle.BackgroundColor3 = config.ParticleColor
    particle.BackgroundTransparency = 0.3
    particle.ZIndex = 100
    particle.Parent = container
    
    -- Add corner radius
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(1, 0)
    corner.Parent = particle
    
    -- Animate particle
    local endPosition = UDim2.new(
        math.random(),
        math.random(-50, 50),
        math.random(),
        math.random(-50, 50)
    )
    
    local moveTween = TweenService:Create(particle, TweenInfo.new(duration, Enum.EasingStyle.Quad), {
        Position = endPosition,
        BackgroundTransparency = 1
    })
    
    moveTween:Play()
    moveTween.Completed:Connect(function()
        particle:Destroy()
    end)
end

function EffectsController:_createBurstEffect(target: GuiObject, config: RarityVisualConfig)
    local burstCount = math.floor(config.EffectIntensity * 8) + 4
    
    for i = 1, burstCount do
        local burst = Instance.new("Frame")
        burst.Name = "BurstEffect"
        burst.Size = UDim2.new(0, 4, 0, 20)
        burst.Position = UDim2.new(0.5, -2, 0.5, -10)
        burst.BackgroundColor3 = config.GlowColor
        burst.BackgroundTransparency = 0.2
        burst.ZIndex = 75
        burst.Parent = target
        
        -- Rotate burst
        burst.Rotation = (360 / burstCount) * i
        
        -- Animate burst
        local scaleTween = TweenService:Create(burst, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
            Size = UDim2.new(0, 2, 0, 60),
            BackgroundTransparency = 1
        })
        
        scaleTween:Play()
        scaleTween.Completed:Connect(function()
            burst:Destroy()
        end)
    end
end

function EffectsController:_createScreenDistortion(config: RarityVisualConfig, duration: number)
    -- Create subtle screen distortion effect
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    local distortionFrame = Instance.new("Frame")
    distortionFrame.Name = "ScreenDistortion"
    distortionFrame.Size = UDim2.new(1, 0, 1, 0)
    distortionFrame.Position = UDim2.new(0, 0, 0, 0)
    distortionFrame.BackgroundColor3 = config.GlowColor
    distortionFrame.BackgroundTransparency = 0.95
    distortionFrame.ZIndex = 999
    distortionFrame.Parent = playerGui
    
    -- Animate distortion
    local distortTween = TweenService:Create(distortionFrame, TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 1, true), {
        BackgroundTransparency = 0.9
    })
    
    distortTween:Play()
    distortTween.Completed:Connect(function()
        distortionFrame:Destroy()
    end)
end

function EffectsController:_updateScreenShake()
    local currentTime = os.clock()
    local elapsed = currentTime - self._screenShakeData.StartTime
    
    if self._screenShakeData.Trauma <= 0 or elapsed > self._screenShakeData.Duration then
        -- Reset camera if shake is done
        if self._screenShakeData.Trauma > 0 then
            self._camera.CFrame = self._originalCFrame
            self._screenShakeData.Trauma = 0
        end
        return
    end
    
    -- Update trauma decay
    self._screenShakeData.Trauma = self._screenShakeData.Trauma * (1 - self._screenShakeData.Decay * RunService.Heartbeat:Wait())
    
    -- Calculate shake intensity
    local shakeIntensity = self._screenShakeData.Trauma ^ SCREEN_SHAKE_CONFIG.TraumaPower
    
    -- Generate noise-based shake
    local noise = math.noise(currentTime * self._screenShakeData.Frequency, 0, 0)
    local shakeX = noise * SCREEN_SHAKE_CONFIG.MaxOffset * shakeIntensity
    local shakeY = math.noise(0, currentTime * self._screenShakeData.Frequency, 0) * SCREEN_SHAKE_CONFIG.MaxOffset * shakeIntensity
    local shakeRot = math.noise(0, 0, currentTime * self._screenShakeData.Frequency) * SCREEN_SHAKE_CONFIG.MaxRotation * shakeIntensity
    
    -- Apply shake to camera
    self._camera.CFrame = self._originalCFrame * CFrame.new(shakeX, shakeY, 0) * CFrame.Angles(0, 0, math.rad(shakeRot))
    
    -- Update original CFrame reference
    self._originalCFrame = workspace.CurrentCamera.CFrame * CFrame.new(-shakeX, -shakeY, 0) * CFrame.Angles(0, 0, -math.rad(shakeRot))
end

function EffectsController:_playAudioSequence(sequence: UITypes.AudioSequence)
    for _, cue in ipairs(sequence.AudioCues) do
        spawn(function()
            wait(cue.PlayTime)
            
            if sequence.IsPlaying then
                local sound = Instance.new("Sound")
                sound.SoundId = cue.SoundID
                sound.Volume = cue.Volume
                sound.Pitch = cue.Pitch
                sound.Parent = SoundService
                
                sound:Play()
                
                -- Clean up sound after it finishes
                sound.Ended:Connect(function()
                    sound:Destroy()
                end)
            end
        end)
    end
end

function EffectsController:_playAudioCue(cueName: string)
    -- Play simple audio cue
    local sound = Instance.new("Sound")
    sound.SoundId = "rbxasset://sounds/electronicpingshort.wav"
    sound.Volume = 0.2
    sound.Pitch = 1.0
    sound.Parent = SoundService
    
    sound:Play()
    sound.Ended:Connect(function()
        sound:Destroy()
    end)
end

function EffectsController:_initializeParticlePools()
    -- Initialize particle object pools for performance
    self._particlePool = {}
    self._effectPool = {}
    
    self:_log("Particle pools initialized")
end

function EffectsController:_initializeAudioSystem()
    -- Initialize audio system
    self._audioCount = 0
    self:_log("Audio system initialized")
end

function EffectsController:_startPerformanceMonitoring()
    self._performanceConnection = RunService.Heartbeat:Connect(function()
        -- Update effect counts
        self._effectCount = 0
        for _ in pairs(self._activeEffects) do
            self._effectCount += 1
        end
        
        -- Clean up expired effects
        local currentTime = os.clock()
        for effectID, effect in pairs(self._activeEffects) do
            if currentTime > effect.EndTime then
                self._activeEffects[effectID] = nil
            end
        end
        
        -- Clean up expired screen effects
        for effectID, effect in pairs(self._screenEffects) do
            if currentTime > effect.StartTime + effect.Duration then
                self._screenEffects[effectID] = nil
            end
        end
    end)
end

function EffectsController:_generateEffectID(): string
    return "effect_" .. tostring(os.time()) .. "_" .. tostring(math.random(1000, 9999))
end

return EffectsController.new() 
--- FILE: ./src/client/Controllers/CardRevealController.luau ---
--!strict
-- CardRevealController.luau
-- Main controller for card reveal UI system with psychological timing and responsive design

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local GuiService = game:GetService("GuiService")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local UITypes = require(ReplicatedStorage.Shared.Types.UITypes)
local RollTypes = require(ReplicatedStorage.Shared.Types.RollTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type CardRevealRequest = UITypes.CardRevealRequest
type CardRevealResult = UITypes.CardRevealResult
type CardRevealState = UITypes.CardRevealState
type RevealUIElements = UITypes.RevealUIElements
type CardDisplayElement = UITypes.CardDisplayElement
type CardLayoutConfig = UITypes.CardLayoutConfig

local CardRevealController = {}
CardRevealController.__index = CardRevealController
setmetatable(CardRevealController, {__index = BaseController})

-- UI Configuration
local UI_CONFIG = {
    CardSize = UDim2.new(0, 200, 0, 280),
    CardSpacing = 20,
    MaxCardsPerRow = 5,
    AnimationDuration = 0.8,
    RevealDelay = 0.3,
    SkipThreshold = 0.5,
    ResponsiveBreakpoints = {
        Mobile = 768,
        Tablet = 1024,
        Desktop = 1920
    }
}

-- Reveal State
local REVEAL_STATES = {
    IDLE = "Idle",
    PREPARING = "Preparing",
    REVEALING = "Revealing",
    COMPLETED = "Completed",
    SKIPPED = "Skipped"
}

function CardRevealController.new()
    local self = BaseController.new("CardRevealController", {"EffectsController"})
    setmetatable(self, CardRevealController)
    
    -- UI State
    self._currentState = REVEAL_STATES.IDLE
    self._revealQueue = {} :: {CardRevealRequest}
    self._currentReveal = nil :: CardRevealRequest?
    self._revealState = nil :: CardRevealState?
    
    -- UI Elements
    self._uiElements = nil :: RevealUIElements?
    self._cardDisplays = {} :: {CardDisplayElement}
    
    -- Input handling
    self._inputConnections = {}
    self._lastInputTime = 0
    
    -- Performance tracking
    self._revealCount = 0
    self._averageRevealTime = 0
    self._skipRate = 0
    
    -- Device detection
    self._deviceType = self:_detectDeviceType()
    self._layoutConfig = self:_getLayoutConfig()
    
    return self
end

function CardRevealController:Initialize()
    self:_log("CardRevealController initializing...")
    
    -- Initialize UI elements
    self:_initializeUI()
    
    -- Setup input handlers
    self:_setupInputHandlers()
    
    -- Setup remote event handlers
    self:_setupRemoteHandlers()
    
    self:_log("CardRevealController initialized successfully")
end

function CardRevealController:Start()
    self:_log("CardRevealController starting...")
    
    -- Start reveal processing
    self._revealProcessingConnection = RunService.Heartbeat:Connect(function()
        self:_processRevealQueue()
    end)
    
    self:_log("CardRevealController started successfully")
end

function CardRevealController:Stop()
    self:_log("CardRevealController stopping...")
    
    -- Clean up connections
    if self._revealProcessingConnection then
        self._revealProcessingConnection:Disconnect()
    end
    
    self:_cleanupInputHandlers()
    
    -- Clear UI
    if self._uiElements then
        self._uiElements.MainFrame:Destroy()
    end
    
    self:_log("CardRevealController stopped")
end

-- Public Methods

-- Simple method for revealing a single card
function CardRevealController:RevealSingleCard(cardResult: RollTypes.CardRollResult)
	-- Create a simple request for a single card
	local request: CardRevealRequest = {
		Cards = {cardResult},
		PlayerId = game.Players.LocalPlayer.UserId,
		SessionId = "single_card_" .. os.time(),
		RequestTime = os.time(),
		Source = "TestScene",
		Priority = "Normal"
	}
	
	return self:RevealCards(request)
end

function CardRevealController:RevealCards(request: CardRevealRequest): CardRevealResult
    self:_log("Revealing " .. #request.Cards .. " cards with type: " .. request.RevealType)
    
    -- Validate request
    if not self:_validateRevealRequest(request) then
        return {
            Success = false,
            CardsRevealed = 0,
            TotalDuration = 0,
            UserSkipped = false,
            ErrorMessage = "Invalid reveal request"
        }
    end
    
    -- Add to queue if currently revealing
    if self._currentState ~= REVEAL_STATES.IDLE then
        table.insert(self._revealQueue, request)
        return {
            Success = true,
            CardsRevealed = 0,
            TotalDuration = 0,
            UserSkipped = false,
            ErrorMessage = "Added to reveal queue"
        }
    end
    
    -- Start reveal process
    return self:_startRevealProcess(request)
end

function CardRevealController:SkipCurrentReveal(): boolean
    if self._currentState ~= REVEAL_STATES.REVEALING then
        return false
    end
    
    if not self._revealState or not self._revealState.CanSkip then
        return false
    end
    
    self:_log("Skipping current reveal")
    
    -- Update state
    self._currentState = REVEAL_STATES.SKIPPED
    self._revealState.IsPaused = true
    
    -- Complete all pending animations instantly
    self:_skipAllAnimations()
    
    -- Show final state
    self:_showFinalRevealState()
    
    -- Update statistics
    self._skipRate = (self._skipRate + 1) / 2
    
    return true
end

function CardRevealController:PauseReveal(): boolean
    if self._currentState ~= REVEAL_STATES.REVEALING then
        return false
    end
    
    if not self._revealState then
        return false
    end
    
    self._revealState.IsPaused = true
    self:_log("Reveal paused")
    
    return true
end

function CardRevealController:ResumeReveal(): boolean
    if self._currentState ~= REVEAL_STATES.REVEALING then
        return false
    end
    
    if not self._revealState then
        return false
    end
    
    self._revealState.IsPaused = false
    self:_log("Reveal resumed")
    
    return true
end

function CardRevealController:GetCurrentRevealState(): CardRevealState?
    return self._revealState
end

function CardRevealController:IsRevealing(): boolean
    return self._currentState == REVEAL_STATES.REVEALING
end

function CardRevealController:GetRevealStatistics(): {[string]: any}
    return {
        RevealCount = self._revealCount,
        AverageRevealTime = self._averageRevealTime,
        SkipRate = self._skipRate,
        DeviceType = self._deviceType,
        QueueSize = #self._revealQueue
    }
end

-- Private Methods

function CardRevealController:_initializeUI()
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    -- Create main UI structure
    local mainFrame = Instance.new("ScreenGui")
    mainFrame.Name = "CardRevealUI"
    mainFrame.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    mainFrame.ResetOnSpawn = false
    mainFrame.Parent = playerGui
    
    -- Create reveal container
    local revealContainer = Instance.new("Frame")
    revealContainer.Name = "RevealContainer"
    revealContainer.Size = UDim2.new(1, 0, 1, 0)
    revealContainer.Position = UDim2.new(0, 0, 0, 0)
    revealContainer.BackgroundColor3 = Color3.new(0, 0, 0)
    revealContainer.BackgroundTransparency = 0.8
    revealContainer.Visible = false
    revealContainer.ZIndex = 100
    revealContainer.Parent = mainFrame
    
    -- Create background overlay
    local backgroundOverlay = Instance.new("Frame")
    backgroundOverlay.Name = "BackgroundOverlay"
    backgroundOverlay.Size = UDim2.new(1, 0, 1, 0)
    backgroundOverlay.Position = UDim2.new(0, 0, 0, 0)
    backgroundOverlay.BackgroundColor3 = Color3.new(0, 0, 0)
    backgroundOverlay.BackgroundTransparency = 0.5
    backgroundOverlay.ZIndex = 10
    backgroundOverlay.Parent = revealContainer
    
    -- Create effects layer
    local effectsLayer = Instance.new("Frame")
    effectsLayer.Name = "EffectsLayer"
    effectsLayer.Size = UDim2.new(1, 0, 1, 0)
    effectsLayer.Position = UDim2.new(0, 0, 0, 0)
    effectsLayer.BackgroundTransparency = 1
    effectsLayer.ZIndex = 200
    effectsLayer.Parent = revealContainer
    
    -- Create progress bar
    local progressBar = Instance.new("Frame")
    progressBar.Name = "ProgressBar"
    progressBar.Size = UDim2.new(0.8, 0, 0, 4)
    progressBar.Position = UDim2.new(0.1, 0, 0.95, 0)
    progressBar.BackgroundColor3 = Color3.new(1, 1, 1)
    progressBar.BackgroundTransparency = 0.3
    progressBar.ZIndex = 150
    progressBar.Parent = revealContainer
    
    -- Progress fill
    local progressFill = Instance.new("Frame")
    progressFill.Name = "ProgressFill"
    progressFill.Size = UDim2.new(0, 0, 1, 0)
    progressFill.Position = UDim2.new(0, 0, 0, 0)
    progressFill.BackgroundColor3 = Color3.new(0.3, 0.8, 1)
    progressFill.BackgroundTransparency = 0
    progressFill.ZIndex = 151
    progressFill.Parent = progressBar
    
    -- Create skip button
    local skipButton = Instance.new("TextButton")
    skipButton.Name = "SkipButton"
    skipButton.Size = UDim2.new(0, 100, 0, 40)
    skipButton.Position = UDim2.new(1, -120, 0, 20)
    skipButton.BackgroundColor3 = Color3.new(0.8, 0.3, 0.3)
    skipButton.BackgroundTransparency = 0.2
    skipButton.Text = "Skip"
    skipButton.TextColor3 = Color3.new(1, 1, 1)
    skipButton.TextScaled = true
    skipButton.ZIndex = 150
    skipButton.Parent = revealContainer
    
    -- Skip button corner
    local skipCorner = Instance.new("UICorner")
    skipCorner.CornerRadius = UDim.new(0, 8)
    skipCorner.Parent = skipButton
    
    -- Create continue button
    local continueButton = Instance.new("TextButton")
    continueButton.Name = "ContinueButton"
    continueButton.Size = UDim2.new(0, 120, 0, 40)
    continueButton.Position = UDim2.new(0.5, -60, 0.9, 0)
    continueButton.BackgroundColor3 = Color3.new(0.3, 0.8, 0.3)
    continueButton.BackgroundTransparency = 0.2
    continueButton.Text = "Continue"
    continueButton.TextColor3 = Color3.new(1, 1, 1)
    continueButton.TextScaled = true
    continueButton.Visible = false
    continueButton.ZIndex = 150
    continueButton.Parent = revealContainer
    
    -- Continue button corner
    local continueCorner = Instance.new("UICorner")
    continueCorner.CornerRadius = UDim.new(0, 8)
    continueCorner.Parent = continueButton
    
    -- Store UI elements
    self._uiElements = {
        MainFrame = mainFrame,
        RevealContainer = revealContainer,
        CardDisplays = {},
        ProgressBar = progressBar,
        SkipButton = skipButton,
        ContinueButton = continueButton,
        BackgroundOverlay = backgroundOverlay,
        EffectsLayer = effectsLayer
    }
    
    self:_log("UI elements initialized")
end

function CardRevealController:_setupInputHandlers()
    -- Skip button handler
    self._inputConnections.SkipButton = self._uiElements.SkipButton.MouseButton1Click:Connect(function()
        self:SkipCurrentReveal()
    end)
    
    -- Continue button handler
    self._inputConnections.ContinueButton = self._uiElements.ContinueButton.MouseButton1Click:Connect(function()
        self:_completeReveal()
    end)
    
    -- Keyboard input
    self._inputConnections.KeyboardInput = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.Space then
            if self._currentState == REVEAL_STATES.REVEALING then
                self:SkipCurrentReveal()
            end
        elseif input.KeyCode == Enum.KeyCode.Return then
            if self._currentState == REVEAL_STATES.COMPLETED then
                self:_completeReveal()
            end
        end
    end)
    
    -- Touch input for mobile
    if self._deviceType == "Mobile" then
        self._inputConnections.TouchInput = UserInputService.TouchTap:Connect(function(touchPositions, gameProcessed)
            if gameProcessed then return end
            
            local currentTime = os.clock()
            if currentTime - self._lastInputTime < 0.5 then
                -- Double tap to skip
                self:SkipCurrentReveal()
            end
            self._lastInputTime = currentTime
        end)
    end
end

function CardRevealController:_setupRemoteHandlers()
	-- Setup remote event handlers for server communication
	-- TODO: Create CardRevealRequest remote event in appropriate service
	-- RemoteEventHandler:ConnectRemoteEventClient("CardRevealRequest", function(revealData)
	--     local request = {
	--         Cards = revealData.Cards,
	--         PlayerID = revealData.PlayerID,
	--         RevealSettings = revealData.RevealSettings or {}
	--     }
	--     
	--     self:RevealCards(request)
	-- end)
end

function CardRevealController:_startRevealProcess(request: CardRevealRequest): CardRevealResult
    local startTime = os.clock()
    
    -- Update state
    self._currentState = REVEAL_STATES.PREPARING
    self._currentReveal = request
    
    -- Initialize reveal state
    self._revealState = {
        CurrentCard = 0,
        TotalCards = #request.Cards,
        RevealStartTime = startTime,
        IsRevealing = true,
        IsPaused = false,
        CanSkip = true,
        RevealProgress = 0
    }
    
    -- Show UI
    self._uiElements.RevealContainer.Visible = true
    
    -- Create card displays
    self:_createCardDisplays(request.Cards)
    
    -- Start reveal sequence
    self:_startRevealSequence(request)
    
    return {
        Success = true,
        CardsRevealed = #request.Cards,
        TotalDuration = request.TotalDuration,
        UserSkipped = false
    }
end

function CardRevealController:_createCardDisplays(cards: {RollTypes.CardRollResult})
    -- Clear existing displays
    for _, display in ipairs(self._cardDisplays) do
        display.Frame:Destroy()
    end
    self._cardDisplays = {}
    
    -- Calculate layout
    local layout = self:_calculateCardLayout(#cards)
    
    -- Create card displays
    for i, cardResult in ipairs(cards) do
        local cardDisplay = self:_createCardDisplay(cardResult, i, layout)
        table.insert(self._cardDisplays, cardDisplay)
    end
end

function CardRevealController:_createCardDisplay(cardResult: RollTypes.CardRollResult, index: number, layout: CardLayoutConfig): CardDisplayElement
    local card = cardResult.Card
    local rarity = cardResult.Rarity
    
    -- Calculate position
    local row = math.floor((index - 1) / layout.MaxCardsPerRow)
    local col = (index - 1) % layout.MaxCardsPerRow
    local totalRows = math.ceil(self._revealState.TotalCards / layout.MaxCardsPerRow)
    
    -- Center the layout
    local startX = (1 - (math.min(layout.MaxCardsPerRow, self._revealState.TotalCards) * layout.CardSize.X.Scale + (layout.MaxCardsPerRow - 1) * layout.CardSpacing / 1000)) / 2
    local startY = (1 - (totalRows * layout.CardSize.Y.Scale + (totalRows - 1) * layout.CardSpacing / 1000)) / 2
    
    local position = UDim2.new(
        startX + col * (layout.CardSize.X.Scale + layout.CardSpacing / 1000),
        0,
        startY + row * (layout.CardSize.Y.Scale + layout.CardSpacing / 1000),
        0
    )
    
    -- Create card frame
    local cardFrame = Instance.new("Frame")
    cardFrame.Name = "CardDisplay_" .. index
    cardFrame.Size = layout.CardSize
    cardFrame.Position = position
    cardFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    cardFrame.BackgroundTransparency = 0.1
    cardFrame.ZIndex = 50
    cardFrame.Parent = self._uiElements.RevealContainer
    
    -- Add corner radius
    local cardCorner = Instance.new("UICorner")
    cardCorner.CornerRadius = UDim.new(0, 12)
    cardCorner.Parent = cardFrame
    
    -- Create card image
    local cardImage = Instance.new("ImageLabel")
    cardImage.Name = "CardImage"
    cardImage.Size = UDim2.new(1, -20, 0.7, -20)
    cardImage.Position = UDim2.new(0, 10, 0, 10)
    cardImage.BackgroundTransparency = 1
    cardImage.Image = card.Image or ""
    cardImage.ImageTransparency = 1 -- Start hidden
    cardImage.ZIndex = 51
    cardImage.Parent = cardFrame
    
    -- Create rarity border
    local rarityBorder = Instance.new("Frame")
    rarityBorder.Name = "RarityBorder"
    rarityBorder.Size = UDim2.new(1, 4, 1, 4)
    rarityBorder.Position = UDim2.new(0, -2, 0, -2)
    rarityBorder.BackgroundColor3 = GameConstants.RarityColors[rarity] or Color3.new(0.7, 0.7, 0.7)
    rarityBorder.BackgroundTransparency = 0.3
    rarityBorder.ZIndex = 49
    rarityBorder.Parent = cardFrame
    
    -- Border corner
    local borderCorner = Instance.new("UICorner")
    borderCorner.CornerRadius = UDim.new(0, 14)
    borderCorner.Parent = rarityBorder
    
    -- Create name label
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, -20, 0.15, 0)
    nameLabel.Position = UDim2.new(0, 10, 0.75, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = card.Name
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.TextTransparency = 1 -- Start hidden
    nameLabel.ZIndex = 52
    nameLabel.Parent = cardFrame
    
    -- Create stats frame
    local statsFrame = Instance.new("Frame")
    statsFrame.Name = "StatsFrame"
    statsFrame.Size = UDim2.new(1, -20, 0.1, 0)
    statsFrame.Position = UDim2.new(0, 10, 0.85, 0)
    statsFrame.BackgroundTransparency = 1
    statsFrame.ZIndex = 52
    statsFrame.Parent = cardFrame
    
    -- Attack stat
    local attackLabel = Instance.new("TextLabel")
    attackLabel.Name = "AttackLabel"
    attackLabel.Size = UDim2.new(0.5, -5, 1, 0)
    attackLabel.Position = UDim2.new(0, 0, 0, 0)
    attackLabel.BackgroundTransparency = 1
    attackLabel.Text = "ATK: " .. card.Attack
    attackLabel.TextColor3 = Color3.new(1, 0.8, 0.8)
    attackLabel.TextScaled = true
    attackLabel.Font = Enum.Font.SourceSans
    attackLabel.TextTransparency = 1 -- Start hidden
    attackLabel.ZIndex = 53
    attackLabel.Parent = statsFrame
    
    -- Defense stat
    local defenseLabel = Instance.new("TextLabel")
    defenseLabel.Name = "DefenseLabel"
    defenseLabel.Size = UDim2.new(0.5, -5, 1, 0)
    defenseLabel.Position = UDim2.new(0.5, 5, 0, 0)
    defenseLabel.BackgroundTransparency = 1
    defenseLabel.Text = "DEF: " .. card.Defense
    defenseLabel.TextColor3 = Color3.new(0.8, 0.8, 1)
    defenseLabel.TextScaled = true
    defenseLabel.Font = Enum.Font.SourceSans
    defenseLabel.TextTransparency = 1 -- Start hidden
    defenseLabel.ZIndex = 53
    defenseLabel.Parent = statsFrame
    
    -- Create effect container
    local effectContainer = Instance.new("Frame")
    effectContainer.Name = "EffectContainer"
    effectContainer.Size = UDim2.new(1, 0, 1, 0)
    effectContainer.Position = UDim2.new(0, 0, 0, 0)
    effectContainer.BackgroundTransparency = 1
    effectContainer.ZIndex = 60
    effectContainer.Parent = cardFrame
    
    -- Set initial scale (hidden)
    cardFrame.Size = UDim2.new(0, 0, 0, 0)
    cardFrame.Position = UDim2.new(position.X.Scale + layout.CardSize.X.Scale / 2, 0, position.Y.Scale + layout.CardSize.Y.Scale / 2, 0)
    
    return {
        Frame = cardFrame,
        CardImage = cardImage,
        RarityBorder = rarityBorder,
        NameLabel = nameLabel,
        StatsFrame = statsFrame,
        EffectContainer = effectContainer,
        IsVisible = false,
        CurrentCard = card
    }
end

function CardRevealController:_startRevealSequence(request: CardRevealRequest)
    self._currentState = REVEAL_STATES.REVEALING
    
    -- Calculate timing for reveals
    local totalDuration = request.TotalDuration
    local cardDelay = totalDuration / #request.Cards
    
    -- Skip animations if requested
    if request.SkipAnimations then
        self:_skipAllAnimations()
        return
    end
    
    -- Reveal cards with staggered timing
    for i, cardResult in ipairs(request.Cards) do
        spawn(function()
            local delay = cardResult.AnimationDelay / 1000 -- Convert to seconds
            wait(delay)
            
            if self._currentState == REVEAL_STATES.REVEALING and not self._revealState.IsPaused then
                self:_revealCard(cardResult, self._cardDisplays[i])
            end
        end)
    end
    
    -- Start progress tracking
    self:_startProgressTracking(totalDuration)
end

function CardRevealController:_revealCard(cardResult: RollTypes.CardRollResult, cardDisplay: CardDisplayElement)
	self:_log("Revealing card: " .. cardResult.Card.Name .. " (" .. cardResult.Rarity .. ")")
	
	-- Update card display
	if cardDisplay.CardImage then
		cardDisplay.CardImage.Image = cardResult.Card.Image
	end
	
	-- Play all effects
	local effectsController = self:_getService("EffectsController")
	local polishEffectsController = self:_getService("PolishEffectsController")
	
	if effectsController and polishEffectsController then
		-- Play the card reveal effect with enhanced particle system
		effectsController:PlayCardRevealEffects(cardResult, cardDisplay.EffectContainer)
		
		-- Add advanced screen effects for high rarities
		if cardResult.Rarity == "Legendary" or cardResult.Rarity == "Ultimate" then
			polishEffectsController:PlayScreenEffect("Bloom", 0.8, 1.5)
			polishEffectsController:PlayScreenEffect("ChromaticAberration", 0.6, 1.0)
		elseif cardResult.Rarity == "Epic" then
			polishEffectsController:PlayScreenEffect("Bloom", 0.5, 1.0)
		end
		
		-- Add rarity-specific particle effects
		local cardPosition = polishEffectsController:_getWorldPositionFromGui(cardDisplay.Frame)
		
		if cardResult.Rarity == "Ultimate" then
			polishEffectsController:SpawnParticleEffect("RainbowCosmos", cardPosition, cardDisplay.Frame)
			-- Add multiple layered effects for ultimate rarity
			spawn(function()
				wait(0.5)
				polishEffectsController:SpawnParticleEffect("GoldenNova", cardPosition, cardDisplay.Frame)
			end)
		elseif cardResult.Rarity == "Legendary" then
			polishEffectsController:SpawnParticleEffect("GoldenNova", cardPosition, cardDisplay.Frame)
			-- Add secondary sparkle layer
			spawn(function()
				wait(0.3)
				polishEffectsController:SpawnParticleEffect("CardSparkle", cardPosition, cardDisplay.Frame)
			end)
		elseif cardResult.Rarity == "Epic" then
			polishEffectsController:SpawnParticleEffect("EpicSpark", cardPosition, cardDisplay.Frame)
		elseif cardResult.Rarity == "Rare" then
			polishEffectsController:SpawnParticleEffect("RareGlow", cardPosition, cardDisplay.Frame)
		elseif cardResult.Rarity == "Uncommon" then
			polishEffectsController:SpawnParticleEffect("UncommonShimmer", cardPosition, cardDisplay.Frame)
		else
			-- Common cards get subtle sparkle
			polishEffectsController:SpawnParticleEffect("CardSparkle", cardPosition, cardDisplay.Frame)
		end
	end
	
	-- Update reveal state
	self._revealState.CurrentCard = index
	self._revealState.RevealProgress = index / self._revealState.TotalCards
	
	-- Mark as visible
	cardDisplay.IsVisible = true
	
	-- Check if this is the last card
	if index == self._revealState.TotalCards then
		spawn(function()
			wait(1.0) -- Wait for effects to finish
			self:_onRevealComplete()
		end)
	end
end

function CardRevealController:_skipAllAnimations()
    -- Instantly show all cards
    for i, cardDisplay in ipairs(self._cardDisplays) do
        cardDisplay.Frame.Size = self._layoutConfig.CardSize
        cardDisplay.Frame.Position = UDim2.new(
            cardDisplay.Frame.Position.X.Scale - self._layoutConfig.CardSize.X.Scale / 2,
            0,
            cardDisplay.Frame.Position.Y.Scale - self._layoutConfig.CardSize.Y.Scale / 2,
            0
        )
        
        cardDisplay.CardImage.ImageTransparency = 0
        cardDisplay.NameLabel.TextTransparency = 0
        
        -- Show stats
        local attackLabel = cardDisplay.StatsFrame:FindFirstChild("AttackLabel")
        local defenseLabel = cardDisplay.StatsFrame:FindFirstChild("DefenseLabel")
        
        if attackLabel then attackLabel.TextTransparency = 0 end
        if defenseLabel then defenseLabel.TextTransparency = 0 end
        
        cardDisplay.IsVisible = true
    end
    
    -- Update progress
    self._revealState.RevealProgress = 1.0
    self._revealState.CurrentCard = self._revealState.TotalCards
    
    -- Complete immediately
    self:_onRevealComplete()
end

function CardRevealController:_onRevealComplete()
    self._currentState = REVEAL_STATES.COMPLETED
    
    -- Show continue button
    self._uiElements.ContinueButton.Visible = true
    self._uiElements.SkipButton.Visible = false
    
    -- Update statistics
    local revealTime = os.clock() - self._revealState.RevealStartTime
    self._averageRevealTime = (self._averageRevealTime + revealTime) / 2
    self._revealCount += 1
    
    self:_log("Reveal completed in " .. string.format("%.2f", revealTime) .. " seconds")
end

function CardRevealController:_completeReveal()
    -- Hide UI
    self._uiElements.RevealContainer.Visible = false
    
    -- Clear effects
    local effectsController = self.ServiceRegistry:GetService("EffectsController")
    if effectsController then
        effectsController:ClearAllEffects()
    end
    
    -- Reset state
    self._currentState = REVEAL_STATES.IDLE
    self._currentReveal = nil
    self._revealState = nil
    
    -- Process next in queue
    if #self._revealQueue > 0 then
        local nextReveal = table.remove(self._revealQueue, 1)
        self:RevealCards(nextReveal)
    end
end

function CardRevealController:_startProgressTracking(duration: number)
    spawn(function()
        local startTime = os.clock()
        
        while self._currentState == REVEAL_STATES.REVEALING do
            local elapsed = os.clock() - startTime
            local progress = math.min(elapsed / duration, 1.0)
            
            -- Update progress bar
            local progressFill = self._uiElements.ProgressBar:FindFirstChild("ProgressFill")
            if progressFill then
                progressFill.Size = UDim2.new(progress, 0, 1, 0)
            end
            
            wait(0.1)
        end
    end)
end

function CardRevealController:_processRevealQueue()
    if self._currentState == REVEAL_STATES.IDLE and #self._revealQueue > 0 then
        local nextReveal = table.remove(self._revealQueue, 1)
        self:RevealCards(nextReveal)
    end
end

function CardRevealController:_validateRevealRequest(request: CardRevealRequest): boolean
    return request.Cards and #request.Cards > 0 and #request.Cards <= 10
end

function CardRevealController:_calculateCardLayout(cardCount: number): CardLayoutConfig
    local config = self._layoutConfig
    
    -- Adjust for card count
    if cardCount == 1 then
        config.CardSize = UDim2.new(0, 240, 0, 320)
    elseif cardCount <= 3 then
        config.CardSize = UDim2.new(0, 200, 0, 280)
    else
        config.CardSize = UDim2.new(0, 160, 0, 224)
    end
    
    return config
end

function CardRevealController:_detectDeviceType(): string
    local screenSize = workspace.CurrentCamera.ViewportSize
    local guiInset = GuiService:GetGuiInset()
    local screenWidth = screenSize.X
    
    if UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled then
        return "Mobile"
    elseif screenWidth < UI_CONFIG.ResponsiveBreakpoints.Tablet then
        return "Tablet"
    else
        return "Desktop"
    end
end

function CardRevealController:_getLayoutConfig(): CardLayoutConfig
    local deviceType = self._deviceType
    
    if deviceType == "Mobile" then
        return {
            CardSize = UDim2.new(0, 140, 0, 196),
            CardSpacing = 10,
            MaxCardsPerRow = 3,
            AnimationStartPosition = UDim2.new(0.5, 0, 1.2, 0),
            AnimationEndPosition = UDim2.new(0.5, 0, 0.5, 0),
            ScaleMultiplier = 0.8
        }
    elseif deviceType == "Tablet" then
        return {
            CardSize = UDim2.new(0, 180, 0, 252),
            CardSpacing = 15,
            MaxCardsPerRow = 4,
            AnimationStartPosition = UDim2.new(0.5, 0, 1.2, 0),
            AnimationEndPosition = UDim2.new(0.5, 0, 0.5, 0),
            ScaleMultiplier = 0.9
        }
    else
        return {
            CardSize = UDim2.new(0, 200, 0, 280),
            CardSpacing = 20,
            MaxCardsPerRow = 5,
            AnimationStartPosition = UDim2.new(0.5, 0, 1.2, 0),
            AnimationEndPosition = UDim2.new(0.5, 0, 0.5, 0),
            ScaleMultiplier = 1.0
        }
    end
end

function CardRevealController:_showFinalRevealState()
    -- Show final state of all cards
    for _, cardDisplay in ipairs(self._cardDisplays) do
        if not cardDisplay.IsVisible then
            cardDisplay.Frame.Size = self._layoutConfig.CardSize
            cardDisplay.CardImage.ImageTransparency = 0
            cardDisplay.NameLabel.TextTransparency = 0
            cardDisplay.IsVisible = true
        end
    end
    
    -- Show continue button
    self._uiElements.ContinueButton.Visible = true
    self._uiElements.SkipButton.Visible = false
end

function CardRevealController:_cleanupInputHandlers()
    for _, connection in pairs(self._inputConnections) do
        connection:Disconnect()
    end
    self._inputConnections = {}
end

return CardRevealController.new() 
--- FILE: ./src/client/Controllers/TestCombatController.luau ---
--!strict
-- TestCombatController.luau
-- A simple controller to initiate a test combat sequence.

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local TestCombatController = {}
TestCombatController.__index = TestCombatController
setmetatable(TestCombatController, {__index = BaseController})

function TestCombatController.new()
	local self = BaseController.new("TestCombatController", {"BattleController"})
	setmetatable(self, TestCombatController)
	
	self._testGui = nil
	self._battleButton = nil
	
	return self
end

function TestCombatController:Initialize()
	self:_log("Initializing...")
	self:_createTestUI()
	self:_log("Initialized.")
end

function TestCombatController:Start()
	self:_log("Starting...")
	if self._battleButton then
		self._battleButton.MouseButton1Click:Connect(function()
			self:_startTestBattle()
		end)
	end
	self:_log("Started.")
end

function TestCombatController:_createTestUI()
	self._testGui = Instance.new("ScreenGui")
	self._testGui.Name = "TestCombatGUI"
	self._testGui.Parent = PlayerGui
	
	self._battleButton = Instance.new("TextButton")
	self._battleButton.Name = "StartBattleButton"
	self._battleButton.Size = UDim2.new(0, 200, 0, 50)
	self._battleButton.Position = UDim2.new(0.5, -100, 0.2, 0)
	self._battleButton.Text = "START BATTLE"
	self._battleButton.Parent = self._testGui
end

function TestCombatController:_startTestBattle()
	self:_log("Starting test battle...")
	local battleController = self.ServiceRegistry:GetService("BattleController")
	if battleController then
		battleController:StartBattle({
			OpponentId = "AI_EASY_01",
			BattleType = "PVE",
		})
	end
end

return TestCombatController.new() 
--- FILE: ./src/client/Controllers/BattleController.luau ---
--!strict
-- BattleController.luau
-- Client-side battle controller for elevated 2D combat with visual juice

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local GuiService = game:GetService("GuiService")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local BattleTypes = require(ReplicatedStorage.Shared.Types.BattleTypes)
local UITypes = require(ReplicatedStorage.Shared.Types.UITypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type BattleSession = BattleTypes.BattleSession
type BattleCard = BattleTypes.BattleCard
type BattleUIState = BattleTypes.BattleUIState
type BattleUIElements = BattleTypes.BattleUIElements
type CardUIData = BattleTypes.CardUIData
type BattleAnimation = BattleTypes.BattleAnimation

local BattleController = {}
BattleController.__index = BattleController
setmetatable(BattleController, {__index = BaseController})

-- UI Configuration
local UI_CONFIG = {
    CardSize = UDim2.new(0, 120, 0, 168),
    HandSpacing = 10,
    BattlefieldHeight = 200,
    AnimationDuration = 0.8,
    ImpactFrameDelay = 0.3,
    ScreenShakeIntensity = 0.5,
    HealthBarHeight = 20,
    EnergyBarHeight = 15,
    TurnTimerSize = UDim2.new(0, 200, 0, 30)
}

-- Battle States
local BATTLE_STATES = {
    INACTIVE = "Inactive",
    CONNECTING = "Connecting",
    ACTIVE = "Active",
    WAITING = "Waiting",
    FINISHED = "Finished"
}

function BattleController.new()
    local self = BaseController.new("BattleController", {"EffectsController"})
    setmetatable(self, BattleController)
    
    -- Battle state
    self._battleState = BATTLE_STATES.INACTIVE
    self._currentBattle = nil :: BattleSession?
    self._uiState = nil :: BattleUIState?
    self._uiElements = nil :: BattleUIElements?
    
    -- Card UI tracking
    self._cardUIElements = {} :: {[string]: CardUIData}
    self._handCards = {} :: {CardUIData}
    self._activeAnimations = {} :: {[string]: BattleAnimation}
    
    -- Input handling
    self._selectedCard = nil :: CardUIData?
    self._validTargets = {} :: {CardUIData}
    self._inputConnections = {}
    
    -- Turn management
    self._turnTimeRemaining = 0
    self._isMyTurn = false
    self._canPerformActions = false
    
    -- Performance tracking
    self._frameTime = 0
    self._animationCount = 0
    
    return self
end

function BattleController:Initialize()
    self:_log("BattleController initializing...")
    
    -- Initialize UI
    self:_initializeBattleUI()
    
    -- Setup input handlers
    self:_setupInputHandlers()
    
    -- Setup remote event handlers
    self:_setupRemoteHandlers()
    
    self:_log("BattleController initialized successfully")
end

function BattleController:Start()
    self:_log("BattleController starting...")
    
    -- Start battle update loop
    self._battleUpdateConnection = RunService.Heartbeat:Connect(function(deltaTime)
        self:_updateBattle(deltaTime)
    end)
    
    self:_log("BattleController started successfully")
end

function BattleController:Stop()
    self:_log("BattleController stopping...")
    
    -- Clean up battle
    if self._battleState ~= BATTLE_STATES.INACTIVE then
        self:LeaveBattle()
    end
    
    -- Clean up connections
    if self._battleUpdateConnection then
        self._battleUpdateConnection:Disconnect()
    end
    
    self:_cleanupInputHandlers()
    
    -- Destroy UI
    if self._uiElements then
        self._uiElements.MainFrame:Destroy()
    end
    
    self:_log("BattleController stopped")
end

-- Public Methods

function BattleController:StartBattle(request: BattleTypes.StartBattleRequest)
	self:_log("Starting battle...")
	
	-- Fire server to create battle session
	local result = RemoteEventHandler:InvokeServer("StartBattle", request)
	
	if result and result.Success then
		self:_log("Battle started successfully: " .. result.Data.BattleID)
		self._currentBattleSession = result.Data
		self:_renderBattleState(self._currentBattleSession)
		self:Show() -- Make the battle UI visible
	else
		self:_logError("Failed to start battle: " .. (result and result.ErrorMessage or "Unknown error"))
	end
end

function BattleController:PlayCard(cardUIData: CardUIData, targetPosition: Vector2?)
    if not self:_canPerformAction() then
        return
    end
    
    if not cardUIData or not cardUIData.Frame then
        return
    end
    
    self:_log("Playing card: " .. cardUIData.CardID)
    
    -- Send action to server
    local actionData = {
        ActionType = "PlayCard",
        ActionData = {
            SourceCardID = cardUIData.CardID,
            Position = "Active"
        }
    }
    
    RemoteEventHandler:InvokeServer("BattleAction", actionData)
    
    -- Start play animation
    self:_animateCardPlay(cardUIData, targetPosition)
end

function BattleController:AttackWithCard(attackerCardUIData: CardUIData, targetCardUIData: CardUIData?)
    if not self:_canPerformAction() then
        return
    end
    
    if not attackerCardUIData then
        return
    end
    
    self:_log("Attacking with card: " .. attackerCardUIData.CardID)
    
    -- Send action to server
    local actionData = {
        ActionType = "Attack",
        ActionData = {
            SourceCardID = attackerCardUIData.CardID,
            TargetCardID = targetCardUIData and targetCardUIData.CardID or nil
        }
    }
    
    RemoteEventHandler:InvokeServer("BattleAction", actionData)
    
    -- Start attack animation
    self:_animateAttack(attackerCardUIData, targetCardUIData)
end

function BattleController:EndTurn()
    if not self:_canPerformAction() then
        return
    end
    
    self:_log("Ending turn")
    
    -- Send action to server
    local actionData = {
        ActionType = "EndTurn",
        ActionData = {}
    }
    
    RemoteEventHandler:InvokeServer("BattleAction", actionData)
    
    -- Update UI state
    self._isMyTurn = false
    self._canPerformActions = false
    self:_updateActionButtons()
end

function BattleController:LeaveBattle()
    if self._battleState == BATTLE_STATES.INACTIVE then
        return
    end
    
    self:_log("Leaving battle")
    
    -- Send surrender action if in active battle
    if self._battleState == BATTLE_STATES.ACTIVE then
        local actionData = {
            ActionType = "Surrender",
            ActionData = {}
        }
        
        RemoteEventHandler:InvokeServer("BattleAction", actionData)
    end
    
    -- Reset battle state
    self:_resetBattleState()
end

function BattleController:SelectCard(cardUIData: CardUIData)
    if not self:_canPerformAction() then
        return
    end
    
    -- Clear previous selection
    if self._selectedCard then
        self:_updateCardSelection(self._selectedCard, false)
    end
    
    -- Select new card
    self._selectedCard = cardUIData
    self:_updateCardSelection(cardUIData, true)
    
    -- Update valid targets
    self:_updateValidTargets(cardUIData)
    
    self:_log("Selected card: " .. cardUIData.CardID)
end

function BattleController:GetBattleState(): BattleSession?
    return self._currentBattle
end

function BattleController:IsInBattle(): boolean
    return self._battleState == BATTLE_STATES.ACTIVE
end

-- Private Methods

function BattleController:_initializeBattleUI()
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    
    -- Create main battle UI
    local mainFrame = Instance.new("ScreenGui")
    mainFrame.Name = "BattleUI"
    mainFrame.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    mainFrame.ResetOnSpawn = false
    mainFrame.Enabled = false
    mainFrame.Parent = playerGui
    
    -- Create battlefield container
    local battleField = Instance.new("Frame")
    battleField.Name = "BattleField"
    battleField.Size = UDim2.new(1, 0, 1, 0)
    battleField.Position = UDim2.new(0, 0, 0, 0)
    battleField.BackgroundColor3 = Color3.new(0.1, 0.1, 0.15)
    battleField.BackgroundTransparency = 0
    battleField.ZIndex = 1
    battleField.Parent = mainFrame
    
    -- Create opponent area (top)
    local player2Area = Instance.new("Frame")
    player2Area.Name = "Player2Area"
    player2Area.Size = UDim2.new(1, -40, 0.4, -20)
    player2Area.Position = UDim2.new(0, 20, 0, 20)
    player2Area.BackgroundColor3 = Color3.new(0.8, 0.3, 0.3)
    player2Area.BackgroundTransparency = 0.8
    player2Area.ZIndex = 10
    player2Area.Parent = battleField
    
    -- Create player area (bottom)
    local player1Area = Instance.new("Frame")
    player1Area.Name = "Player1Area"
    player1Area.Size = UDim2.new(1, -40, 0.4, -20)
    player1Area.Position = UDim2.new(0, 20, 0.6, 0)
    player1Area.BackgroundColor3 = Color3.new(0.3, 0.3, 0.8)
    player1Area.BackgroundTransparency = 0.8
    player1Area.ZIndex = 10
    player1Area.Parent = battleField
    
    -- Create hand container
    local handContainer = Instance.new("Frame")
    handContainer.Name = "HandContainer"
    handContainer.Size = UDim2.new(1, -20, 0, 200)
    handContainer.Position = UDim2.new(0, 10, 1, -210)
    handContainer.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
    handContainer.BackgroundTransparency = 0.5
    handContainer.ZIndex = 20
    handContainer.Parent = mainFrame
    
    -- Create action buttons
    local actionButtons = Instance.new("Frame")
    actionButtons.Name = "ActionButtons"
    actionButtons.Size = UDim2.new(0, 200, 0, 60)
    actionButtons.Position = UDim2.new(1, -220, 1, -270)
    actionButtons.BackgroundTransparency = 1
    actionButtons.ZIndex = 30
    actionButtons.Parent = mainFrame
    
    -- End Turn button
    local endTurnButton = Instance.new("TextButton")
    endTurnButton.Name = "EndTurnButton"
    endTurnButton.Size = UDim2.new(1, 0, 0.5, -5)
    endTurnButton.Position = UDim2.new(0, 0, 0, 0)
    endTurnButton.BackgroundColor3 = Color3.new(0.3, 0.8, 0.3)
    endTurnButton.Text = "End Turn"
    endTurnButton.TextColor3 = Color3.new(1, 1, 1)
    endTurnButton.TextScaled = true
    endTurnButton.Font = Enum.Font.SourceSansBold
    endTurnButton.ZIndex = 31
    endTurnButton.Parent = actionButtons
    
    -- Leave Battle button
    local leaveBattleButton = Instance.new("TextButton")
    leaveBattleButton.Name = "LeaveBattleButton"
    leaveBattleButton.Size = UDim2.new(1, 0, 0.5, -5)
    leaveBattleButton.Position = UDim2.new(0, 0, 0.5, 5)
    leaveBattleButton.BackgroundColor3 = Color3.new(0.8, 0.3, 0.3)
    leaveBattleButton.Text = "Leave Battle"
    leaveBattleButton.TextColor3 = Color3.new(1, 1, 1)
    leaveBattleButton.TextScaled = true
    leaveBattleButton.Font = Enum.Font.SourceSansBold
    leaveBattleButton.ZIndex = 31
    leaveBattleButton.Parent = actionButtons
    
    -- Create status display
    local statusDisplay = Instance.new("Frame")
    statusDisplay.Name = "StatusDisplay"
    statusDisplay.Size = UDim2.new(0, 300, 0, 100)
    statusDisplay.Position = UDim2.new(0, 20, 0, 20)
    statusDisplay.BackgroundColor3 = Color3.new(0, 0, 0)
    statusDisplay.BackgroundTransparency = 0.3
    statusDisplay.ZIndex = 40
    statusDisplay.Parent = mainFrame
    
    -- Create timer display
    local timerDisplay = Instance.new("Frame")
    timerDisplay.Name = "TimerDisplay"
    timerDisplay.Size = UI_CONFIG.TurnTimerSize
    timerDisplay.Position = UDim2.new(0.5, -100, 0, 20)
    timerDisplay.BackgroundColor3 = Color3.new(0.2, 0.2, 0.2)
    timerDisplay.BackgroundTransparency = 0.2
    timerDisplay.ZIndex = 50
    timerDisplay.Parent = mainFrame
    
    -- Timer text
    local timerText = Instance.new("TextLabel")
    timerText.Name = "TimerText"
    timerText.Size = UDim2.new(1, 0, 1, 0)
    timerText.Position = UDim2.new(0, 0, 0, 0)
    timerText.BackgroundTransparency = 1
    timerText.Text = "30"
    timerText.TextColor3 = Color3.new(1, 1, 1)
    timerText.TextScaled = true
    timerText.Font = Enum.Font.SourceSansBold
    timerText.ZIndex = 51
    timerText.Parent = timerDisplay
    
    -- Create effects layer
    local effectsLayer = Instance.new("Frame")
    effectsLayer.Name = "EffectsLayer"
    effectsLayer.Size = UDim2.new(1, 0, 1, 0)
    effectsLayer.Position = UDim2.new(0, 0, 0, 0)
    effectsLayer.BackgroundTransparency = 1
    effectsLayer.ZIndex = 100
    effectsLayer.Parent = mainFrame
    
    -- Store UI elements
    self._uiElements = {
        MainFrame = mainFrame,
        BattleField = battleField,
        Player1Area = player1Area,
        Player2Area = player2Area,
        HandContainer = handContainer,
        ActionButtons = actionButtons,
        StatusDisplay = statusDisplay,
        TimerDisplay = timerDisplay,
        EffectsLayer = effectsLayer
    }
    
    self:_log("Battle UI initialized")
end

function BattleController:_setupInputHandlers()
    -- End Turn button
    self._inputConnections.EndTurnButton = self._uiElements.ActionButtons.EndTurnButton.MouseButton1Click:Connect(function()
        self:EndTurn()
    end)
    
    -- Leave Battle button
    self._inputConnections.LeaveBattleButton = self._uiElements.ActionButtons.LeaveBattleButton.MouseButton1Click:Connect(function()
        self:LeaveBattle()
    end)
    
    -- Keyboard shortcuts
    self._inputConnections.KeyboardInput = UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.KeyCode == Enum.KeyCode.Space then
            self:EndTurn()
        elseif input.KeyCode == Enum.KeyCode.Escape then
            self:LeaveBattle()
        end
    end)
end

function BattleController:_setupRemoteHandlers()
    RemoteEventHandler:ConnectRemoteEventClient("BattleUpdate", function(updateData)
        self:_handleBattleUpdate(updateData)
    end)
end

function BattleController:_renderBattleState(session: BattleTypes.BattleSession)
	if not self._uiElements then return end
	
	-- Player stats
	local player = session.Player1
	self._uiElements.PlayerHealth.Text = "❤️ " .. player.Health .. "/" .. player.MaxHealth
	self._uiElements.PlayerEnergy.Text = "⚡ " .. player.Energy .. "/" .. player.MaxEnergy
	self._uiElements.PlayerDeck.Text = "🃏 " .. #player.Deck
	
	-- Opponent stats
	local opponent = session.Player2
	self._uiElements.OpponentHealth.Text = "❤️ " .. opponent.Health .. "/" .. opponent.MaxHealth
	self._uiElements.OpponentEnergy.Text = "⚡ " .. opponent.Energy .. "/" .. opponent.MaxEnergy
	self._uiElements.OpponentDeck.Text = "🃏 " .. #opponent.Deck
	
	-- Render hand
	self:_renderHand(player.Hand)
end

function BattleController:_handleBattleUpdate(updateData: any)
    self:_log("Received battle update: " .. updateData.Type)
    if updateData.Type == "BattleStarted" then
        self:_onBattleStarted(updateData.BattleState)
    elseif updateData.Type == "ActionExecuted" then
        self:_onActionExecuted(updateData.Action, updateData.BattleState)
    elseif updateData.Type == "BattleEnded" then
        self:_onBattleEnded(updateData.Result, updateData.Reason)
    end
end

function BattleController:_onBattleStarted(battleState: BattleSession)
    self:_log("Battle started: " .. battleState.BattleID)
    
    self._currentBattle = battleState
    self._battleState = BATTLE_STATES.ACTIVE
    
    -- Update UI with battle data
    self:_updateBattleUI(battleState)
    
    -- Initialize cards
    self:_initializePlayerCards(battleState)
    
    -- Check if it's our turn
    local player = Players.LocalPlayer
    local isPlayer1 = battleState.Player1.UserID == player.UserId
    self._isMyTurn = (isPlayer1 and battleState.ActivePlayer == 1) or (not isPlayer1 and battleState.ActivePlayer == 2)
    self._canPerformActions = self._isMyTurn
    
    self:_updateActionButtons()
end

function BattleController:_onActionExecuted(action: BattleTypes.BattleAction, battleState: BattleSession)
    self._currentBattle = battleState
    
    -- Play action animation
    if action.ActionType == "PlayCard" then
        self:_handlePlayCardAction(action)
    elseif action.ActionType == "Attack" then
        self:_handleAttackAction(action)
    elseif action.ActionType == "EndTurn" then
        self:_handleEndTurnAction(action, battleState)
    end
    
    -- Update UI
    self:_updateBattleUI(battleState)
end

function BattleController:_onBattleEnded(result: BattleTypes.BattleResult, reason: string)
    self:_log("Battle ended: " .. reason)
    
    -- Show battle results
    self:_showBattleResults(result)
    
    -- Schedule cleanup
    spawn(function()
        wait(5) -- Show results for 5 seconds
        self:_resetBattleState()
    end)
end

function BattleController:_updateBattle(deltaTime: number)
    self._frameTime += deltaTime
    
    if self._battleState ~= BATTLE_STATES.ACTIVE then
        return
    end
    
    -- Update turn timer
    if self._isMyTurn then
        self._turnTimeRemaining -= deltaTime
        if self._turnTimeRemaining <= 0 then
            self._turnTimeRemaining = 0
            -- Auto end turn
            self:EndTurn()
        end
        
        -- Update timer display
        local timerText = self._uiElements.TimerDisplay:FindFirstChild("TimerText")
        if timerText then
            timerText.Text = tostring(math.ceil(self._turnTimeRemaining))
            
            -- Change color based on time remaining
            if self._turnTimeRemaining <= 5 then
                timerText.TextColor3 = Color3.new(1, 0.3, 0.3) -- Red
            elseif self._turnTimeRemaining <= 10 then
                timerText.TextColor3 = Color3.new(1, 1, 0.3) -- Yellow
            else
                timerText.TextColor3 = Color3.new(1, 1, 1) -- White
            end
        end
    end
    
    -- Update animations
    self:_updateActiveAnimations(deltaTime)
end

function BattleController:_updateBattleUI(battleState: BattleSession)
    if not self._uiElements then
        return
    end
    
    local player = Players.LocalPlayer
    local isPlayer1 = battleState.Player1.UserID == player.UserId
    local playerData = isPlayer1 and battleState.Player1 or battleState.Player2
    local opponentData = isPlayer1 and battleState.Player2 or battleState.Player1
    
    -- Update status display
    self:_updateStatusDisplay(playerData, opponentData)
    
    -- Update hand cards
    self:_updateHandCards(playerData.Hand)
    
    -- Update active cards
    self:_updateActiveCards(playerData, opponentData)
end

function BattleController:_updateStatusDisplay(playerData: BattleTypes.BattlePlayer, opponentData: BattleTypes.BattlePlayer)
    local statusDisplay = self._uiElements.StatusDisplay
    
    -- Clear existing elements
    for _, child in ipairs(statusDisplay:GetChildren()) do
        if child:IsA("GuiObject") then
            child:Destroy()
        end
    end
    
    -- Player health
    local playerHealthLabel = Instance.new("TextLabel")
    playerHealthLabel.Name = "PlayerHealth"
    playerHealthLabel.Size = UDim2.new(1, 0, 0.25, 0)
    playerHealthLabel.Position = UDim2.new(0, 0, 0, 0)
    playerHealthLabel.BackgroundTransparency = 1
    playerHealthLabel.Text = "Your Health: " .. playerData.Health .. "/" .. playerData.MaxHealth
    playerHealthLabel.TextColor3 = Color3.new(0.3, 1, 0.3)
    playerHealthLabel.TextScaled = true
    playerHealthLabel.Font = Enum.Font.SourceSansBold
    playerHealthLabel.Parent = statusDisplay
    
    -- Opponent health
    local opponentHealthLabel = Instance.new("TextLabel")
    opponentHealthLabel.Name = "OpponentHealth"
    opponentHealthLabel.Size = UDim2.new(1, 0, 0.25, 0)
    opponentHealthLabel.Position = UDim2.new(0, 0, 0.25, 0)
    opponentHealthLabel.BackgroundTransparency = 1
    opponentHealthLabel.Text = "Opponent Health: " .. opponentData.Health .. "/" .. opponentData.MaxHealth
    opponentHealthLabel.TextColor3 = Color3.new(1, 0.3, 0.3)
    opponentHealthLabel.TextScaled = true
    opponentHealthLabel.Font = Enum.Font.SourceSansBold
    opponentHealthLabel.Parent = statusDisplay
    
    -- Player energy
    local playerEnergyLabel = Instance.new("TextLabel")
    playerEnergyLabel.Name = "PlayerEnergy"
    playerEnergyLabel.Size = UDim2.new(1, 0, 0.25, 0)
    playerEnergyLabel.Position = UDim2.new(0, 0, 0.5, 0)
    playerEnergyLabel.BackgroundTransparency = 1
    playerEnergyLabel.Text = "Energy: " .. playerData.Energy .. "/" .. playerData.MaxEnergy
    playerEnergyLabel.TextColor3 = Color3.new(0.3, 0.3, 1)
    playerEnergyLabel.TextScaled = true
    playerEnergyLabel.Font = Enum.Font.SourceSansBold
    playerEnergyLabel.Parent = statusDisplay
    
    -- Turn indicator
    local turnLabel = Instance.new("TextLabel")
    turnLabel.Name = "TurnIndicator"
    turnLabel.Size = UDim2.new(1, 0, 0.25, 0)
    turnLabel.Position = UDim2.new(0, 0, 0.75, 0)
    turnLabel.BackgroundTransparency = 1
    turnLabel.Text = self._isMyTurn and "Your Turn" or "Opponent's Turn"
    turnLabel.TextColor3 = self._isMyTurn and Color3.new(1, 1, 0.3) or Color3.new(0.7, 0.7, 0.7)
    turnLabel.TextScaled = true
    turnLabel.Font = Enum.Font.SourceSansBold
    turnLabel.Parent = statusDisplay
end

function BattleController:_updateHandCards(handCards: {BattleTypes.BattleCard})
    -- Clear existing hand cards
    for _, cardUIData in ipairs(self._handCards) do
        cardUIData.Frame:Destroy()
    end
    self._handCards = {}
    
    -- Create new hand cards
    for i, battleCard in ipairs(handCards) do
        local cardUIData = self:_createCardUI(battleCard, i, "Hand")
        table.insert(self._handCards, cardUIData)
        self._cardUIElements[battleCard.InstanceID] = cardUIData
    end
end

function BattleController:_updateActiveCards(playerData: BattleTypes.BattlePlayer, opponentData: BattleTypes.BattlePlayer)
    -- Update player's active card
    if playerData.ActiveCard then
        local existingUI = self._cardUIElements[playerData.ActiveCard.InstanceID]
        if not existingUI then
            local cardUIData = self:_createCardUI(playerData.ActiveCard, 1, "PlayerActive")
            self._cardUIElements[playerData.ActiveCard.InstanceID] = cardUIData
        end
    end
    
    -- Update opponent's active card
    if opponentData.ActiveCard then
        local existingUI = self._cardUIElements[opponentData.ActiveCard.InstanceID]
        if not existingUI then
            local cardUIData = self:_createCardUI(opponentData.ActiveCard, 1, "OpponentActive")
            self._cardUIElements[opponentData.ActiveCard.InstanceID] = cardUIData
        end
    end
end

function BattleController:_createCardUI(battleCard: BattleTypes.BattleCard, index: number, position: string): CardUIData
    local cardFrame = Instance.new("Frame")
    cardFrame.Name = "Card_" .. battleCard.InstanceID
    cardFrame.Size = UI_CONFIG.CardSize
    cardFrame.BackgroundColor3 = Color3.new(0.1, 0.1, 0.1)
    cardFrame.BorderSizePixel = 2
    cardFrame.BorderColor3 = GameConstants.RarityColors[battleCard.CardData.Rarity] or Color3.new(0.7, 0.7, 0.7)
    cardFrame.ZIndex = 25
    
    -- Position based on location
    if position == "Hand" then
        local spacing = UI_CONFIG.HandSpacing
        local totalWidth = #self._handCards * (UI_CONFIG.CardSize.X.Offset + spacing) - spacing
        local startX = (self._uiElements.HandContainer.AbsoluteSize.X - totalWidth) / 2
        
        cardFrame.Position = UDim2.new(0, startX + (index - 1) * (UI_CONFIG.CardSize.X.Offset + spacing), 0, 10)
        cardFrame.Parent = self._uiElements.HandContainer
    elseif position == "PlayerActive" then
        cardFrame.Position = UDim2.new(0.5, -UI_CONFIG.CardSize.X.Offset / 2, 0.5, -UI_CONFIG.CardSize.Y.Offset / 2)
        cardFrame.Parent = self._uiElements.Player1Area
    elseif position == "OpponentActive" then
        cardFrame.Position = UDim2.new(0.5, -UI_CONFIG.CardSize.X.Offset / 2, 0.5, -UI_CONFIG.CardSize.Y.Offset / 2)
        cardFrame.Parent = self._uiElements.Player2Area
    end
    
    -- Card image
    local cardImage = Instance.new("ImageLabel")
    cardImage.Name = "CardImage"
    cardImage.Size = UDim2.new(1, -10, 0.6, -10)
    cardImage.Position = UDim2.new(0, 5, 0, 5)
    cardImage.BackgroundTransparency = 1
    cardImage.Image = battleCard.CardData.Image or ""
    cardImage.ZIndex = 26
    cardImage.Parent = cardFrame
    
    -- Card name
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, -10, 0.15, 0)
    nameLabel.Position = UDim2.new(0, 5, 0.6, 5)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = battleCard.CardData.Name
    nameLabel.TextColor3 = Color3.new(1, 1, 1)
    nameLabel.TextScaled = true
    nameLabel.Font = Enum.Font.SourceSansBold
    nameLabel.ZIndex = 27
    nameLabel.Parent = cardFrame
    
    -- Stats display
    local statsFrame = Instance.new("Frame")
    statsFrame.Name = "StatsFrame"
    statsFrame.Size = UDim2.new(1, -10, 0.25, -5)
    statsFrame.Position = UDim2.new(0, 5, 0.75, 0)
    statsFrame.BackgroundTransparency = 1
    statsFrame.ZIndex = 27
    statsFrame.Parent = cardFrame
    
    -- Attack stat
    local attackLabel = Instance.new("TextLabel")
    attackLabel.Name = "AttackLabel"
    attackLabel.Size = UDim2.new(0.33, 0, 1, 0)
    attackLabel.Position = UDim2.new(0, 0, 0, 0)
    attackLabel.BackgroundTransparency = 1
    attackLabel.Text = tostring(battleCard.Attack)
    attackLabel.TextColor3 = Color3.new(1, 0.6, 0.6)
    attackLabel.TextScaled = true
    attackLabel.Font = Enum.Font.SourceSans
    attackLabel.ZIndex = 28
    attackLabel.Parent = statsFrame
    
    -- Health stat
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(0.33, 0, 1, 0)
    healthLabel.Position = UDim2.new(0.33, 0, 0, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.Text = tostring(battleCard.CurrentHealth)
    healthLabel.TextColor3 = Color3.new(0.6, 1, 0.6)
    healthLabel.TextScaled = true
    healthLabel.Font = Enum.Font.SourceSans
    healthLabel.ZIndex = 28
    healthLabel.Parent = statsFrame
    
    -- Energy cost
    local energyLabel = Instance.new("TextLabel")
    energyLabel.Name = "EnergyLabel"
    energyLabel.Size = UDim2.new(0.33, 0, 1, 0)
    energyLabel.Position = UDim2.new(0.66, 0, 0, 0)
    energyLabel.BackgroundTransparency = 1
    energyLabel.Text = tostring(battleCard.Energy)
    energyLabel.TextColor3 = Color3.new(0.6, 0.6, 1)
    energyLabel.TextScaled = true
    energyLabel.Font = Enum.Font.SourceSans
    energyLabel.ZIndex = 28
    energyLabel.Parent = statsFrame
    
    -- Click handler for hand cards
    if position == "Hand" then
        local clickDetector = Instance.new("TextButton")
        clickDetector.Name = "ClickDetector"
        clickDetector.Size = UDim2.new(1, 0, 1, 0)
        clickDetector.Position = UDim2.new(0, 0, 0, 0)
        clickDetector.BackgroundTransparency = 1
        clickDetector.Text = ""
        clickDetector.ZIndex = 30
        clickDetector.Parent = cardFrame
        
        clickDetector.MouseButton1Click:Connect(function()
            self:SelectCard({
                Frame = cardFrame,
                CardID = battleCard.InstanceID,
                Position = Vector2.new(cardFrame.AbsolutePosition.X, cardFrame.AbsolutePosition.Y),
                IsAnimating = false,
                IsSelected = false,
                IsValidTarget = false,
                EffectContainer = cardFrame
            })
        end)
    end
    
    return {
        Frame = cardFrame,
        CardID = battleCard.InstanceID,
        Position = Vector2.new(cardFrame.AbsolutePosition.X, cardFrame.AbsolutePosition.Y),
        IsAnimating = false,
        IsSelected = false,
        IsValidTarget = false,
        EffectContainer = cardFrame
    }
end

function BattleController:_animateCardPlay(cardUIData: CardUIData, targetPosition: Vector2?)
    local effectsController = self.ServiceRegistry:GetService("EffectsController")
    
    -- Play card animation
    local playAnimation = TweenService:Create(cardUIData.Frame, TweenInfo.new(UI_CONFIG.AnimationDuration, Enum.EasingStyle.Quad), {
        Position = UDim2.new(0.5, -UI_CONFIG.CardSize.X.Offset / 2, 0.5, -UI_CONFIG.CardSize.Y.Offset / 2)
    })
    
    playAnimation:Play()
    
    -- Play effects
    if effectsController then
        effectsController:PlayCardRevealEffects({
            Card = { Name = "Card Play" },
            Rarity = "Common",
            EffectIntensity = 0.6,
            IsPityResult = false
        }, cardUIData.EffectContainer)
    end
    
    playAnimation.Completed:Connect(function()
        cardUIData.IsAnimating = false
    end)
    
    cardUIData.IsAnimating = true
end

function BattleController:_animateAttack(attackerCardUIData: CardUIData, targetCardUIData: CardUIData?)
    local effectsController = self.ServiceRegistry:GetService("EffectsController")
    
    -- Attack animation with impact frames
    local originalPosition = attackerCardUIData.Frame.Position
    local targetPosition = targetCardUIData and targetCardUIData.Frame.Position or UDim2.new(0.5, 0, 0.3, 0)
    
    -- Move toward target
    local attackMove = TweenService:Create(attackerCardUIData.Frame, TweenInfo.new(UI_CONFIG.ImpactFrameDelay, Enum.EasingStyle.Quad), {
        Position = UDim2.new(targetPosition.X.Scale * 0.8, targetPosition.X.Offset * 0.8, targetPosition.Y.Scale * 0.8, targetPosition.Y.Offset * 0.8)
    })
    
    attackMove:Play()
    
    attackMove.Completed:Connect(function()
        -- Impact frame pause
        wait(UI_CONFIG.ImpactFrameDelay / 3)
        
        -- Screen shake and effects
        if effectsController then
            effectsController:TriggerScreenShake(UI_CONFIG.ScreenShakeIntensity, 0.3)
            
            -- Play impact effects
            effectsController:PlayScreenFlash(Color3.new(1, 1, 0.8), 0.5, 0.2)
        end
        
        -- Return to original position
        local returnMove = TweenService:Create(attackerCardUIData.Frame, TweenInfo.new(UI_CONFIG.AnimationDuration / 2, Enum.EasingStyle.Quad), {
            Position = originalPosition
        })
        
        returnMove:Play()
        returnMove.Completed:Connect(function()
            attackerCardUIData.IsAnimating = false
        end)
    end)
    
    attackerCardUIData.IsAnimating = true
end

function BattleController:_handlePlayCardAction(action: BattleTypes.BattleAction)
    local cardID = action.ActionData.SourceCardID
    local cardUIData = self._cardUIElements[cardID]
    
    if cardUIData then
        self:_animateCardPlay(cardUIData)
    end
end

function BattleController:_handleAttackAction(action: BattleTypes.BattleAction)
    local attackerID = action.ActionData.SourceCardID
    local targetID = action.ActionData.TargetCardID
    
    local attackerUI = self._cardUIElements[attackerID]
    local targetUI = targetID and self._cardUIElements[targetID] or nil
    
    if attackerUI then
        self:_animateAttack(attackerUI, targetUI)
    end
end

function BattleController:_handleEndTurnAction(action: BattleTypes.BattleAction, battleState: BattleSession)
    local player = Players.LocalPlayer
    local isPlayer1 = battleState.Player1.UserID == player.UserId
    self._isMyTurn = (isPlayer1 and battleState.ActivePlayer == 1) or (not isPlayer1 and battleState.ActivePlayer == 2)
    self._canPerformActions = self._isMyTurn
    
    -- Reset turn timer
    self._turnTimeRemaining = 30
    
    self:_updateActionButtons()
end

function BattleController:_updateActionButtons()
    local endTurnButton = self._uiElements.ActionButtons.EndTurnButton
    endTurnButton.BackgroundTransparency = self._canPerformActions and 0 or 0.5
    endTurnButton.TextTransparency = self._canPerformActions and 0 or 0.5
end

function BattleController:_updateCardSelection(cardUIData: CardUIData, isSelected: boolean)
    cardUIData.IsSelected = isSelected
    
    local selectionFrame = cardUIData.Frame:FindFirstChild("Selection")
    if isSelected then
        if not selectionFrame then
            selectionFrame = Instance.new("Frame")
            selectionFrame.Name = "Selection"
            selectionFrame.Size = UDim2.new(1, 6, 1, 6)
            selectionFrame.Position = UDim2.new(0, -3, 0, -3)
            selectionFrame.BackgroundColor3 = Color3.new(1, 1, 0)
            selectionFrame.BackgroundTransparency = 0.5
            selectionFrame.ZIndex = cardUIData.Frame.ZIndex - 1
            selectionFrame.Parent = cardUIData.Frame
        end
    else
        if selectionFrame then
            selectionFrame:Destroy()
        end
    end
end

function BattleController:_updateValidTargets(selectedCard: CardUIData)
    -- Clear previous valid targets
    for _, cardUIData in pairs(self._cardUIElements) do
        cardUIData.IsValidTarget = false
        local targetFrame = cardUIData.Frame:FindFirstChild("ValidTarget")
        if targetFrame then
            targetFrame:Destroy()
        end
    end
    
    -- Set new valid targets (simplified logic)
    self._validTargets = {}
    
    -- For now, all opponent cards are valid targets
    for _, cardUIData in pairs(self._cardUIElements) do
        if cardUIData.Frame.Parent == self._uiElements.Player2Area then
            cardUIData.IsValidTarget = true
            table.insert(self._validTargets, cardUIData)
            
            -- Add visual indicator
            local targetFrame = Instance.new("Frame")
            targetFrame.Name = "ValidTarget"
            targetFrame.Size = UDim2.new(1, 4, 1, 4)
            targetFrame.Position = UDim2.new(0, -2, 0, -2)
            targetFrame.BackgroundColor3 = Color3.new(0, 1, 0)
            targetFrame.BackgroundTransparency = 0.7
            targetFrame.ZIndex = cardUIData.Frame.ZIndex - 1
            targetFrame.Parent = cardUIData.Frame
        end
    end
end

function BattleController:_updateActiveAnimations(deltaTime: number)
    self._animationCount = 0
    
    for animationID, animation in pairs(self._activeAnimations) do
        animation.Duration -= deltaTime
        
        if animation.Duration <= 0 then
            -- Animation finished
            if animation.OnComplete then
                animation.OnComplete()
            end
            self._activeAnimations[animationID] = nil
        else
            self._animationCount += 1
        end
    end
end

function BattleController:_showBattleResults(result: BattleTypes.BattleResult)
    local player = Players.LocalPlayer
    local isWinner = (result.Winner == 1 and result.Player1Stats) or (result.Winner == 2 and result.Player2Stats)
    
    -- Create results UI
    local resultsFrame = Instance.new("Frame")
    resultsFrame.Name = "BattleResults"
    resultsFrame.Size = UDim2.new(0.5, 0, 0.6, 0)
    resultsFrame.Position = UDim2.new(0.25, 0, 0.2, 0)
    resultsFrame.BackgroundColor3 = Color3.new(0, 0, 0)
    resultsFrame.BackgroundTransparency = 0.2
    resultsFrame.ZIndex = 200
    resultsFrame.Parent = self._uiElements.MainFrame
    
    -- Results text
    local resultsText = Instance.new("TextLabel")
    resultsText.Name = "ResultsText"
    resultsText.Size = UDim2.new(1, 0, 0.5, 0)
    resultsText.Position = UDim2.new(0, 0, 0, 0)
    resultsText.BackgroundTransparency = 1
    resultsText.Text = result.Winner and (isWinner and "Victory!" or "Defeat!") or "Draw!"
    resultsText.TextColor3 = result.Winner and (isWinner and Color3.new(0, 1, 0) or Color3.new(1, 0, 0)) or Color3.new(1, 1, 0)
    resultsText.TextScaled = true
    resultsText.Font = Enum.Font.SourceSansBold
    resultsText.ZIndex = 201
    resultsText.Parent = resultsFrame
    
    self._uiState.ShowingResults = true
end

function BattleController:_resetBattleState()
    self._battleState = BATTLE_STATES.INACTIVE
    self._currentBattle = nil
    self._uiState = nil
    
    -- Clear card UI
    for _, cardUIData in pairs(self._cardUIElements) do
        cardUIData.Frame:Destroy()
    end
    self._cardUIElements = {}
    self._handCards = {}
    
    -- Hide UI
    if self._uiElements then
        self._uiElements.MainFrame.Enabled = false
    end
    
    self:_log("Battle state reset")
end

function BattleController:_canPerformAction(): boolean
    return self._battleState == BATTLE_STATES.ACTIVE and 
           self._canPerformActions and 
           not self._uiState.UILocked and 
           self._uiState.AnimationsPlaying == 0
end

function BattleController:_cleanupInputHandlers()
    for _, connection in pairs(self._inputConnections) do
        connection:Disconnect()
    end
    self._inputConnections = {}
end

return BattleController.new() 
--- FILE: ./src/client/Controllers/PolishEffectsController.luau ---
--!strict
-- PolishEffectsController.luau
-- Client-side visual effects controller for premium polish
-- Handles screen effects, particles, impact frames, and visual juice locally

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local StarterGui = game:GetService("StarterGui")
local Lighting = game:GetService("Lighting")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local EffectsTypes = require(ReplicatedStorage.Shared.Types.EffectsTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type ScreenEffect = EffectsTypes.ScreenEffect
type ParticleSystem = EffectsTypes.ParticleSystem
type ImpactFrame = EffectsTypes.ImpactFrame
type JuiceSequence = EffectsTypes.JuiceSequence
type ChromaticAberrationEffect = EffectsTypes.ChromaticAberrationEffect
type BloomEffect = EffectsTypes.BloomEffect

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local PolishEffectsController = {}
PolishEffectsController.__index = PolishEffectsController
setmetatable(PolishEffectsController, {__index = BaseController})

function PolishEffectsController.new()
	local self = BaseController.new("PolishEffectsController", {"AudioController"})
	setmetatable(self, PolishEffectsController)
	
	-- Visual Effects State
	self._isEnabled = true
	self._qualityLevel = 2
	self._frameRate = 60
	
	-- Active Effects
	self._activeScreenEffects = {} :: {[string]: any}
	self._activeParticleEmitters = {} :: {[string]: ParticleEmitter}
	self._activeJuiceAnimations = {} :: {[string]: Tween}
	self._impactFrameData = {} :: {[string]: any}
	
	-- Performance Management
	self._particlePool = {} :: {[string]: {ParticleEmitter}}
	self._effectCount = 0
	self._particleCount = 0
	self._lastOptimization = 0
	
	-- Screen Effect Elements
	self._screenEffectGui = nil :: ScreenGui?
	self._chromaticFrame = nil :: Frame?
	self._bloomFrame = nil :: Frame?
	self._vignetteFrame = nil :: Frame?
	self._distortionFrame = nil :: Frame?
	
	-- Impact Frame State
	self._originalTimeScale = 1.0
	self._impactFrameActive = false
	
	-- Research-Based Configurations
	self._researchConfig = {
		ImpactDurations = {
			Light = 0.05, -- 3 frames at 60fps
			Medium = 0.1, -- 6 frames at 60fps
			Heavy = 0.167, -- 10 frames at 60fps
			Ultimate = 0.2 -- 12 frames at 60fps
		},
		SatisfactionCurves = {
			ButtonPress = Enum.EasingStyle.Back,
			CardReveal = Enum.EasingStyle.Elastic,
			Victory = Enum.EasingStyle.Bounce
		},
		OptimalIntensities = {
			Hover = 0.1,
			Press = 0.3,
			Success = 0.7,
			Epic = 0.9
		}
	}
	
	-- Events from server (using individual GetRemoteEvent calls)
	self._events = {
		ScreenEffectRequested = RemoteEventHandler:GetRemoteEvent("ScreenEffectRequested"),
		ParticleSystemRequested = RemoteEventHandler:GetRemoteEvent("ParticleSystemRequested"),
		ImpactFrameRequested = RemoteEventHandler:GetRemoteEvent("ImpactFrameRequested"),
		VisualJuiceRequested = RemoteEventHandler:GetRemoteEvent("VisualJuiceRequested"),
		QualityLevelChanged = RemoteEventHandler:GetRemoteEvent("QualityLevelChanged"),
		PerformanceMetricsUpdate = RemoteEventHandler:GetRemoteEvent("PerformanceMetricsUpdate")
	}
	
	return self
end

function PolishEffectsController:Initialize()
	self:_log("PolishEffectsController initializing...")
	
	-- Initialize screen effects GUI
	self:_initializeScreenEffectsGUI()
	
	-- Initialize particle pools
	self:_initializeParticlePools()
	
	-- Setup remote event handlers
	self:_setupRemoteEventHandlers()
	
	-- Initialize performance monitoring
	self:_initializePerformanceMonitoring()
	
	self:_log("PolishEffectsController initialized successfully")
end

function PolishEffectsController:Start()
	self:_log("PolishEffectsController starting...")
	
	-- Start effects update loop
	self:_startEffectsUpdateLoop()
	
	-- Start performance monitoring
	self:_startPerformanceMonitoring()
	
	self:_log("PolishEffectsController started successfully")
end

function PolishEffectsController:Stop()
	self:_log("PolishEffectsController stopping...")
	
	-- Stop all effects
	self:StopAllEffects()
	
	-- Cleanup connections
	if self._effectsUpdateConnection then
		self._effectsUpdateConnection:Disconnect()
		self._effectsUpdateConnection = nil
	end
	
	if self._performanceConnection then
		self._performanceConnection:Disconnect()
		self._performanceConnection = nil
	end
	
	BaseController.Stop(self)
	self:_log("PolishEffectsController stopped")
end

-- Public API

-- Screen Effects
function PolishEffectsController:PlayScreenEffect(effectName: string, intensity: number?, duration: number?): string
	if not self._isEnabled then
		return ""
	end
	
	local effectID = self:_generateEffectID(effectName)
	
	-- Create screen effect based on type
	local success = false
	
	if effectName == "ChromaticAberration" then
		success = self:_playChromaticAberration(effectID, intensity or 0.7, duration or 1.0)
	elseif effectName == "Bloom" then
		success = self:_playBloom(effectID, intensity or 0.7, duration or 1.0)
	elseif effectName == "Vignette" then
		success = self:_playVignette(effectID, intensity or 0.7, duration or 1.0)
	elseif effectName == "Distortion" then
		success = self:_playDistortion(effectID, intensity or 0.7, duration or 1.0)
	else
		self:_logError("Unknown screen effect: " .. effectName)
		return ""
	end
	
	if success then
		self._effectCount = self._effectCount + 1
		self:_log("Screen effect started: " .. effectName .. " (ID: " .. effectID .. ")")
		return effectID
	else
		return ""
	end
end

-- Particle Systems
function PolishEffectsController:SpawnParticleEffect(effectType: string, position: Vector3, guiObject: GuiObject?): string
	local effectID = self:_generateEffectID(effectType)
	
	-- Get particle emitter from pool
	local emitter = self:_getParticleFromPool(effectType)
	if not emitter then
		self:_logError("Failed to create particle emitter for: " .. effectType)
		return ""
	end
	
	-- Configure the emitter
	self:_configureParticleEmitter(emitter, effectType, position)
	
	-- Enable the emitter
	emitter.Enabled = true
	
	-- Auto-disable after duration
	spawn(function()
		wait(self:_getParticleEffectDuration(effectType))
		emitter.Enabled = false
		
		-- Return to pool after cleanup
		spawn(function()
			wait(2.0) -- Allow existing particles to finish
			self:_returnParticleToPool(emitter)
		end)
	end)
	
	-- Track active emitter
	self._activeParticleEmitters[effectID] = emitter
	self._particleCount = self._particleCount + 1
	
	self:_log("Particle effect spawned: " .. effectType .. " (ID: " .. effectID .. ")")
	return effectID
end

-- Impact Frames with research-based timing
function PolishEffectsController:TriggerImpactFrame(impactType: string, intensity: number?, targetPosition: Vector3?): string
	if not self._isEnabled or self._impactFrameActive then
		return ""
	end
	
	local frameID = self:_generateEffectID(impactType .. "_impact")
	
	-- Get research-based timing
	local duration = self._researchConfig.ImpactDurations[impactType] or 0.1
	intensity = intensity or 0.7
	
	-- Store original game speed
	self._originalTimeScale = workspace.CurrentCamera.FieldOfView
	self._impactFrameActive = true
	
	-- Execute impact frame sequence
	self:_executeImpactFrameSequence(impactType, intensity, duration, frameID, targetPosition)
	
	-- Track impact frame
	self._impactFrameData[frameID] = {
		Type = impactType,
		Intensity = intensity,
		Duration = duration,
		StartTime = tick()
	}
	
	self:_log("Impact frame triggered: " .. impactType .. " (ID: " .. frameID .. ")")
	return frameID
end

-- Visual Juice Effects
function PolishEffectsController:PlayVisualJuice(sequenceName: string, targetObject: Instance, config: any?): string
	if not self._isEnabled or not targetObject then
		return ""
	end
	
	local juiceID = self:_generateEffectID(sequenceName .. "_juice")
	
	-- Get juice sequence configuration
	local sequence = self:_getJuiceSequenceConfig(sequenceName, config)
	if not sequence then
		self:_logError("Unknown visual juice sequence: " .. sequenceName)
		return ""
	end
	
	-- Execute juice sequence
	local tween = self:_createJuiceTween(targetObject, sequence)
	if tween then
		-- Track animation
		self._activeJuiceAnimations[juiceID] = tween
		
		-- Start animation
		tween:Play()
		
		-- Auto-cleanup when finished
		tween.Completed:Connect(function()
			self._activeJuiceAnimations[juiceID] = nil
		end)
		
		self:_log("Visual juice started: " .. sequenceName .. " (ID: " .. juiceID .. ")")
		return juiceID
	else
		self:_logError("Failed to create visual juice: " .. sequenceName)
		return ""
	end
end

-- Enhanced Button Interactions
function PolishEffectsController:EnhanceButton(button: GuiButton, config: EffectsTypes.ButtonEnhancementConfig?)
	-- Default configuration
	local buttonConfig = config or {
		HoverScale = 1.05, -- This will now be treated as a pixel offset
		PressScale = 0.95, -- This will now be treated as a pixel offset
		HoverDuration = 0.1,
		PressDuration = 0.05,
		EasingStyle = Enum.EasingStyle.Quad
	}
	
	-- Store original properties
	local originalSize = button.AbsoluteSize
	button.AnchorPoint = Vector2.new(0.5, 0.5) -- Ensure scaling is from the center
	
	-- Hover effects
	button.MouseEnter:Connect(function()
		local hoverSize = UDim2.fromOffset(originalSize.X + 10, originalSize.Y + 10) -- Add 10px on hover
		TweenService:Create(button, TweenInfo.new(buttonConfig.HoverDuration), {Size = hoverSize}):Play()
	end)
	
	button.MouseLeave:Connect(function()
		local normalSize = UDim2.fromOffset(originalSize.X, originalSize.Y)
		TweenService:Create(button, TweenInfo.new(buttonConfig.HoverDuration), {Size = normalSize}):Play()
	end)
	
	-- Press effects
	button.MouseButton1Down:Connect(function()
		local pressSize = UDim2.fromOffset(originalSize.X - 5, originalSize.Y - 5) -- Subtract 5px on press
		TweenService:Create(button, TweenInfo.new(buttonConfig.PressDuration), {Size = pressSize}):Play()
		self:TriggerImpactFrame("Light", 0.3)
	end)
	
	button.MouseButton1Up:Connect(function()
		local hoverSize = UDim2.fromOffset(originalSize.X + 10, originalSize.Y + 10) -- Return to hover size
		TweenService:Create(button, TweenInfo.new(buttonConfig.PressDuration * 2), {Size = hoverSize}):Play()
	end)
	
	self:_log("Button enhanced: " .. button.Name)
end

-- Card-Specific Effects
function PolishEffectsController:PlayCardRevealEffect(cardFrame: Frame, rarity: string): string
	if not cardFrame then return "" end
	
	local effectID = self:_generateEffectID("card_reveal")
	
	-- Rarity-based effects
	local intensity = self:_getRarityIntensity(rarity)
	local duration = self:_getRarityDuration(rarity)
	
	-- Play multiple synchronized effects
	spawn(function()
		-- Visual juice sequence
		self:PlayVisualJuice("CardReveal", cardFrame, {
			Intensity = intensity,
			Duration = duration
		})
		
		-- Screen effect for higher rarities
		if intensity > 0.6 then
			self:PlayScreenEffect("Bloom", intensity * 0.8, duration * 0.5)
		end
		
		if intensity > 0.8 then
			self:PlayScreenEffect("ChromaticAberration", intensity * 0.6, duration * 0.3)
		end
		
		-- Particle effects
		if intensity > 0.5 then
			local cardPosition = self:_getWorldPositionFromGui(cardFrame)
			self:SpawnParticleEffect("CardSparkle", cardPosition, cardFrame)
		end
		
		-- Impact frame for legendary+ cards
		if intensity > 0.7 then
			wait(duration * 0.3) -- Timing for maximum impact
			self:TriggerImpactFrame(intensity > 0.9 and "Ultimate" or "Heavy", intensity)
		end
	end)
	
	self:_log("Card reveal effect started: " .. rarity .. " (ID: " .. effectID .. ")")
	return effectID
end

-- Stop Effects
function PolishEffectsController:StopScreenEffect(effectID: string)
	if self._activeScreenEffects[effectID] then
		local effect = self._activeScreenEffects[effectID]
		if effect.Tween then
			effect.Tween:Cancel()
		end
		self._activeScreenEffects[effectID] = nil
		self._effectCount = math.max(0, self._effectCount - 1)
	end
end

function PolishEffectsController:StopParticleEffect(effectID: string)
	if self._activeParticleEmitters[effectID] then
		local emitter = self._activeParticleEmitters[effectID]
		emitter.Enabled = false
		
		-- Return to pool after cleanup delay
		spawn(function()
			wait(2.0) -- Allow existing particles to finish
			self:_returnParticleToPool(emitter)
		end)
		
		self._activeParticleEmitters[effectID] = nil
		self._particleCount = math.max(0, self._particleCount - 1)
	end
end

function PolishEffectsController:StopAllEffects()
	-- Stop screen effects
	for effectID, _ in pairs(self._activeScreenEffects) do
		self:StopScreenEffect(effectID)
	end
	
	-- Stop particle effects
	for effectID, _ in pairs(self._activeParticleEmitters) do
		self:StopParticleEffect(effectID)
	end
	
	-- Stop juice animations
	for juiceID, tween in pairs(self._activeJuiceAnimations) do
		tween:Cancel()
	end
	self._activeJuiceAnimations = {}
	
	-- Reset counters
	self._effectCount = 0
	self._particleCount = 0
	
	self:_log("All effects stopped")
end

-- Performance and Quality
function PolishEffectsController:SetQualityLevel(level: number)
	level = math.clamp(level, 0, 3)
	self._qualityLevel = level
	
	-- Adjust performance settings based on quality
	self:_adjustPerformanceForQuality(level)
	
	self:_log("Quality level set to: " .. level)
end

function PolishEffectsController:GetPerformanceMetrics()
	return {
		EffectCount = self._effectCount,
		ParticleCount = self._particleCount,
		QualityLevel = self._qualityLevel,
		FrameRate = self._frameRate,
		ActiveScreenEffects = table.getn(self._activeScreenEffects),
		ActiveParticleEffects = table.getn(self._activeParticleEmitters),
		ActiveJuiceAnimations = table.getn(self._activeJuiceAnimations)
	}
end

-- Private Methods

function PolishEffectsController:_initializeScreenEffectsGUI()
	-- Create screen effects GUI container
	self._screenEffectGui = Instance.new("ScreenGui")
	self._screenEffectGui.Name = "PolishEffectsGUI"
	self._screenEffectGui.Parent = PlayerGui
	self._screenEffectGui.ResetOnSpawn = false
	self._screenEffectGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	
	-- Create effect frames
	self._chromaticFrame = self:_createEffectFrame("ChromaticAberration")
	self._bloomFrame = self:_createEffectFrame("Bloom")
	self._vignetteFrame = self:_createEffectFrame("Vignette")
	self._distortionFrame = self:_createEffectFrame("Distortion")
end

function PolishEffectsController:_createEffectFrame(effectType: string): Frame
	local frame = Instance.new("Frame")
	frame.Name = effectType .. "Frame"
	frame.Size = UDim2.new(1, 0, 1, 0)
	frame.Position = UDim2.new(0, 0, 0, 0)
	frame.BackgroundTransparency = 1
	frame.BorderSizePixel = 0
	frame.Parent = self._screenEffectGui
	frame.ZIndex = 1000
	
	-- Add effect-specific visual elements
	if effectType == "Vignette" then
		frame.BackgroundColor3 = Color3.new(0, 0, 0)
		
		-- Create gradient for vignette effect
		local gradient = Instance.new("UIGradient")
		gradient.Color = ColorSequence.new(Color3.new(1, 1, 1), Color3.new(0, 0, 0))
		gradient.Rotation = 0
		gradient.Parent = frame
		
		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0.5, 0)
		corner.Parent = frame
	end
	
	return frame
end

function PolishEffectsController:_initializeParticlePools()
	-- Initialize particle pools for different effect types
	local particleTypes = {"Spark", "Glow", "Magic", "Energy", "Explosion", "CardSparkle"}
	
	for _, particleType in ipairs(particleTypes) do
		self._particlePool[particleType] = {}
		
		-- Pre-create pool of particles
		for i = 1, 10 do
			local emitter = self:_createParticleEmitter(particleType)
			if emitter then
				table.insert(self._particlePool[particleType], emitter)
			end
		end
	end
end

function PolishEffectsController:_getParticleFromPool(effectType: string): ParticleEmitter?
	if not self._particlePool[effectType] then
		self._particlePool[effectType] = {}
	end
	
	local pool = self._particlePool[effectType]
	if #pool > 0 then
		return table.remove(pool, 1)
	end
	
	-- Create new emitter if pool is empty
	return self:_createParticleEmitter(effectType)
end

function PolishEffectsController:_returnParticleToPool(emitter: ParticleEmitter)
	if not emitter then return end
	
	emitter.Enabled = false
	emitter.Parent = nil
	
	-- Find the effect type
	local effectType = emitter.Name:match("(.+)Emitter") or "Default"
	
	if not self._particlePool[effectType] then
		self._particlePool[effectType] = {}
	end
	
	-- Return to pool if not full
	if #self._particlePool[effectType] < 10 then
		table.insert(self._particlePool[effectType], emitter)
	else
		emitter:Destroy()
	end
end

function PolishEffectsController:_createParticleEmitter(effectType: string): ParticleEmitter
	local emitter = Instance.new("ParticleEmitter")
	emitter.Name = effectType .. "Emitter"
	
	-- Configure based on effect type
	if effectType == "GoldenNova" then
		-- Legendary card effect - golden explosion
		emitter.Rate = 200
		emitter.Lifetime = NumberRange.new(1.5, 3.0)
		emitter.Speed = NumberRange.new(5, 15)
		emitter.SpreadAngle = Vector2.new(180, 180)
		emitter.Drag = 5
		emitter.VelocityInheritance = 0.5
		
		-- Golden colors
		emitter.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 215, 0)),   -- Gold
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(255, 255, 0)), -- Yellow
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 140, 0))    -- Orange
		})
		
		-- Size animation - starts small, grows, then shrinks
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0),
			NumberSequenceKeypoint.new(0.3, 2),
			NumberSequenceKeypoint.new(0.7, 1.5),
			NumberSequenceKeypoint.new(1, 0)
		})
		
		-- Transparency animation
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.9),
			NumberSequenceKeypoint.new(0.2, 0.1),
			NumberSequenceKeypoint.new(0.8, 0.3),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 0.9
		emitter.LightInfluence = 0.1
		
	elseif effectType == "RainbowCosmos" then
		-- Ultimate card effect - cosmic rainbow
		emitter.Rate = 150
		emitter.Lifetime = NumberRange.new(2.0, 4.0)
		emitter.Speed = NumberRange.new(3, 12)
		emitter.SpreadAngle = Vector2.new(360, 360)
		emitter.Drag = 3
		emitter.VelocityInheritance = 0.3
		
		-- Rainbow colors
		emitter.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 0, 0)),     -- Red
			ColorSequenceKeypoint.new(0.17, Color3.fromRGB(255, 165, 0)), -- Orange
			ColorSequenceKeypoint.new(0.33, Color3.fromRGB(255, 255, 0)), -- Yellow
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(0, 255, 0)),    -- Green
			ColorSequenceKeypoint.new(0.67, Color3.fromRGB(0, 0, 255)),   -- Blue
			ColorSequenceKeypoint.new(0.83, Color3.fromRGB(75, 0, 130)),  -- Indigo
			ColorSequenceKeypoint.new(1, Color3.fromRGB(148, 0, 211))     -- Violet
		})
		
		-- Cosmic size animation
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.5),
			NumberSequenceKeypoint.new(0.4, 3),
			NumberSequenceKeypoint.new(0.8, 2),
			NumberSequenceKeypoint.new(1, 0.2)
		})
		
		-- Mystical transparency
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.8),
			NumberSequenceKeypoint.new(0.3, 0.2),
			NumberSequenceKeypoint.new(0.7, 0.4),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 1.0
		emitter.LightInfluence = 0
		
	elseif effectType == "EpicSpark" then
		-- Epic card effect - purple sparks
		emitter.Rate = 100
		emitter.Lifetime = NumberRange.new(1.0, 2.5)
		emitter.Speed = NumberRange.new(4, 10)
		emitter.SpreadAngle = Vector2.new(90, 90)
		emitter.Drag = 4
		
		-- Purple spark colors
		emitter.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(148, 0, 211)),   -- Violet
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(138, 43, 226)), -- Blue Violet
			ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))     -- Indigo
		})
		
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.2),
			NumberSequenceKeypoint.new(0.5, 1.2),
			NumberSequenceKeypoint.new(1, 0.1)
		})
		
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.7),
			NumberSequenceKeypoint.new(0.3, 0.2),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 0.7
		
	elseif effectType == "RareGlow" then
		-- Rare card effect - blue glow
		emitter.Rate = 60
		emitter.Lifetime = NumberRange.new(0.8, 2.0)
		emitter.Speed = NumberRange.new(2, 6)
		emitter.SpreadAngle = Vector2.new(60, 60)
		emitter.Drag = 6
		
		-- Blue glow colors
		emitter.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 191, 255)),   -- Deep Sky Blue
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(30, 144, 255)), -- Dodger Blue
			ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 0, 255))      -- Blue
		})
		
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.1),
			NumberSequenceKeypoint.new(0.4, 0.8),
			NumberSequenceKeypoint.new(1, 0.2)
		})
		
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.8),
			NumberSequenceKeypoint.new(0.4, 0.3),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 0.5
		
	elseif effectType == "UncommonShimmer" then
		-- Uncommon card effect - green shimmer
		emitter.Rate = 40
		emitter.Lifetime = NumberRange.new(0.5, 1.5)
		emitter.Speed = NumberRange.new(1, 4)
		emitter.SpreadAngle = Vector2.new(45, 45)
		emitter.Drag = 8
		
		-- Green shimmer colors
		emitter.Color = ColorSequence.new({
			ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 0)),     -- Lime
			ColorSequenceKeypoint.new(0.5, Color3.fromRGB(50, 205, 50)), -- Lime Green
			ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 128, 0))      -- Green
		})
		
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.1),
			NumberSequenceKeypoint.new(0.3, 0.5),
			NumberSequenceKeypoint.new(1, 0.1)
		})
		
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.6),
			NumberSequenceKeypoint.new(0.5, 0.4),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 0.3
		
	elseif effectType == "CardSparkle" then
		-- Generic card sparkle effect
		emitter.Rate = 30
		emitter.Lifetime = NumberRange.new(0.5, 1.2)
		emitter.Speed = NumberRange.new(1, 3)
		emitter.SpreadAngle = Vector2.new(30, 30)
		emitter.Drag = 5
		
		-- White sparkle
		emitter.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
		
		emitter.Size = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.1),
			NumberSequenceKeypoint.new(0.5, 0.4),
			NumberSequenceKeypoint.new(1, 0.05)
		})
		
		emitter.Transparency = NumberSequence.new({
			NumberSequenceKeypoint.new(0, 0.5),
			NumberSequenceKeypoint.new(0.7, 0.8),
			NumberSequenceKeypoint.new(1, 1)
		})
		
		emitter.LightEmission = 0.2
		
	else
		-- Default particle effect
		emitter.Rate = 20
		emitter.Lifetime = NumberRange.new(0.5, 1.0)
		emitter.Speed = NumberRange.new(1, 3)
		emitter.SpreadAngle = Vector2.new(45, 45)
		emitter.Color = ColorSequence.new(Color3.fromRGB(255, 255, 255))
		emitter.LightEmission = 0.1
	end
	
	-- Add mobile optimization
	if game:GetService("UserInputService").TouchEnabled then
		emitter.Rate = emitter.Rate * 0.7 -- Reduce particles on mobile
	end
	
	return emitter
end

function PolishEffectsController:_configureParticleEmitter(emitter: ParticleEmitter, effectType: string, position: Vector3)
	-- Apply position-based modifications
	if effectType == "GoldenNova" then
		-- Add slight upward velocity for nova effect
		emitter.Acceleration = Vector3.new(0, -2, 0)
		emitter.EmissionDirection = Enum.NormalId.Top
		
	elseif effectType == "RainbowCosmos" then
		-- Cosmic swirl effect
		emitter.Acceleration = Vector3.new(0, -1, 0)
		emitter.EmissionDirection = Enum.NormalId.Front
		
	elseif effectType == "EpicSpark" then
		-- Sparks fly outward
		emitter.Acceleration = Vector3.new(0, -5, 0)
		emitter.EmissionDirection = Enum.NormalId.Front
		
	elseif effectType == "RareGlow" then
		-- Gentle float upward
		emitter.Acceleration = Vector3.new(0, 2, 0)
		emitter.EmissionDirection = Enum.NormalId.Top
		
	elseif effectType == "UncommonShimmer" then
		-- Subtle shimmer
		emitter.Acceleration = Vector3.new(0, 1, 0)
		emitter.EmissionDirection = Enum.NormalId.Front
	end
	
	-- Create attachment point for world position
	local attachment = Instance.new("Attachment")
	attachment.WorldPosition = position
	attachment.Parent = workspace
	emitter.Parent = attachment
	
	-- Auto-cleanup attachment after effect
	spawn(function()
		wait(self:_getParticleEffectDuration(effectType))
		if attachment then
			attachment:Destroy()
		end
	end)
end

function PolishEffectsController:_getParticleEffectDuration(effectType: string): number
	local durations = {
		GoldenNova = 4.0,      -- Legendary needs long duration
		RainbowCosmos = 5.0,   -- Ultimate gets longest
		EpicSpark = 3.0,       -- Epic medium duration
		RareGlow = 2.5,        -- Rare shorter
		UncommonShimmer = 2.0, -- Uncommon brief
		CardSparkle = 1.5,     -- Generic short
		Default = 2.0
	}
	
	return durations[effectType] or durations.Default
end

function PolishEffectsController:_generateEffectID(baseName: string): string
	return "client_" .. baseName .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
end

function PolishEffectsController:_setupRemoteEventHandlers()
	-- Handle server effect requests
	if self._events.ScreenEffectRequested then
		self._events.ScreenEffectRequested.OnClientEvent:Connect(function(effectName: string, effectID: string, effect: any)
			self:PlayScreenEffect(effectName, effect.Intensity, effect.Duration)
		end)
	end
	
	if self._events.ImpactFrameRequested then
		self._events.ImpactFrameRequested.OnClientEvent:Connect(function(impactType: string, frameID: string, frame: any)
			self:TriggerImpactFrame(impactType, frame.Intensity)
		end)
	end
	
	if self._events.QualityLevelChanged then
		self._events.QualityLevelChanged.OnClientEvent:Connect(function(level: number, reason: string)
			self:SetQualityLevel(level)
		end)
	end
end

-- Placeholder methods for complex screen effects
function PolishEffectsController:_playChromaticAberration(id: string, intensity: number, duration: number): boolean
	if not self._chromaticFrame then return false end
	
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true)
	
	-- Create red/blue shifted images
	local redLayer = self._chromaticFrame:Clone()
	redLayer.ImageColor3 = Color3.new(1, 0, 0)
	redLayer.ImageTransparency = 0.8
	redLayer.Parent = self._chromaticFrame
	
	local blueLayer = self._chromaticFrame:Clone()
	blueLayer.ImageColor3 = Color3.new(0, 0, 1)
	blueLayer.ImageTransparency = 0.8
	blueLayer.Parent = self._chromaticFrame
	
	-- Animate layers
	local redTween = TweenService:Create(redLayer, tweenInfo, {Position = UDim2.new(0, intensity * 20, 0, 0)})
	local blueTween = TweenService:Create(blueLayer, tweenInfo, {Position = UDim2.new(0, -intensity * 20, 0, 0)})
	
	redTween:Play()
	blueTween:Play()
	
	-- Cleanup
	spawn(function()
		wait(duration)
		redLayer:Destroy()
		blueLayer:Destroy()
	end)
	
	return true
end

function PolishEffectsController:_playBloom(id: string, intensity: number, duration: number): boolean
	if not self._bloomFrame then return false end
	
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	local bloomEffect = Lighting:FindFirstChild("Bloom") or Instance.new("BloomEffect")
	bloomEffect.Parent = Lighting
	
	bloomEffect.Intensity = intensity
	bloomEffect.Size = 24
	bloomEffect.Threshold = 0.8
	
	-- Animate bloom intensity
	local bloomTween = TweenService:Create(bloomEffect, tweenInfo, {Intensity = 0})
	bloomTween:Play()
	
	-- Cleanup
	bloomTween.Completed:Connect(function()
		bloomEffect.Intensity = 0
	end)
	
	return true
end

function PolishEffectsController:_playVignette(id: string, intensity: number, duration: number): boolean
	if not self._vignetteFrame then return false end
	
	local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
	
	-- Animate transparency
	self._vignetteFrame.BackgroundTransparency = 1 - intensity
	local vignetteTween = TweenService:Create(self._vignetteFrame, tweenInfo, {BackgroundTransparency = 1})
	vignetteTween:Play()
	
	return true
end

function PolishEffectsController:_playDistortion(id: string, intensity: number, duration: number): boolean
	-- Placeholder for distortion effect
	return true
end

function PolishEffectsController:_executeImpactFrameSequence(impactType: string, intensity: number, duration: number, id: string, position: Vector3?) end

function PolishEffectsController:_getJuiceSequenceConfig(sequenceName: string, config: any?): any
	if sequenceName == "ButtonHover" then
		return {
			Properties = { Size = UDim2.fromScale(1.1, 1.1) },
			Duration = 0.1,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
		}
	elseif sequenceName == "ButtonUnhover" then
		return {
			Properties = { Size = UDim2.fromScale(1, 1) },
			Duration = 0.1,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
		}
	elseif sequenceName == "ButtonPress" then
		return {
			Properties = { Size = UDim2.fromScale(0.9, 0.9) },
			Duration = 0.05,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
		}
	elseif sequenceName == "ButtonRelease" then
		return {
			Properties = { Size = UDim2.fromScale(1.1, 1.1) },
			Duration = 0.1,
			EasingStyle = Enum.EasingStyle.Quad,
			EasingDirection = Enum.EasingDirection.Out,
		}
	elseif sequenceName == "CardReveal" then
		return {
			Properties = { Rotation = 360, Transparency = 0 },
			Duration = 0.5,
			EasingStyle = Enum.EasingStyle.Quint,
			EasingDirection = Enum.EasingDirection.Out,
		}
	end

	return nil
end

function PolishEffectsController:_createJuiceTween(target: Instance, sequence: any): Tween?
	if not target or not sequence then
		return nil
	end

	local tweenInfo = TweenInfo.new(
		sequence.Duration,
		sequence.EasingStyle,
		sequence.EasingDirection
	)

	return TweenService:Create(target, tweenInfo, sequence.Properties)
end

function PolishEffectsController:_getRarityIntensity(rarity: string): number
	local intensities = {
		Common = 0.2,
		Uncommon = 0.3,
		Rare = 0.5,
		Epic = 0.7,
		Legendary = 0.9,
		Ultimate = 1.0
	}
	
	return intensities[rarity] or intensities.Common
end

function PolishEffectsController:_getRarityDuration(rarity: string): number
	local durations = {
		Common = 0.5,
		Uncommon = 0.8,
		Rare = 1.0,
		Epic = 1.5,
		Legendary = 2.0,
		Ultimate = 2.5
	}
	
	return durations[rarity] or durations.Common
end

function PolishEffectsController:_getWorldPositionFromGui(guiObject: GuiObject): Vector3
	-- Convert GUI position to world position for particles
	local camera = workspace.CurrentCamera
	local screenPos = guiObject.AbsolutePosition + guiObject.AbsoluteSize / 2
	
	-- Project screen position to world space
	local ray = camera:ScreenPointToRay(screenPos.X, screenPos.Y)
	local distance = 10 -- Distance from camera
	
	return ray.Origin + ray.Direction * distance
end

function PolishEffectsController:_initializePerformanceMonitoring() end
function PolishEffectsController:_startEffectsUpdateLoop() end
function PolishEffectsController:_startPerformanceMonitoring() end
function PolishEffectsController:_adjustPerformanceForQuality(level: number) end

function PolishEffectsController:_logError(message: string)
	warn("[PolishEffectsController] ERROR: " .. message)
end

return PolishEffectsController.new() 
--- FILE: ./src/client/Controllers/AudioController.luau ---
--!strict
-- AudioController.luau
-- Client-side audio controller that interfaces with AudioService
-- Provides local audio playback with psychological timing and frequency layering

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local SoundService = game:GetService("SoundService")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)
local AudioTypes = require(ReplicatedStorage.Shared.Types.AudioTypes)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)

type AudioContext = AudioTypes.AudioContext
type PsychologicalAudioConfig = AudioTypes.PsychologicalAudioConfig
type AudioCue = AudioTypes.AudioCue
type AudioSequence = AudioTypes.AudioSequence

local Player = Players.LocalPlayer

local AudioController = {}
AudioController.__index = AudioController
setmetatable(AudioController, {__index = BaseController})

function AudioController.new()
	local self = BaseController.new("AudioController", {})
	setmetatable(self, AudioController)
	
	-- Audio state
	self._isEnabled = true
	self._masterVolume = GameConstants.Audio.MasterVolume
	self._sfxVolume = GameConstants.Audio.SFXVolume
	self._musicVolume = GameConstants.Audio.MusicVolume
	self._isMuted = false
	
	-- Local audio management
	self._activeSounds = {} :: {[string]: Sound}
	self._soundGroups = {} :: {[string]: SoundGroup}
	self._audioQueue = {} :: {AudioCue}
	self._localSequences = {} :: {[string]: AudioSequence}
	
	-- Psychological state tracking
	self._currentContext = {
		CurrentScene = "Menu",
		PlayerState = "Idle", 
		TensionLevel = 0.0,
		ExcitementLevel = 0.0,
		RecentActions = {},
		SessionLength = 0,
		LastMajorEvent = "SessionStart",
		NextExpectedEvent = "CardRoll"
	} :: AudioContext
	
	-- Performance tracking
	self._performanceMetrics = {
		LocalSounds = 0,
		QueuedSounds = 0,
		LatencyMS = 0
	}
	
	-- Audio events from server (using individual GetRemoteEvent calls)
	self._events = {
		AudioCueRequested = RemoteEventHandler:GetRemoteEvent("AudioCueRequested"),
		AudioSequenceRequested = RemoteEventHandler:GetRemoteEvent("AudioSequenceRequested"),
		AudioContextChanged = RemoteEventHandler:GetRemoteEvent("AudioContextChanged"),
		AudioSettingsChanged = RemoteEventHandler:GetRemoteEvent("AudioSettingsChanged"),
		PsychologicalEventTriggered = RemoteEventHandler:GetRemoteEvent("PsychologicalEventTriggered"),
		SpatialAudioUpdate = RemoteEventHandler:GetRemoteEvent("SpatialAudioUpdate")
	}
	
	return self
end

function AudioController:Initialize()
	self:_log("AudioController initializing...")
	
	-- Initialize sound service settings
	self:_initializeSoundService()
	
	-- Create sound groups for frequency layering
	self:_createSoundGroups()
	
	-- Setup remote event handlers
	self:_setupRemoteEventHandlers()
	
	-- Initialize user preferences
	self:_loadUserAudioSettings()
	
	self:_log("AudioController initialized successfully")
end

function AudioController:Start()
	self:_log("AudioController starting...")
	
	-- Start audio processing loop
	self:_startAudioProcessingLoop()
	
	-- Setup input handlers for audio controls
	self:_setupInputHandlers()
	
	-- Request initial audio context from server
	self:_requestAudioContextUpdate()
	
	self:_log("AudioController started successfully")
end

function AudioController:Stop()
	self:_log("AudioController stopping...")
	
	-- Stop all active audio
	self:StopAllAudio()
	
	-- Cleanup audio processing
	if self._audioProcessingConnection then
		self._audioProcessingConnection:Disconnect()
		self._audioProcessingConnection = nil
	end
	
	BaseController.Stop(self)
	self:_log("AudioController stopped")
end

-- Public API

-- Play audio cue with optional psychological configuration
function AudioController:PlayAudioCue(cueID: string, config: PsychologicalAudioConfig?): string
	if not self._isEnabled or self._isMuted then
		return ""
	end
	
	-- Generate local instance ID
	local instanceID = self:_generateInstanceID(cueID)
	
	-- Create audio cue
	local audioCue = self:_createAudioCue(cueID, config)
	if not audioCue then
		self:_logError("Failed to create audio cue: " .. cueID)
		return ""
	end
	
	-- Apply psychological timing if configured
	if config then
		self:_applyPsychologicalTiming(audioCue, config)
	end
	
	-- Play locally with frequency layering
	self:_playAudioCueLocally(audioCue, instanceID)
	
	-- Also request from server for synchronized experience
	if self._events.AudioCueRequested then
		self._events.AudioCueRequested:FireServer(cueID, config)
	end
	
	return instanceID
end

-- Play audio sequence with crossfading
function AudioController:PlayAudioSequence(sequenceID: string, config: PsychologicalAudioConfig?): string
	if not self._isEnabled or self._isMuted then
		return ""
	end
	
	local instanceID = self:_generateInstanceID(sequenceID)
	
	-- Request sequence from server
	if self._events.AudioSequenceRequested then
		self._events.AudioSequenceRequested:FireServer(sequenceID, config)
	end
	
	return instanceID
end

-- Update current audio context for psychological adaptation
function AudioController:UpdateAudioContext(context: AudioContext)
	self._currentContext = context
	
	-- Apply context-based audio changes
	self:_adaptToContext(context)
	
	-- Notify server of context change
	if self._events.AudioContextChanged then
		self._events.AudioContextChanged:FireServer(context)
	end
	
	self:_log("Audio context updated: " .. context.CurrentScene)
end

-- Trigger psychological audio event (e.g., card reveal, battle victory)
function AudioController:TriggerPsychologicalEvent(eventType: string, intensity: number, duration: number?)
	-- Update local context
	self._currentContext.TensionLevel = math.min(1.0, self._currentContext.TensionLevel + intensity * 0.3)
	self._currentContext.ExcitementLevel = math.min(1.0, self._currentContext.ExcitementLevel + intensity * 0.5)
	
	-- Play appropriate audio response
	local audioResponse = self:_createPsychologicalResponse(eventType, intensity)
	if audioResponse then
		self:PlayAudioCue(audioResponse, {
			RarityLevel = self:_intensityToRarity(intensity),
			DopamineProfile = {
				BuildupCurve = "exponential",
				PeakIntensity = intensity,
				SustainDuration = duration or 1.0,
				ReleaseCurve = "logarithmic",
				NextEventPrep = 0.5
			},
			PsychologicalTiming = {
				AnticipationDelay = 0.1,
				ImpactTiming = 0.05,
				ResolutionFade = 0.5,
				NextCuePrep = 0.2
			},
			FrequencyEmphasis = self:_getFrequencyEmphasisForEvent(eventType),
			SpatialEffects = intensity > 0.7,
			CompressionLevel = math.max(0.3, 1.0 - intensity)
		})
	end
	
	self:_log("Psychological event triggered: " .. eventType .. " (intensity: " .. intensity .. ")")
end

-- Audio volume controls
function AudioController:SetMasterVolume(volume: number)
	self._masterVolume = math.clamp(volume, 0.0, 1.0)
	self:_updateSoundGroupVolumes()
	self:_saveUserAudioSettings()
end

function AudioController:SetSFXVolume(volume: number)
	self._sfxVolume = math.clamp(volume, 0.0, 1.0)
	if self._soundGroups.SFX then
		self._soundGroups.SFX.Volume = self._sfxVolume * self._masterVolume
	end
	self:_saveUserAudioSettings()
end

function AudioController:SetMusicVolume(volume: number)
	self._musicVolume = math.clamp(volume, 0.0, 1.0)
	if self._soundGroups.Music then
		self._soundGroups.Music.Volume = self._musicVolume * self._masterVolume
	end
	self:_saveUserAudioSettings()
end

function AudioController:ToggleMute()
	self._isMuted = not self._isMuted
	
	if self._isMuted then
		self:StopAllAudio()
	end
	
	self:_updateSoundGroupVolumes()
	self:_saveUserAudioSettings()
	
	self:_log("Audio " .. (self._isMuted and "muted" or "unmuted"))
end

-- Stop specific audio instance
function AudioController:StopAudio(instanceID: string)
	if self._activeSounds[instanceID] then
		self._activeSounds[instanceID]:Stop()
		self._activeSounds[instanceID]:Destroy()
		self._activeSounds[instanceID] = nil
		self._performanceMetrics.LocalSounds = math.max(0, self._performanceMetrics.LocalSounds - 1)
	end
end

-- Stop all audio
function AudioController:StopAllAudio()
	for instanceID, sound in pairs(self._activeSounds) do
		sound:Stop()
		sound:Destroy()
	end
	self._activeSounds = {}
	self._localSequences = {}
	self._performanceMetrics.LocalSounds = 0
	
	self:_log("All audio stopped")
end

-- Get current audio state
function AudioController:GetAudioState()
	return {
		IsEnabled = self._isEnabled,
		IsMuted = self._isMuted,
		MasterVolume = self._masterVolume,
		SFXVolume = self._sfxVolume,
		MusicVolume = self._musicVolume,
		CurrentContext = self._currentContext,
		ActiveSounds = table.getn(self._activeSounds),
		PerformanceMetrics = self._performanceMetrics
	}
end

-- Private Methods

function AudioController:_initializeSoundService()
	-- Configure SoundService for optimal client experience
	SoundService.AmbientReverb = Enum.ReverbType.NoReverb
	SoundService.DistanceFactor = 3.33
	SoundService.DopplerScale = 1
	SoundService.RolloffScale = 1
end

function AudioController:_createSoundGroups()
	-- Create sound groups for frequency layering and categories
	local groupConfigs = {
		{name = "SFX", volume = self._sfxVolume},
		{name = "Music", volume = self._musicVolume},
		{name = "Voice", volume = 0.8},
		{name = "Ambient", volume = 0.6},
		-- Frequency-based groups
		{name = "SubBass", volume = 1.0},
		{name = "MidBass", volume = 1.0},
		{name = "Midrange", volume = 1.0},
		{name = "Presence", volume = 1.0},
		{name = "Brilliance", volume = 1.0}
	}
	
	for _, config in ipairs(groupConfigs) do
		local soundGroup = Instance.new("SoundGroup")
		soundGroup.Name = config.name
		soundGroup.Parent = SoundService
		soundGroup.Volume = config.volume * self._masterVolume
		self._soundGroups[config.name] = soundGroup
	end
end

function AudioController:_setupRemoteEventHandlers()
	-- Handle audio cue requests from server
	if self._events.AudioCueRequested then
		self._events.AudioCueRequested.OnClientEvent:Connect(function(cueID: string, instanceID: string, audioCue: AudioCue)
			-- Server confirmed audio cue, sync locally if needed
			self:_syncAudioCue(cueID, instanceID, audioCue)
		end)
	end
	
	-- Handle audio sequence requests from server
	if self._events.AudioSequenceRequested then
		self._events.AudioSequenceRequested.OnClientEvent:Connect(function(sequenceID: string, instanceID: string, sequence: AudioSequence)
			self:_playAudioSequenceLocally(sequence, instanceID)
		end)
	end
	
	-- Handle context changes from server
	if self._events.AudioContextChanged then
		self._events.AudioContextChanged.OnClientEvent:Connect(function(context: AudioContext)
			self._currentContext = context
			self:_adaptToContext(context)
		end)
	end
	
	-- Handle psychological events from server
	if self._events.PsychologicalEventTriggered then
		self._events.PsychologicalEventTriggered.OnClientEvent:Connect(function(eventType: string, intensity: number)
			-- Server triggered psychological event, enhance locally
			self:_enhancePsychologicalEvent(eventType, intensity)
		end)
	end
end

function AudioController:_setupInputHandlers()
	-- Setup audio control input (e.g., mute key)
	UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
		if gameProcessed then return end
		
		-- M key to toggle mute
		if input.KeyCode == Enum.KeyCode.M then
			self:ToggleMute()
		end
	end)
end

function AudioController:_startAudioProcessingLoop()
	self._audioProcessingConnection = RunService.Heartbeat:Connect(function(deltaTime)
		-- Update audio context based on gameplay
		self:_updateAudioContext(deltaTime)
		
		-- Process audio queue
		self:_processAudioQueue()
		
		-- Update performance metrics
		self:_updatePerformanceMetrics()
		
		-- Clean up finished sounds
		self:_cleanupFinishedSounds()
	end)
end

function AudioController:_generateInstanceID(baseID: string): string
	return "client_" .. baseID .. "_" .. tostring(tick()) .. "_" .. tostring(math.random(1000, 9999))
end

function AudioController:_createAudioCue(cueID: string, config: PsychologicalAudioConfig?): AudioCue?
	-- Create basic audio cue structure
	-- In a real implementation, this would load from an asset database
	return {
		ID = cueID,
		Name = cueID,
		SoundId = "rbxasset://sounds/" .. cueID .. ".mp3", -- Placeholder
		Volume = config and (1.0 - config.CompressionLevel) or 0.5,
		Pitch = 1.0,
		Duration = 1.0,
		Layers = {},
		Priority = 1,
		Category = "SFX",
		IsLooping = false,
		FadeInDuration = 0.1,
		FadeOutDuration = 0.1
	}
end

function AudioController:_playAudioCueLocally(audioCue: AudioCue, instanceID: string)
	local sound = Instance.new("Sound")
	sound.Name = instanceID
	sound.SoundId = audioCue.SoundId
	sound.Volume = audioCue.Volume * (self._isMuted and 0 or 1)
	sound.Pitch = audioCue.Pitch
	sound.Parent = self._soundGroups[audioCue.Category] or SoundService
	
	-- Apply timing precision
	local syncWindow = GameConstants.Audio.AudioSyncWindow
	wait(syncWindow) -- 2ms precision window
	
	sound:Play()
	
	-- Track sound
	self._activeSounds[instanceID] = sound
	self._performanceMetrics.LocalSounds = self._performanceMetrics.LocalSounds + 1
	
	-- Auto-cleanup when finished
	sound.Ended:Connect(function()
		self:StopAudio(instanceID)
	end)
end

function AudioController:_updateSoundGroupVolumes()
	local masterMultiplier = self._isMuted and 0 or self._masterVolume
	
	for groupName, soundGroup in pairs(self._soundGroups) do
		if groupName == "SFX" then
			soundGroup.Volume = self._sfxVolume * masterMultiplier
		elseif groupName == "Music" then
			soundGroup.Volume = self._musicVolume * masterMultiplier
		else
			soundGroup.Volume = masterMultiplier
		end
	end
end

function AudioController:_intensityToRarity(intensity: number): string
	if intensity >= 0.9 then return "Ultimate"
	elseif intensity >= 0.7 then return "Legendary"
	elseif intensity >= 0.5 then return "Epic"
	elseif intensity >= 0.3 then return "Rare"
	elseif intensity >= 0.1 then return "Uncommon"
	else return "Common"
	end
end

function AudioController:_getFrequencyEmphasisForEvent(eventType: string): {[string]: number}
	local emphasis = {}
	
	if eventType == "CardReveal" then
		emphasis.Presence = 1.3
		emphasis.Brilliance = 1.2
	elseif eventType == "BattleVictory" then
		emphasis.SubBass = 1.4
		emphasis.MidBass = 1.2
		emphasis.Brilliance = 1.3
	elseif eventType == "DopamineSpike" then
		emphasis.Midrange = 1.2
		emphasis.Presence = 1.4
		emphasis.Brilliance = 1.5
	end
	
	return emphasis
end

-- Placeholder methods for complex functionality
function AudioController:_loadUserAudioSettings() end
function AudioController:_saveUserAudioSettings() end
function AudioController:_requestAudioContextUpdate() end
function AudioController:_applyPsychologicalTiming(cue: AudioCue, config: PsychologicalAudioConfig) end
function AudioController:_syncAudioCue(cueID: string, instanceID: string, audioCue: AudioCue) end
function AudioController:_playAudioSequenceLocally(sequence: AudioSequence, instanceID: string) end
function AudioController:_adaptToContext(context: AudioContext) end
function AudioController:_enhancePsychologicalEvent(eventType: string, intensity: number) end
function AudioController:_updateAudioContext(deltaTime: number) end
function AudioController:_processAudioQueue() end
function AudioController:_updatePerformanceMetrics() end
function AudioController:_cleanupFinishedSounds() end
function AudioController:_createPsychologicalResponse(eventType: string, intensity: number): string? return "psychological_" .. eventType end

function AudioController:_logError(message: string)
	warn("[AudioController] ERROR: " .. message)
end

return AudioController.new() 
--- FILE: ./src/client/Controllers/TestSceneController.luau ---
--!strict
-- TestSceneController.luau
-- Simple test controller with a basic ROLL button for MVP testing

local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")

local BaseController = require(ReplicatedStorage.Shared.Core.BaseController)
local RemoteEventHandler = require(ReplicatedStorage.Shared.Core.RemoteEventHandler)
local GameConstants = require(ReplicatedStorage.Shared.Constants.GameConstants)

local Player = Players.LocalPlayer
local PlayerGui = Player:WaitForChild("PlayerGui")

local TestSceneController = {}
TestSceneController.__index = TestSceneController
setmetatable(TestSceneController, {__index = BaseController})

function TestSceneController.new()
	local self = BaseController.new("TestSceneController", {"PolishEffectsController", "CardRevealController"})
	setmetatable(self, TestSceneController)
	
	-- UI Elements
	self._testGui = nil
	self._rollButton = nil
	
	return self
end

function TestSceneController:Initialize()
	self:_log("TestSceneController initializing...")
	
	-- Create simple test UI
	self:_createTestUI()
	
	self:_log("TestSceneController initialized successfully")
end

function TestSceneController:Start()
	self:_log("TestSceneController starting...")
	
	-- Set up server event listeners
	self:_setupServerEventListeners()
	
	-- Connect roll button
	if self._rollButton then
		self._rollButton.MouseButton1Click:Connect(function()
			self:_performCardRoll()
		end)
		
		-- Enhance with visual effects
		local polishEffectsController = self.ServiceRegistry:GetService("PolishEffectsController")
		if polishEffectsController then
			polishEffectsController:EnhanceButton(self._rollButton)
		end
	end
	
	self:_log("Test scene ready! Click 'ROLL CARD' to test the core game loop")
end

function TestSceneController:Stop()
	self:_log("TestSceneController stopping...")
	
	-- Cleanup UI
	if self._testGui then
		self._testGui:Destroy()
		self._testGui = nil
	end
	
	BaseController.Stop(self)
	self:_log("TestSceneController stopped")
end

-- Private Methods

function TestSceneController:_createTestUI()
	-- Create main GUI
	self._testGui = Instance.new("ScreenGui")
	self._testGui.Name = "TestSceneGUI"
	self._testGui.Parent = PlayerGui
	self._testGui.ResetOnSpawn = false
	
	-- Create roll button
	self._rollButton = Instance.new("TextButton")
	self._rollButton.Name = "RollButton"
	self._rollButton.Size = UDim2.new(0, 200, 0, 80)
	self._rollButton.Position = UDim2.new(0.5, -100, 0.5, -40)
	self._rollButton.BackgroundColor3 = Color3.fromRGB(255, 215, 0) -- Gold
	self._rollButton.BorderSizePixel = 0
	self._rollButton.Text = "🎲 ROLL CARD"
	self._rollButton.TextColor3 = Color3.new(0, 0, 0)
	self._rollButton.TextSize = 24
	self._rollButton.TextScaled = true
	self._rollButton.Font = Enum.Font.GothamBold
	self._rollButton.Parent = self._testGui
	
	-- Add corner radius
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 12)
	corner.Parent = self._rollButton
	
	-- Add text padding
	local padding = Instance.new("UIPadding")
	padding.PaddingLeft = UDim.new(0, 8)
	padding.PaddingRight = UDim.new(0, 8)
	padding.PaddingTop = UDim.new(0, 4)
	padding.PaddingBottom = UDim.new(0, 4)
	padding.Parent = self._rollButton
end

function TestSceneController:_performCardRoll()
	self:_log("Performing card roll...")
	
	-- Disable button temporarily
	if self._rollButton then
		self._rollButton.Text = "Rolling..."
		self._rollButton.BackgroundColor3 = Color3.fromRGB(150, 150, 150)
	end
	
	-- Request card roll from server
	RemoteEventHandler:FireServer("RequestCardRoll", "Standard")
	
	-- Re-enable button after delay
	spawn(function()
		wait(3) -- Wait for roll sequence
		if self._rollButton then
			self._rollButton.Text = "🎲 ROLL CARD"
			self._rollButton.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		end
	end)
end

function TestSceneController:_setupServerEventListeners()
	-- Listen for card roll results
	RemoteEventHandler:ConnectRemoteEventClient("CardRollResult", function(rollResult)
		self:_handleCardRollResult(rollResult)
	end)
	
	-- Listen for card roll errors
	RemoteEventHandler:ConnectRemoteEventClient("CardRollError", function(errorMessage)
		self:_handleCardRollError(errorMessage)
	end)
end

function TestSceneController:_handleCardRollResult(rollResult: any)
	self:_log("Received card roll result!")
	
	-- Re-enable button
	if self._rollButton then
		self._rollButton.Text = "🎲 ROLL CARD"
		self._rollButton.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
	end
	
	-- Get the first card from the result
	if rollResult.Cards and #rollResult.Cards > 0 then
		local cardResult = rollResult.Cards[1]
		self:_log("Rolling card: " .. cardResult.Card.Name .. " (" .. cardResult.Rarity .. ")")
		
		-- Trigger card reveal
		local cardRevealController = self.ServiceRegistry:GetService("CardRevealController")
		if cardRevealController then
			cardRevealController:RevealSingleCard(cardResult)
		end
	end
end

function TestSceneController:_handleCardRollError(errorMessage: string)
	warn("[TestSceneController] Card roll failed: " .. errorMessage)
	
	-- Re-enable button
	if self._rollButton then
		self._rollButton.Text = "❌ ROLL FAILED"
		self._rollButton.BackgroundColor3 = Color3.fromRGB(255, 100, 100)
		
		-- Reset after delay
		spawn(function()
			wait(2)
			if self._rollButton then
				self._rollButton.Text = "🎲 ROLL CARD"
				self._rollButton.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
			end
		end)
	end
end

return TestSceneController.new() 
